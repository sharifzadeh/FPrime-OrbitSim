// ======================================================================
// \title  TimeValueSerializableAc.cpp
// \author Generated by fpp-to-cpp
// \brief  cpp file for TimeValue struct
// ======================================================================

#include "Fw/Time/TimeValueSerializableAc.hpp"
#include "Fw/Types/Assert.hpp"

namespace Fw {

  // ----------------------------------------------------------------------
  // Constructors
  // ----------------------------------------------------------------------

  TimeValue ::
    TimeValue() :
      Serializable(),
      m_timeBase(),
      m_timeContext(),
      m_seconds(),
      m_useconds()
  {

  }

  TimeValue ::
    TimeValue(
        TimeBase::T timeBase,
        FwTimeContextStoreType timeContext,
        U32 seconds,
        U32 useconds
    ) :
      Serializable(),
      m_timeBase(timeBase),
      m_timeContext(timeContext),
      m_seconds(seconds),
      m_useconds(useconds)
  {

  }

  TimeValue ::
    TimeValue(const TimeValue& obj) :
      Serializable(),
      m_timeBase(obj.m_timeBase),
      m_timeContext(obj.m_timeContext),
      m_seconds(obj.m_seconds),
      m_useconds(obj.m_useconds)
  {

  }

  // ----------------------------------------------------------------------
  // Operators
  // ----------------------------------------------------------------------

  TimeValue& TimeValue ::
    operator=(const TimeValue& obj)
  {
    if (this == &obj) {
      return *this;
    }

    set(obj.m_timeBase, obj.m_timeContext, obj.m_seconds, obj.m_useconds);
    return *this;
  }

  bool TimeValue ::
    operator==(const TimeValue& obj) const
  {
    if (this == &obj) { return true; }
    return (
      (this->m_timeBase == obj.m_timeBase) &&
      (this->m_timeContext == obj.m_timeContext) &&
      (this->m_seconds == obj.m_seconds) &&
      (this->m_useconds == obj.m_useconds)
    );
  }

  bool TimeValue ::
    operator!=(const TimeValue& obj) const
  {
    return !(*this == obj);
  }

#ifdef BUILD_UT

  std::ostream& operator<<(std::ostream& os, const TimeValue& obj) {
    Fw::String s;
    obj.toString(s);
    os << s.toChar();
    return os;
  }

#endif

  // ----------------------------------------------------------------------
  // Member functions
  // ----------------------------------------------------------------------

  Fw::SerializeStatus TimeValue ::
    serializeTo(
        Fw::SerialBufferBase& buffer,
        Fw::Endianness mode
    ) const
  {
    Fw::SerializeStatus status;

    status = buffer.serializeFrom(this->m_timeBase, mode);
    if (status != Fw::FW_SERIALIZE_OK) {
      return status;
    }
    status = buffer.serializeFrom(this->m_timeContext, mode);
    if (status != Fw::FW_SERIALIZE_OK) {
      return status;
    }
    status = buffer.serializeFrom(this->m_seconds, mode);
    if (status != Fw::FW_SERIALIZE_OK) {
      return status;
    }
    status = buffer.serializeFrom(this->m_useconds, mode);
    if (status != Fw::FW_SERIALIZE_OK) {
      return status;
    }

    return status;
  }

  Fw::SerializeStatus TimeValue ::
    deserializeFrom(
        Fw::SerialBufferBase& buffer,
        Fw::Endianness mode
    )
  {
    Fw::SerializeStatus status;

    status = buffer.deserializeTo(this->m_timeBase, mode);
    if (status != Fw::FW_SERIALIZE_OK) {
      return status;
    }
    status = buffer.deserializeTo(this->m_timeContext, mode);
    if (status != Fw::FW_SERIALIZE_OK) {
      return status;
    }
    status = buffer.deserializeTo(this->m_seconds, mode);
    if (status != Fw::FW_SERIALIZE_OK) {
      return status;
    }
    status = buffer.deserializeTo(this->m_useconds, mode);
    if (status != Fw::FW_SERIALIZE_OK) {
      return status;
    }

    return status;
  }

  FwSizeType TimeValue ::
    serializedSize() const
  {
    FwSizeType size = 0;
    size += TimeBase::SERIALIZED_SIZE;
    size += sizeof(FwTimeContextStoreType);
    size += sizeof(U32);
    size += sizeof(U32);
    return size;
  }

#if FW_SERIALIZABLE_TO_STRING

  void TimeValue ::
    toString(Fw::StringBase& sb) const
  {
    Fw::String tmp;
    sb = "( ";

    // Format timeBase
    sb += "timeBase = ";
    this->m_timeBase.toString(tmp);
    sb += tmp;
    sb += ", ";

    // Format timeContext
    sb += "timeContext = ";
    tmp.format("%" PRIu8 "", this->m_timeContext);
    sb += tmp;
    sb += ", ";

    // Format seconds
    sb += "seconds = ";
    tmp.format("%" PRIu32 "", this->m_seconds);
    sb += tmp;
    sb += ", ";

    // Format useconds
    sb += "useconds = ";
    tmp.format("%" PRIu32 "", this->m_useconds);
    sb += tmp;
    sb += " )";
  }

#endif

  // ----------------------------------------------------------------------
  // Setter functions
  // ----------------------------------------------------------------------

  void TimeValue ::
    set(
        TimeBase::T timeBase,
        FwTimeContextStoreType timeContext,
        U32 seconds,
        U32 useconds
    )
  {
    this->m_timeBase = timeBase;
    this->m_timeContext = timeContext;
    this->m_seconds = seconds;
    this->m_useconds = useconds;
  }

  void TimeValue ::
    set_timeBase(TimeBase::T timeBase)
  {
    this->m_timeBase = timeBase;
  }

  void TimeValue ::
    set_timeContext(FwTimeContextStoreType timeContext)
  {
    this->m_timeContext = timeContext;
  }

  void TimeValue ::
    set_seconds(U32 seconds)
  {
    this->m_seconds = seconds;
  }

  void TimeValue ::
    set_useconds(U32 useconds)
  {
    this->m_useconds = useconds;
  }

}
