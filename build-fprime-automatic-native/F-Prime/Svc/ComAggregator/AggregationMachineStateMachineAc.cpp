// ======================================================================
// \title  AggregationMachineStateMachineAc.cpp
// \author Generated by fpp-to-cpp
// \brief  cpp file for AggregationMachine state machine
// ======================================================================

#include "Fw/Types/Assert.hpp"
#include "Svc/ComAggregator/AggregationMachineStateMachineAc.hpp"

namespace Svc {

  // ----------------------------------------------------------------------
  // Constructors and Destructors
  // ----------------------------------------------------------------------

  AggregationMachineStateMachineBase ::
    AggregationMachineStateMachineBase()
  {

  }

  AggregationMachineStateMachineBase ::
    ~AggregationMachineStateMachineBase()
  {

  }

  // ----------------------------------------------------------------------
  // Initialization
  // ----------------------------------------------------------------------

  void AggregationMachineStateMachineBase ::
    initBase(const FwEnumStoreType id)
  {
    this->m_id = id;
    // Enter the initial target of the state machine
    this->enter_WAIT_STATUS(Signal::__FPRIME_AC_INITIAL_TRANSITION);
  }

  // ----------------------------------------------------------------------
  // Getter functions
  // ----------------------------------------------------------------------

  AggregationMachineStateMachineBase::State AggregationMachineStateMachineBase ::
    getState() const
  {
    return this->m_state;
  }

  // ----------------------------------------------------------------------
  // Send signal functions
  // ----------------------------------------------------------------------

  void AggregationMachineStateMachineBase ::
    sendSignal_timeout()
  {
    switch (this->m_state) {
      case State::FILL:
        if (this->guard_isNotEmpty(Signal::timeout)) {
          // Do the actions for the transition
          this->action_doSend(Signal::timeout);
          // Enter the target
          this->enter_WAIT_STATUS(Signal::timeout);
        }
        break;
      case State::WAIT_STATUS:
        break;
      default:
        FW_ASSERT(0, static_cast<FwAssertArgType>(this->m_state));
        break;
    }
  }

  void AggregationMachineStateMachineBase ::
    sendSignal_fill(const Svc::ComDataContextPair& value)
  {
    switch (this->m_state) {
      case State::FILL:
        // Enter the target
        this->enter_IS_FULL_THEN_SEND(Signal::fill, value);
        break;
      case State::WAIT_STATUS:
        // Do the actions for the transition
        this->action_doHold(Signal::fill, value);
        break;
      default:
        FW_ASSERT(0, static_cast<FwAssertArgType>(this->m_state));
        break;
    }
  }

  void AggregationMachineStateMachineBase ::
    sendSignal_status(const Fw::Success& value)
  {
    switch (this->m_state) {
      case State::FILL:
        // Do the actions for the transition
        this->action_assertNoStatus(Signal::status);
        break;
      case State::WAIT_STATUS:
        // Enter the target
        this->enter_IS_GOOD_STATUS(Signal::status, value);
        break;
      default:
        FW_ASSERT(0, static_cast<FwAssertArgType>(this->m_state));
        break;
    }
  }

  // ----------------------------------------------------------------------
  // State and choice entry
  // ----------------------------------------------------------------------

  void AggregationMachineStateMachineBase ::
    enter_FILL(Signal signal)
  {
    // Update the state
    this->m_state = State::FILL;
  }

  void AggregationMachineStateMachineBase ::
    enter_WAIT_STATUS(Signal signal)
  {
    // Update the state
    this->m_state = State::WAIT_STATUS;
  }

  void AggregationMachineStateMachineBase ::
    enter_IS_GOOD_STATUS(
        Signal signal,
        const Fw::Success& value
    )
  {
    if (this->guard_isGood(signal, value)) {
      // Do the actions for the transition
      this->action_doClear(signal);
      // Enter the target
      this->enter_FILL(signal);
    }
    else {
      // Enter the target
      this->enter_WAIT_STATUS(signal);
    }
  }

  void AggregationMachineStateMachineBase ::
    enter_WILL_FILL_THEN_SEND(
        Signal signal,
        const Svc::ComDataContextPair& value
    )
  {
    if (this->guard_willFill(signal, value)) {
      // Do the actions for the transition
      this->action_doFill(signal, value);
      this->action_doSend(signal);
      // Enter the target
      this->enter_WAIT_STATUS(signal);
    }
    else {
      // Do the actions for the transition
      this->action_doFill(signal, value);
      // Enter the target
      this->enter_FILL(signal);
    }
  }

  void AggregationMachineStateMachineBase ::
    enter_IS_FULL_THEN_SEND(
        Signal signal,
        const Svc::ComDataContextPair& value
    )
  {
    if (this->guard_isFull(signal, value)) {
      // Do the actions for the transition
      this->action_doHold(signal, value);
      this->action_doSend(signal);
      // Enter the target
      this->enter_WAIT_STATUS(signal);
    }
    else {
      // Enter the target
      this->enter_WILL_FILL_THEN_SEND(signal, value);
    }
  }

}
