// ======================================================================
// \title  CmdSequencerComponentAc.hpp
// \author Generated by fpp-to-cpp
// \brief  hpp file for CmdSequencer component base class
// ======================================================================

#ifndef Svc_CmdSequencerComponentAc_HPP
#define Svc_CmdSequencerComponentAc_HPP

#include <atomic>

#include "Fw/Cmd/CmdPortAc.hpp"
#include "Fw/Cmd/CmdRegPortAc.hpp"
#include "Fw/Cmd/CmdResponsePortAc.hpp"
#include "Fw/Cmd/CmdString.hpp"
#include "Fw/Com/ComPortAc.hpp"
#include "Fw/Comp/ActiveComponentBase.hpp"
#include "Fw/FPrimeBasicTypes.hpp"
#include "Fw/Log/LogPortAc.hpp"
#include "Fw/Log/LogString.hpp"
#if FW_ENABLE_TEXT_LOGGING == 1
#include "Fw/Log/LogTextPortAc.hpp"
#endif
#include "Fw/Port/InputSerializePort.hpp"
#include "Fw/Port/OutputSerializePort.hpp"
#include "Fw/Time/TimePortAc.hpp"
#include "Fw/Tlm/TlmPortAc.hpp"
#include "Fw/Tlm/TlmString.hpp"
#include "Svc/CmdSequencer/CmdSequencer_BlockStateEnumAc.hpp"
#include "Svc/CmdSequencer/CmdSequencer_FileReadStageEnumAc.hpp"
#include "Svc/CmdSequencer/CmdSequencer_SeqModeEnumAc.hpp"
#include "Svc/Ping/PingPortAc.hpp"
#include "Svc/Sched/SchedPortAc.hpp"
#include "Svc/Seq/CmdSeqCancelPortAc.hpp"
#include "Svc/Seq/CmdSeqInPortAc.hpp"
#include "default/config/FwOpcodeTypeAliasAc.hpp"

namespace Svc {

  //! \class CmdSequencerComponentBase
  //! \brief Auto-generated base for CmdSequencer component
  //!
  //! A component for running command sequences
  class CmdSequencerComponentBase :
    public Fw::ActiveComponentBase
  {

      // ----------------------------------------------------------------------
      // Friend classes
      // ----------------------------------------------------------------------

      //! Friend class tester to support autocoded test harness
      friend class CmdSequencerTesterBase;
      //! Friend class tester implementation to support white-box testing
      friend class CmdSequencerTester;

    protected:

      // ----------------------------------------------------------------------
      // Constants
      // ----------------------------------------------------------------------

      //! Enumerations for numbers of special input ports
      enum {
        NUM_CMDIN_INPUT_PORTS = 1,
      };

      //! Enumerations for numbers of typed input ports
      enum {
        NUM_CMDRESPONSEIN_INPUT_PORTS = 1,
        NUM_PINGIN_INPUT_PORTS = 1,
        NUM_SCHEDIN_INPUT_PORTS = 1,
        NUM_SEQCANCELIN_INPUT_PORTS = 1,
        NUM_SEQRUNIN_INPUT_PORTS = 1,
      };

      //! Enumerations for numbers of special output ports
      enum {
        NUM_LOGTEXT_OUTPUT_PORTS = 1,
        NUM_CMDREGOUT_OUTPUT_PORTS = 1,
        NUM_CMDRESPONSEOUT_OUTPUT_PORTS = 1,
        NUM_LOGOUT_OUTPUT_PORTS = 1,
        NUM_TIMECALLER_OUTPUT_PORTS = 1,
        NUM_TLMOUT_OUTPUT_PORTS = 1,
      };

      //! Enumerations for numbers of typed output ports
      enum {
        NUM_COMCMDOUT_OUTPUT_PORTS = 1,
        NUM_PINGOUT_OUTPUT_PORTS = 1,
        NUM_SEQDONE_OUTPUT_PORTS = 1,
        NUM_SEQSTARTOUT_OUTPUT_PORTS = 1,
      };

      //! Command opcodes
      enum {
        OPCODE_CS_RUN = 0x0, //!< Run a command sequence file
        OPCODE_CS_VALIDATE = 0x1, //!< Validate a command sequence file
        OPCODE_CS_CANCEL = 0x2, //!< Cancel a command sequence
        OPCODE_CS_START = 0x3, //!< Start running a command sequence
        OPCODE_CS_STEP = 0x4, //!< Perform one step in a command sequence. Valid only if CmdSequencer is in MANUAL run mode.
        OPCODE_CS_AUTO = 0x5, //!< Set the run mode to AUTO.
        OPCODE_CS_MANUAL = 0x6, //!< Set the run mode to MANUAL.
        OPCODE_CS_JOIN_WAIT = 0x7, //!< Wait for sequences that are running to finish. Allow user to run multiple seq files in SEQ_NO_BLOCK mode then wait for them to finish before allowing more seq run request.
      };

      //! Event IDs
      enum {
        EVENTID_CS_SEQUENCELOADED = 0x0, //!< Sequence file was successfully loaded.
        EVENTID_CS_SEQUENCECANCELED = 0x1, //!< A command sequence was successfully canceled.
        EVENTID_CS_FILEREADERROR = 0x2, //!< The Sequence File Loader could not read the sequence file.
        EVENTID_CS_FILEINVALID = 0x3, //!< The sequence file format was invalid.
        EVENTID_CS_RECORDINVALID = 0x4, //!< The format of a command record was invalid.
        EVENTID_CS_FILESIZEERROR = 0x5, //!< The sequence file was too large.
        EVENTID_CS_FILENOTFOUND = 0x6, //!< The sequence file was not found
        EVENTID_CS_FILECRCFAILURE = 0x7, //!< The sequence file validation failed
        EVENTID_CS_COMMANDCOMPLETE = 0x8, //!< The Command Sequencer issued a command and received a success status in return.
        EVENTID_CS_SEQUENCECOMPLETE = 0x9, //!< A command sequence successfully completed.
        EVENTID_CS_COMMANDERROR = 0xa, //!< The Command Sequencer issued a command and received an error status in return.
        EVENTID_CS_INVALIDMODE = 0xb, //!< The Command Sequencer received a command that was invalid for its current mode.
        EVENTID_CS_RECORDMISMATCH = 0xc, //!< Number of records in header doesn't match number in file
        EVENTID_CS_TIMEBASEMISMATCH = 0xd, //!< The running time base doesn't match the time base in the sequence files
        EVENTID_CS_TIMECONTEXTMISMATCH = 0xe, //!< The running time base doesn't match the time base in the sequence files
        EVENTID_CS_PORTSEQUENCESTARTED = 0xf, //!< A local port request to run a sequence was started
        EVENTID_CS_UNEXPECTEDCOMPLETION = 0x10, //!< A command status came back when no sequence was running
        EVENTID_CS_MODESWITCHED = 0x11, //!< Switched step mode
        EVENTID_CS_NOSEQUENCEACTIVE = 0x12, //!< A sequence related command came with no active sequence
        EVENTID_CS_SEQUENCEVALID = 0x13, //!< A sequence passed validation
        EVENTID_CS_SEQUENCETIMEOUT = 0x14, //!< A sequence passed validation
        EVENTID_CS_CMDSTEPPED = 0x15, //!< A command in a sequence was stepped through
        EVENTID_CS_CMDSTARTED = 0x16, //!< A manual sequence was started
        EVENTID_CS_JOINWAITING = 0x17, //!< Wait for the current running sequence file complete
        EVENTID_CS_JOINWAITINGNOTCOMPLETE = 0x18, //!< Cannot run new sequence when current sequence file is still running.
        EVENTID_CS_NORECORDS = 0x19,
      };

      //! Channel IDs
      enum {
        CHANNELID_CS_LOADCOMMANDS = 0x0, //!< Channel ID for CS_LoadCommands
        CHANNELID_CS_CANCELCOMMANDS = 0x1, //!< Channel ID for CS_CancelCommands
        CHANNELID_CS_ERRORS = 0x2, //!< Channel ID for CS_Errors
        CHANNELID_CS_COMMANDSEXECUTED = 0x3, //!< Channel ID for CS_CommandsExecuted
        CHANNELID_CS_SEQUENCESCOMPLETED = 0x4, //!< Channel ID for CS_SequencesCompleted
      };

    public:

      // ----------------------------------------------------------------------
      // Component initialization
      // ----------------------------------------------------------------------

      //! Initialize CmdSequencerComponentBase object
      void init(
          FwSizeType queueDepth, //!< The queue depth
          FwEnumStoreType instance = 0 //!< The instance number
      );

    public:

      // ----------------------------------------------------------------------
      // Getters for special input ports
      // ----------------------------------------------------------------------

      //! Get special input port at index
      //!
      //! \return cmdIn[portNum]
      Fw::InputCmdPort* get_cmdIn_InputPort(
          FwIndexType portNum //!< The port number
      );

    public:

      // ----------------------------------------------------------------------
      // Getters for typed input ports
      // ----------------------------------------------------------------------

      //! Get typed input port at index
      //!
      //! \return cmdResponseIn[portNum]
      Fw::InputCmdResponsePort* get_cmdResponseIn_InputPort(
          FwIndexType portNum //!< The port number
      );

      //! Get typed input port at index
      //!
      //! \return pingIn[portNum]
      Svc::InputPingPort* get_pingIn_InputPort(
          FwIndexType portNum //!< The port number
      );

      //! Get typed input port at index
      //!
      //! \return schedIn[portNum]
      Svc::InputSchedPort* get_schedIn_InputPort(
          FwIndexType portNum //!< The port number
      );

      //! Get typed input port at index
      //!
      //! \return seqCancelIn[portNum]
      Svc::InputCmdSeqCancelPort* get_seqCancelIn_InputPort(
          FwIndexType portNum //!< The port number
      );

      //! Get typed input port at index
      //!
      //! \return seqRunIn[portNum]
      Svc::InputCmdSeqInPort* get_seqRunIn_InputPort(
          FwIndexType portNum //!< The port number
      );

    public:

      // ----------------------------------------------------------------------
      // Connect input ports to special output ports
      // ----------------------------------------------------------------------

#if FW_ENABLE_TEXT_LOGGING == 1

      //! Connect port to LogText[portNum]
      void set_LogText_OutputPort(
          FwIndexType portNum, //!< The port number
          Fw::InputLogTextPort* port //!< The input port
      );

#endif

      //! Connect port to cmdRegOut[portNum]
      void set_cmdRegOut_OutputPort(
          FwIndexType portNum, //!< The port number
          Fw::InputCmdRegPort* port //!< The input port
      );

      //! Connect port to cmdResponseOut[portNum]
      void set_cmdResponseOut_OutputPort(
          FwIndexType portNum, //!< The port number
          Fw::InputCmdResponsePort* port //!< The input port
      );

      //! Connect port to logOut[portNum]
      void set_logOut_OutputPort(
          FwIndexType portNum, //!< The port number
          Fw::InputLogPort* port //!< The input port
      );

      //! Connect port to timeCaller[portNum]
      void set_timeCaller_OutputPort(
          FwIndexType portNum, //!< The port number
          Fw::InputTimePort* port //!< The input port
      );

      //! Connect port to tlmOut[portNum]
      void set_tlmOut_OutputPort(
          FwIndexType portNum, //!< The port number
          Fw::InputTlmPort* port //!< The input port
      );

    public:

      // ----------------------------------------------------------------------
      // Connect typed input ports to typed output ports
      // ----------------------------------------------------------------------

      //! Connect port to comCmdOut[portNum]
      void set_comCmdOut_OutputPort(
          FwIndexType portNum, //!< The port number
          Fw::InputComPort* port //!< The input port
      );

      //! Connect port to pingOut[portNum]
      void set_pingOut_OutputPort(
          FwIndexType portNum, //!< The port number
          Svc::InputPingPort* port //!< The input port
      );

      //! Connect port to seqDone[portNum]
      void set_seqDone_OutputPort(
          FwIndexType portNum, //!< The port number
          Fw::InputCmdResponsePort* port //!< The input port
      );

      //! Connect port to seqStartOut[portNum]
      void set_seqStartOut_OutputPort(
          FwIndexType portNum, //!< The port number
          Svc::InputCmdSeqInPort* port //!< The input port
      );

#if FW_PORT_SERIALIZATION

    public:

      // ----------------------------------------------------------------------
      // Connect serial input ports to special output ports
      // ----------------------------------------------------------------------

#if FW_ENABLE_TEXT_LOGGING == 1

      //! Connect port to LogText[portNum]
      void set_LogText_OutputPort(
          FwIndexType portNum, //!< The port number
          Fw::InputSerializePort* port //!< The port
      );

#endif

      //! Connect port to cmdRegOut[portNum]
      void set_cmdRegOut_OutputPort(
          FwIndexType portNum, //!< The port number
          Fw::InputSerializePort* port //!< The port
      );

      //! Connect port to cmdResponseOut[portNum]
      void set_cmdResponseOut_OutputPort(
          FwIndexType portNum, //!< The port number
          Fw::InputSerializePort* port //!< The port
      );

      //! Connect port to logOut[portNum]
      void set_logOut_OutputPort(
          FwIndexType portNum, //!< The port number
          Fw::InputSerializePort* port //!< The port
      );

      //! Connect port to timeCaller[portNum]
      void set_timeCaller_OutputPort(
          FwIndexType portNum, //!< The port number
          Fw::InputSerializePort* port //!< The port
      );

      //! Connect port to tlmOut[portNum]
      void set_tlmOut_OutputPort(
          FwIndexType portNum, //!< The port number
          Fw::InputSerializePort* port //!< The port
      );

#endif

#if FW_PORT_SERIALIZATION

    public:

      // ----------------------------------------------------------------------
      // Connect serial input ports to typed output ports
      // ----------------------------------------------------------------------

      //! Connect port to comCmdOut[portNum]
      void set_comCmdOut_OutputPort(
          FwIndexType portNum, //!< The port number
          Fw::InputSerializePort* port //!< The port
      );

      //! Connect port to pingOut[portNum]
      void set_pingOut_OutputPort(
          FwIndexType portNum, //!< The port number
          Fw::InputSerializePort* port //!< The port
      );

      //! Connect port to seqDone[portNum]
      void set_seqDone_OutputPort(
          FwIndexType portNum, //!< The port number
          Fw::InputSerializePort* port //!< The port
      );

      //! Connect port to seqStartOut[portNum]
      void set_seqStartOut_OutputPort(
          FwIndexType portNum, //!< The port number
          Fw::InputSerializePort* port //!< The port
      );

#endif

    public:

      // ----------------------------------------------------------------------
      // Command registration
      // ----------------------------------------------------------------------

      //! \brief Register commands with the Command Dispatcher
      //!
      //! Connect the dispatcher first
      void regCommands();

    protected:

      // ----------------------------------------------------------------------
      // Component construction and destruction
      // ----------------------------------------------------------------------

      //! Construct CmdSequencerComponentBase object
      CmdSequencerComponentBase(
          const char* compName = "" //!< The component name
      );

      //! Destroy CmdSequencerComponentBase object
      virtual ~CmdSequencerComponentBase();

    protected:

      // ----------------------------------------------------------------------
      // Getters for numbers of special input ports
      // ----------------------------------------------------------------------

      //! Get the number of cmdIn input ports
      //!
      //! \return The number of cmdIn input ports
      static constexpr FwIndexType getNum_cmdIn_InputPorts() {
        return NUM_CMDIN_INPUT_PORTS;
      }

    protected:

      // ----------------------------------------------------------------------
      // Getters for numbers of typed input ports
      // ----------------------------------------------------------------------

      //! Get the number of cmdResponseIn input ports
      //!
      //! \return The number of cmdResponseIn input ports
      static constexpr FwIndexType getNum_cmdResponseIn_InputPorts() {
        return NUM_CMDRESPONSEIN_INPUT_PORTS;
      }

      //! Get the number of pingIn input ports
      //!
      //! \return The number of pingIn input ports
      static constexpr FwIndexType getNum_pingIn_InputPorts() {
        return NUM_PINGIN_INPUT_PORTS;
      }

      //! Get the number of schedIn input ports
      //!
      //! \return The number of schedIn input ports
      static constexpr FwIndexType getNum_schedIn_InputPorts() {
        return NUM_SCHEDIN_INPUT_PORTS;
      }

      //! Get the number of seqCancelIn input ports
      //!
      //! \return The number of seqCancelIn input ports
      static constexpr FwIndexType getNum_seqCancelIn_InputPorts() {
        return NUM_SEQCANCELIN_INPUT_PORTS;
      }

      //! Get the number of seqRunIn input ports
      //!
      //! \return The number of seqRunIn input ports
      static constexpr FwIndexType getNum_seqRunIn_InputPorts() {
        return NUM_SEQRUNIN_INPUT_PORTS;
      }

    protected:

      // ----------------------------------------------------------------------
      // Getters for numbers of special output ports
      // ----------------------------------------------------------------------

#if FW_ENABLE_TEXT_LOGGING == 1

      //! Get the number of LogText output ports
      //!
      //! \return The number of LogText output ports
      static constexpr FwIndexType getNum_LogText_OutputPorts() {
        return NUM_LOGTEXT_OUTPUT_PORTS;
      }

#endif

      //! Get the number of cmdRegOut output ports
      //!
      //! \return The number of cmdRegOut output ports
      static constexpr FwIndexType getNum_cmdRegOut_OutputPorts() {
        return NUM_CMDREGOUT_OUTPUT_PORTS;
      }

      //! Get the number of cmdResponseOut output ports
      //!
      //! \return The number of cmdResponseOut output ports
      static constexpr FwIndexType getNum_cmdResponseOut_OutputPorts() {
        return NUM_CMDRESPONSEOUT_OUTPUT_PORTS;
      }

      //! Get the number of logOut output ports
      //!
      //! \return The number of logOut output ports
      static constexpr FwIndexType getNum_logOut_OutputPorts() {
        return NUM_LOGOUT_OUTPUT_PORTS;
      }

      //! Get the number of timeCaller output ports
      //!
      //! \return The number of timeCaller output ports
      static constexpr FwIndexType getNum_timeCaller_OutputPorts() {
        return NUM_TIMECALLER_OUTPUT_PORTS;
      }

      //! Get the number of tlmOut output ports
      //!
      //! \return The number of tlmOut output ports
      static constexpr FwIndexType getNum_tlmOut_OutputPorts() {
        return NUM_TLMOUT_OUTPUT_PORTS;
      }

    protected:

      // ----------------------------------------------------------------------
      // Getters for numbers of typed output ports
      // ----------------------------------------------------------------------

      //! Get the number of comCmdOut output ports
      //!
      //! \return The number of comCmdOut output ports
      static constexpr FwIndexType getNum_comCmdOut_OutputPorts() {
        return NUM_COMCMDOUT_OUTPUT_PORTS;
      }

      //! Get the number of pingOut output ports
      //!
      //! \return The number of pingOut output ports
      static constexpr FwIndexType getNum_pingOut_OutputPorts() {
        return NUM_PINGOUT_OUTPUT_PORTS;
      }

      //! Get the number of seqDone output ports
      //!
      //! \return The number of seqDone output ports
      static constexpr FwIndexType getNum_seqDone_OutputPorts() {
        return NUM_SEQDONE_OUTPUT_PORTS;
      }

      //! Get the number of seqStartOut output ports
      //!
      //! \return The number of seqStartOut output ports
      static constexpr FwIndexType getNum_seqStartOut_OutputPorts() {
        return NUM_SEQSTARTOUT_OUTPUT_PORTS;
      }

    protected:

      // ----------------------------------------------------------------------
      // Connection status queries for special output ports
      // ----------------------------------------------------------------------

#if FW_ENABLE_TEXT_LOGGING == 1

      //! Check whether port LogText is connected
      //!
      //! \return Whether port LogText is connected
      bool isConnected_LogText_OutputPort(
          FwIndexType portNum //!< The port number
      );

#endif

      //! Check whether port cmdRegOut is connected
      //!
      //! \return Whether port cmdRegOut is connected
      bool isConnected_cmdRegOut_OutputPort(
          FwIndexType portNum //!< The port number
      );

      //! Check whether port cmdResponseOut is connected
      //!
      //! \return Whether port cmdResponseOut is connected
      bool isConnected_cmdResponseOut_OutputPort(
          FwIndexType portNum //!< The port number
      );

      //! Check whether port logOut is connected
      //!
      //! \return Whether port logOut is connected
      bool isConnected_logOut_OutputPort(
          FwIndexType portNum //!< The port number
      );

      //! Check whether port timeCaller is connected
      //!
      //! \return Whether port timeCaller is connected
      bool isConnected_timeCaller_OutputPort(
          FwIndexType portNum //!< The port number
      );

      //! Check whether port tlmOut is connected
      //!
      //! \return Whether port tlmOut is connected
      bool isConnected_tlmOut_OutputPort(
          FwIndexType portNum //!< The port number
      );

    protected:

      // ----------------------------------------------------------------------
      // Connection status queries for typed output ports
      // ----------------------------------------------------------------------

      //! Check whether port comCmdOut is connected
      //!
      //! \return Whether port comCmdOut is connected
      bool isConnected_comCmdOut_OutputPort(
          FwIndexType portNum //!< The port number
      );

      //! Check whether port pingOut is connected
      //!
      //! \return Whether port pingOut is connected
      bool isConnected_pingOut_OutputPort(
          FwIndexType portNum //!< The port number
      );

      //! Check whether port seqDone is connected
      //!
      //! \return Whether port seqDone is connected
      bool isConnected_seqDone_OutputPort(
          FwIndexType portNum //!< The port number
      );

      //! Check whether port seqStartOut is connected
      //!
      //! \return Whether port seqStartOut is connected
      bool isConnected_seqStartOut_OutputPort(
          FwIndexType portNum //!< The port number
      );

    protected:

      // ----------------------------------------------------------------------
      // Handlers to implement for typed input ports
      // ----------------------------------------------------------------------

      //! Handler for input port cmdResponseIn
      virtual void cmdResponseIn_handler(
          FwIndexType portNum, //!< The port number
          FwOpcodeType opCode, //!< Command Op Code
          U32 cmdSeq, //!< Command Sequence
          const Fw::CmdResponse& response //!< The command response argument
      ) = 0;

      //! Handler for input port pingIn
      virtual void pingIn_handler(
          FwIndexType portNum, //!< The port number
          U32 key //!< Value to return to pinger
      ) = 0;

      //! Handler for input port schedIn
      virtual void schedIn_handler(
          FwIndexType portNum, //!< The port number
          U32 context //!< The call order
      ) = 0;

      //! Handler for input port seqCancelIn
      virtual void seqCancelIn_handler(
          FwIndexType portNum //!< The port number
      ) = 0;

      //! Handler for input port seqRunIn
      virtual void seqRunIn_handler(
          FwIndexType portNum, //!< The port number
          const Fw::StringBase& filename //!< The sequence file
      ) = 0;

    protected:

      // ----------------------------------------------------------------------
      // Port handler base-class functions for typed input ports
      //
      // Call these functions directly to bypass the corresponding ports
      // ----------------------------------------------------------------------

      //! Handler base-class function for input port cmdResponseIn
      void cmdResponseIn_handlerBase(
          FwIndexType portNum, //!< The port number
          FwOpcodeType opCode, //!< Command Op Code
          U32 cmdSeq, //!< Command Sequence
          const Fw::CmdResponse& response //!< The command response argument
      );

      //! Handler base-class function for input port pingIn
      void pingIn_handlerBase(
          FwIndexType portNum, //!< The port number
          U32 key //!< Value to return to pinger
      );

      //! Handler base-class function for input port schedIn
      void schedIn_handlerBase(
          FwIndexType portNum, //!< The port number
          U32 context //!< The call order
      );

      //! Handler base-class function for input port seqCancelIn
      void seqCancelIn_handlerBase(
          FwIndexType portNum //!< The port number
      );

      //! Handler base-class function for input port seqRunIn
      void seqRunIn_handlerBase(
          FwIndexType portNum, //!< The port number
          const Fw::StringBase& filename //!< The sequence file
      );

    protected:

      // ----------------------------------------------------------------------
      // Pre-message hooks for typed async input ports
      //
      // Each of these functions is invoked just before processing a message
      // on the corresponding port. By default, they do nothing. You can
      // override them to provide specific pre-message behavior.
      // ----------------------------------------------------------------------

      //! Pre-message hook for async input port cmdResponseIn
      virtual void cmdResponseIn_preMsgHook(
          FwIndexType portNum, //!< The port number
          FwOpcodeType opCode, //!< Command Op Code
          U32 cmdSeq, //!< Command Sequence
          const Fw::CmdResponse& response //!< The command response argument
      );

      //! Pre-message hook for async input port pingIn
      virtual void pingIn_preMsgHook(
          FwIndexType portNum, //!< The port number
          U32 key //!< Value to return to pinger
      );

      //! Pre-message hook for async input port schedIn
      virtual void schedIn_preMsgHook(
          FwIndexType portNum, //!< The port number
          U32 context //!< The call order
      );

      //! Pre-message hook for async input port seqCancelIn
      virtual void seqCancelIn_preMsgHook(
          FwIndexType portNum //!< The port number
      );

      //! Pre-message hook for async input port seqRunIn
      virtual void seqRunIn_preMsgHook(
          FwIndexType portNum, //!< The port number
          const Fw::StringBase& filename //!< The sequence file
      );

    protected:

      // ----------------------------------------------------------------------
      // Invocation functions for typed output ports
      // ----------------------------------------------------------------------

      //! Invoke output port comCmdOut
      void comCmdOut_out(
          FwIndexType portNum, //!< The port number
          Fw::ComBuffer& data, //!< Buffer containing packet data
          U32 context //!< Call context value; meaning chosen by user
      );

      //! Invoke output port pingOut
      void pingOut_out(
          FwIndexType portNum, //!< The port number
          U32 key //!< Value to return to pinger
      );

      //! Invoke output port seqDone
      void seqDone_out(
          FwIndexType portNum, //!< The port number
          FwOpcodeType opCode, //!< Command Op Code
          U32 cmdSeq, //!< Command Sequence
          const Fw::CmdResponse& response //!< The command response argument
      );

      //! Invoke output port seqStartOut
      void seqStartOut_out(
          FwIndexType portNum, //!< The port number
          const Fw::StringBase& filename //!< The sequence file
      );

    protected:

      // ----------------------------------------------------------------------
      // Command response
      // ----------------------------------------------------------------------

      //! Emit command response
      void cmdResponse_out(
          FwOpcodeType opCode, //!< The opcode
          U32 cmdSeq, //!< The command sequence number
          Fw::CmdResponse response //!< The command response
      );

    protected:

      // ----------------------------------------------------------------------
      // Command handlers to implement
      // ----------------------------------------------------------------------

      //! Handler for command CS_RUN
      //!
      //! Run a command sequence file
      virtual void CS_RUN_cmdHandler(
          FwOpcodeType opCode, //!< The opcode
          U32 cmdSeq, //!< The command sequence number
          const Fw::CmdStringArg& fileName, //!< The name of the sequence file
          Svc::CmdSequencer_BlockState block //!< Return command status when complete or not
      ) = 0;

      //! Handler for command CS_VALIDATE
      //!
      //! Validate a command sequence file
      virtual void CS_VALIDATE_cmdHandler(
          FwOpcodeType opCode, //!< The opcode
          U32 cmdSeq, //!< The command sequence number
          const Fw::CmdStringArg& fileName //!< The name of the sequence file
      ) = 0;

      //! Handler for command CS_CANCEL
      //!
      //! Cancel a command sequence
      virtual void CS_CANCEL_cmdHandler(
          FwOpcodeType opCode, //!< The opcode
          U32 cmdSeq //!< The command sequence number
      ) = 0;

      //! Handler for command CS_START
      //!
      //! Start running a command sequence
      virtual void CS_START_cmdHandler(
          FwOpcodeType opCode, //!< The opcode
          U32 cmdSeq //!< The command sequence number
      ) = 0;

      //! Handler for command CS_STEP
      //!
      //! Perform one step in a command sequence. Valid only if CmdSequencer is in MANUAL run mode.
      virtual void CS_STEP_cmdHandler(
          FwOpcodeType opCode, //!< The opcode
          U32 cmdSeq //!< The command sequence number
      ) = 0;

      //! Handler for command CS_AUTO
      //!
      //! Set the run mode to AUTO.
      virtual void CS_AUTO_cmdHandler(
          FwOpcodeType opCode, //!< The opcode
          U32 cmdSeq //!< The command sequence number
      ) = 0;

      //! Handler for command CS_MANUAL
      //!
      //! Set the run mode to MANUAL.
      virtual void CS_MANUAL_cmdHandler(
          FwOpcodeType opCode, //!< The opcode
          U32 cmdSeq //!< The command sequence number
      ) = 0;

      //! Handler for command CS_JOIN_WAIT
      //!
      //! Wait for sequences that are running to finish. Allow user to run multiple seq files in SEQ_NO_BLOCK mode then wait for them to finish before allowing more seq run request.
      virtual void CS_JOIN_WAIT_cmdHandler(
          FwOpcodeType opCode, //!< The opcode
          U32 cmdSeq //!< The command sequence number
      ) = 0;

    protected:

      // ----------------------------------------------------------------------
      // Command handler base-class functions
      //
      // Call these functions directly to bypass the command input port
      // ----------------------------------------------------------------------

      //! Base-class handler function for command CS_RUN
      //!
      //! Run a command sequence file
      void CS_RUN_cmdHandlerBase(
          FwOpcodeType opCode, //!< The opcode
          U32 cmdSeq, //!< The command sequence number
          Fw::CmdArgBuffer& args //!< The command argument buffer
      );

      //! Base-class handler function for command CS_VALIDATE
      //!
      //! Validate a command sequence file
      void CS_VALIDATE_cmdHandlerBase(
          FwOpcodeType opCode, //!< The opcode
          U32 cmdSeq, //!< The command sequence number
          Fw::CmdArgBuffer& args //!< The command argument buffer
      );

      //! Base-class handler function for command CS_CANCEL
      //!
      //! Cancel a command sequence
      void CS_CANCEL_cmdHandlerBase(
          FwOpcodeType opCode, //!< The opcode
          U32 cmdSeq, //!< The command sequence number
          Fw::CmdArgBuffer& args //!< The command argument buffer
      );

      //! Base-class handler function for command CS_START
      //!
      //! Start running a command sequence
      void CS_START_cmdHandlerBase(
          FwOpcodeType opCode, //!< The opcode
          U32 cmdSeq, //!< The command sequence number
          Fw::CmdArgBuffer& args //!< The command argument buffer
      );

      //! Base-class handler function for command CS_STEP
      //!
      //! Perform one step in a command sequence. Valid only if CmdSequencer is in MANUAL run mode.
      void CS_STEP_cmdHandlerBase(
          FwOpcodeType opCode, //!< The opcode
          U32 cmdSeq, //!< The command sequence number
          Fw::CmdArgBuffer& args //!< The command argument buffer
      );

      //! Base-class handler function for command CS_AUTO
      //!
      //! Set the run mode to AUTO.
      void CS_AUTO_cmdHandlerBase(
          FwOpcodeType opCode, //!< The opcode
          U32 cmdSeq, //!< The command sequence number
          Fw::CmdArgBuffer& args //!< The command argument buffer
      );

      //! Base-class handler function for command CS_MANUAL
      //!
      //! Set the run mode to MANUAL.
      void CS_MANUAL_cmdHandlerBase(
          FwOpcodeType opCode, //!< The opcode
          U32 cmdSeq, //!< The command sequence number
          Fw::CmdArgBuffer& args //!< The command argument buffer
      );

      //! Base-class handler function for command CS_JOIN_WAIT
      //!
      //! Wait for sequences that are running to finish. Allow user to run multiple seq files in SEQ_NO_BLOCK mode then wait for them to finish before allowing more seq run request.
      void CS_JOIN_WAIT_cmdHandlerBase(
          FwOpcodeType opCode, //!< The opcode
          U32 cmdSeq, //!< The command sequence number
          Fw::CmdArgBuffer& args //!< The command argument buffer
      );

    protected:

      // ----------------------------------------------------------------------
      // Pre-message hooks for async commands
      //
      // Each of these functions is invoked just before processing the
      // corresponding command. By default they do nothing. You can
      // override them to provide specific pre-command behavior.
      // ----------------------------------------------------------------------

      //! Pre-message hook for command CS_RUN
      virtual void CS_RUN_preMsgHook(
          FwOpcodeType opCode, //!< The opcode
          U32 cmdSeq //!< The command sequence number
      );

      //! Pre-message hook for command CS_VALIDATE
      virtual void CS_VALIDATE_preMsgHook(
          FwOpcodeType opCode, //!< The opcode
          U32 cmdSeq //!< The command sequence number
      );

      //! Pre-message hook for command CS_CANCEL
      virtual void CS_CANCEL_preMsgHook(
          FwOpcodeType opCode, //!< The opcode
          U32 cmdSeq //!< The command sequence number
      );

      //! Pre-message hook for command CS_START
      virtual void CS_START_preMsgHook(
          FwOpcodeType opCode, //!< The opcode
          U32 cmdSeq //!< The command sequence number
      );

      //! Pre-message hook for command CS_STEP
      virtual void CS_STEP_preMsgHook(
          FwOpcodeType opCode, //!< The opcode
          U32 cmdSeq //!< The command sequence number
      );

      //! Pre-message hook for command CS_AUTO
      virtual void CS_AUTO_preMsgHook(
          FwOpcodeType opCode, //!< The opcode
          U32 cmdSeq //!< The command sequence number
      );

      //! Pre-message hook for command CS_MANUAL
      virtual void CS_MANUAL_preMsgHook(
          FwOpcodeType opCode, //!< The opcode
          U32 cmdSeq //!< The command sequence number
      );

      //! Pre-message hook for command CS_JOIN_WAIT
      virtual void CS_JOIN_WAIT_preMsgHook(
          FwOpcodeType opCode, //!< The opcode
          U32 cmdSeq //!< The command sequence number
      );

    protected:

      // ----------------------------------------------------------------------
      // Event logging functions
      // ----------------------------------------------------------------------

      //! Log event CS_SequenceLoaded
      //!
      //! Sequence file was successfully loaded.
      void log_ACTIVITY_LO_CS_SequenceLoaded(
          const Fw::StringBase& fileName //!< The name of the sequence file
      ) const;

      //! Log event CS_SequenceCanceled
      //!
      //! A command sequence was successfully canceled.
      void log_ACTIVITY_HI_CS_SequenceCanceled(
          const Fw::StringBase& fileName //!< The name of the sequence file
      ) const;

      //! Log event CS_FileReadError
      //!
      //! The Sequence File Loader could not read the sequence file.
      void log_WARNING_HI_CS_FileReadError(
          const Fw::StringBase& fileName //!< The name of the sequence file
      ) const;

      //! Log event CS_FileInvalid
      //!
      //! The sequence file format was invalid.
      void log_WARNING_HI_CS_FileInvalid(
          const Fw::StringBase& fileName, //!< The name of the sequence file
          Svc::CmdSequencer_FileReadStage stage, //!< The read stage
          I32 error //!< The error code
      ) const;

      //! Log event CS_RecordInvalid
      //!
      //! The format of a command record was invalid.
      void log_WARNING_HI_CS_RecordInvalid(
          const Fw::StringBase& fileName, //!< The name of the sequence file
          U32 recordNumber, //!< The record number
          I32 error //!< The error code
      ) const;

      //! Log event CS_FileSizeError
      //!
      //! The sequence file was too large.
      void log_WARNING_HI_CS_FileSizeError(
          const Fw::StringBase& fileName, //!< The name of the sequence file
          U32 size //!< Invalid size
      ) const;

      //! Log event CS_FileNotFound
      //!
      //! The sequence file was not found
      void log_WARNING_HI_CS_FileNotFound(
          const Fw::StringBase& fileName //!< The sequence file
      ) const;

      //! Log event CS_FileCrcFailure
      //!
      //! The sequence file validation failed
      void log_WARNING_HI_CS_FileCrcFailure(
          const Fw::StringBase& fileName, //!< The sequence file
          U32 storedCRC, //!< The CRC stored in the file
          U32 computedCRC //!< The CRC computed over the file
      ) const;

      //! Log event CS_CommandComplete
      //!
      //! The Command Sequencer issued a command and received a success status in return.
      void log_ACTIVITY_LO_CS_CommandComplete(
          const Fw::StringBase& fileName, //!< The name of the sequence file
          U32 recordNumber, //!< The record number of the command
          FwOpcodeType opCode //!< The command opcode
      ) const;

      //! Log event CS_SequenceComplete
      //!
      //! A command sequence successfully completed.
      void log_ACTIVITY_HI_CS_SequenceComplete(
          const Fw::StringBase& fileName //!< The name of the sequence file
      ) const;

      //! Log event CS_CommandError
      //!
      //! The Command Sequencer issued a command and received an error status in return.
      void log_WARNING_HI_CS_CommandError(
          const Fw::StringBase& fileName, //!< The name of the sequence file
          U32 recordNumber, //!< The record number
          FwOpcodeType opCode, //!< The opcode
          U32 errorStatus //!< The error status
      ) const;

      //! Log event CS_InvalidMode
      //!
      //! The Command Sequencer received a command that was invalid for its current mode.
      void log_WARNING_HI_CS_InvalidMode() const;

      //! Log event CS_RecordMismatch
      //!
      //! Number of records in header doesn't match number in file
      void log_WARNING_HI_CS_RecordMismatch(
          const Fw::StringBase& fileName, //!< The name of the sequence file
          U32 header_records, //!< The number of records in the header
          U32 extra_bytes //!< The number of bytes beyond last record
      ) const;

      //! Log event CS_TimeBaseMismatch
      //!
      //! The running time base doesn't match the time base in the sequence files
      void log_WARNING_HI_CS_TimeBaseMismatch(
          const Fw::StringBase& fileName, //!< The name of the sequence file
          U16 time_base, //!< The current time
          U16 seq_time_base //!< The sequence time base
      ) const;

      //! Log event CS_TimeContextMismatch
      //!
      //! The running time base doesn't match the time base in the sequence files
      void log_WARNING_HI_CS_TimeContextMismatch(
          const Fw::StringBase& fileName, //!< The name of the sequence file
          U8 currTimeBase, //!< The current time base
          U8 seqTimeBase //!< The sequence time base
      ) const;

      //! Log event CS_PortSequenceStarted
      //!
      //! A local port request to run a sequence was started
      void log_ACTIVITY_HI_CS_PortSequenceStarted(
          const Fw::StringBase& filename //!< The sequence file
      ) const;

      //! Log event CS_UnexpectedCompletion
      //!
      //! A command status came back when no sequence was running
      void log_WARNING_HI_CS_UnexpectedCompletion(
          FwOpcodeType opcode //!< The reported opcode
      ) const;

      //! Log event CS_ModeSwitched
      //!
      //! Switched step mode
      void log_ACTIVITY_HI_CS_ModeSwitched(
          Svc::CmdSequencer_SeqMode mode //!< The new mode
      ) const;

      //! Log event CS_NoSequenceActive
      //!
      //! A sequence related command came with no active sequence
      void log_WARNING_LO_CS_NoSequenceActive() const;

      //! Log event CS_SequenceValid
      //!
      //! A sequence passed validation
      void log_ACTIVITY_HI_CS_SequenceValid(
          const Fw::StringBase& filename //!< The sequence file
      ) const;

      //! Log event CS_SequenceTimeout
      //!
      //! A sequence passed validation
      void log_WARNING_HI_CS_SequenceTimeout(
          const Fw::StringBase& filename, //!< The sequence file
          U32 command //!< The command that timed out
      ) const;

      //! Log event CS_CmdStepped
      //!
      //! A command in a sequence was stepped through
      void log_ACTIVITY_HI_CS_CmdStepped(
          const Fw::StringBase& filename, //!< The sequence file
          U32 command //!< The command that was stepped
      ) const;

      //! Log event CS_CmdStarted
      //!
      //! A manual sequence was started
      void log_ACTIVITY_HI_CS_CmdStarted(
          const Fw::StringBase& filename //!< The sequence file
      ) const;

      //! Log event CS_JoinWaiting
      //!
      //! Wait for the current running sequence file complete
      void log_ACTIVITY_HI_CS_JoinWaiting(
          const Fw::StringBase& filename, //!< The sequence file
          U32 recordNumber, //!< The record number
          FwOpcodeType opCode //!< The opcode
      ) const;

      //! Log event CS_JoinWaitingNotComplete
      //!
      //! Cannot run new sequence when current sequence file is still running.
      void log_WARNING_HI_CS_JoinWaitingNotComplete() const;

      //! Log event CS_NoRecords
      void log_WARNING_LO_CS_NoRecords(
          const Fw::StringBase& fileName //!< The name of the sequence file
      ) const;

    protected:

      // ----------------------------------------------------------------------
      // Telemetry write functions
      // ----------------------------------------------------------------------

      //! Write telemetry channel CS_LoadCommands
      //!
      //! The number of Load commands executed
      void tlmWrite_CS_LoadCommands(
          U32 arg, //!< The telemetry value
          Fw::Time _tlmTime = Fw::Time() //!< Timestamp. Default: unspecified, request from getTime port
      ) const;

      //! Write telemetry channel CS_CancelCommands
      //!
      //! The number of Cancel commands executed
      void tlmWrite_CS_CancelCommands(
          U32 arg, //!< The telemetry value
          Fw::Time _tlmTime = Fw::Time() //!< Timestamp. Default: unspecified, request from getTime port
      ) const;

      //! Write telemetry channel CS_Errors
      //!
      //! The number of errors that have occurred
      void tlmWrite_CS_Errors(
          U32 arg, //!< The telemetry value
          Fw::Time _tlmTime = Fw::Time() //!< Timestamp. Default: unspecified, request from getTime port
      ) const;

      //! Write telemetry channel CS_CommandsExecuted
      //!
      //! The number of commands executed across all sequences.
      void tlmWrite_CS_CommandsExecuted(
          U32 arg, //!< The telemetry value
          Fw::Time _tlmTime = Fw::Time() //!< Timestamp. Default: unspecified, request from getTime port
      ) const;

      //! Write telemetry channel CS_SequencesCompleted
      //!
      //! The number of sequences completed.
      void tlmWrite_CS_SequencesCompleted(
          U32 arg, //!< The telemetry value
          Fw::Time _tlmTime = Fw::Time() //!< Timestamp. Default: unspecified, request from getTime port
      ) const;

    protected:

      // ----------------------------------------------------------------------
      // Time
      // ----------------------------------------------------------------------

      //! Get the time
      //!
      //! \\return The current time
      Fw::Time getTime() const;

    private:

      // ----------------------------------------------------------------------
      // Message dispatch functions
      // ----------------------------------------------------------------------

      //! Called in the message loop to dispatch a message from the queue
      virtual MsgDispatchStatus doDispatch();

    private:

      // ----------------------------------------------------------------------
      // Calls for messages received on special input ports
      // ----------------------------------------------------------------------

      //! Callback for port cmdIn
      static void m_p_cmdIn_in(
          Fw::PassiveComponentBase* callComp, //!< The component instance
          FwIndexType portNum, //!< The port number
          FwOpcodeType opCode, //!< Command Op Code
          U32 cmdSeq, //!< Command Sequence
          Fw::CmdArgBuffer& args //!< Buffer containing arguments
      );

    private:

      // ----------------------------------------------------------------------
      // Calls for messages received on typed input ports
      // ----------------------------------------------------------------------

      //! Callback for port cmdResponseIn
      static void m_p_cmdResponseIn_in(
          Fw::PassiveComponentBase* callComp, //!< The component instance
          FwIndexType portNum, //!< The port number
          FwOpcodeType opCode, //!< Command Op Code
          U32 cmdSeq, //!< Command Sequence
          const Fw::CmdResponse& response //!< The command response argument
      );

      //! Callback for port pingIn
      static void m_p_pingIn_in(
          Fw::PassiveComponentBase* callComp, //!< The component instance
          FwIndexType portNum, //!< The port number
          U32 key //!< Value to return to pinger
      );

      //! Callback for port schedIn
      static void m_p_schedIn_in(
          Fw::PassiveComponentBase* callComp, //!< The component instance
          FwIndexType portNum, //!< The port number
          U32 context //!< The call order
      );

      //! Callback for port seqCancelIn
      static void m_p_seqCancelIn_in(
          Fw::PassiveComponentBase* callComp, //!< The component instance
          FwIndexType portNum //!< The port number
      );

      //! Callback for port seqRunIn
      static void m_p_seqRunIn_in(
          Fw::PassiveComponentBase* callComp, //!< The component instance
          FwIndexType portNum, //!< The port number
          const Fw::StringBase& filename //!< The sequence file
      );

    private:

      // ----------------------------------------------------------------------
      // Special input ports
      // ----------------------------------------------------------------------

      //! Input port cmdIn
      Fw::InputCmdPort m_cmdIn_InputPort[NUM_CMDIN_INPUT_PORTS];

    private:

      // ----------------------------------------------------------------------
      // Typed input ports
      // ----------------------------------------------------------------------

      //! Input port cmdResponseIn
      Fw::InputCmdResponsePort m_cmdResponseIn_InputPort[NUM_CMDRESPONSEIN_INPUT_PORTS];

      //! Input port pingIn
      Svc::InputPingPort m_pingIn_InputPort[NUM_PINGIN_INPUT_PORTS];

      //! Input port schedIn
      Svc::InputSchedPort m_schedIn_InputPort[NUM_SCHEDIN_INPUT_PORTS];

      //! Input port seqCancelIn
      Svc::InputCmdSeqCancelPort m_seqCancelIn_InputPort[NUM_SEQCANCELIN_INPUT_PORTS];

      //! Input port seqRunIn
      Svc::InputCmdSeqInPort m_seqRunIn_InputPort[NUM_SEQRUNIN_INPUT_PORTS];

    private:

      // ----------------------------------------------------------------------
      // Special output ports
      // ----------------------------------------------------------------------

#if FW_ENABLE_TEXT_LOGGING == 1

      //! Output port LogText
      Fw::OutputLogTextPort m_LogText_OutputPort[NUM_LOGTEXT_OUTPUT_PORTS];

#endif

      //! Output port cmdRegOut
      Fw::OutputCmdRegPort m_cmdRegOut_OutputPort[NUM_CMDREGOUT_OUTPUT_PORTS];

      //! Output port cmdResponseOut
      Fw::OutputCmdResponsePort m_cmdResponseOut_OutputPort[NUM_CMDRESPONSEOUT_OUTPUT_PORTS];

      //! Output port logOut
      Fw::OutputLogPort m_logOut_OutputPort[NUM_LOGOUT_OUTPUT_PORTS];

      //! Output port timeCaller
      Fw::OutputTimePort m_timeCaller_OutputPort[NUM_TIMECALLER_OUTPUT_PORTS];

      //! Output port tlmOut
      Fw::OutputTlmPort m_tlmOut_OutputPort[NUM_TLMOUT_OUTPUT_PORTS];

    private:

      // ----------------------------------------------------------------------
      // Typed output ports
      // ----------------------------------------------------------------------

      //! Output port comCmdOut
      Fw::OutputComPort m_comCmdOut_OutputPort[NUM_COMCMDOUT_OUTPUT_PORTS];

      //! Output port pingOut
      Svc::OutputPingPort m_pingOut_OutputPort[NUM_PINGOUT_OUTPUT_PORTS];

      //! Output port seqDone
      Fw::OutputCmdResponsePort m_seqDone_OutputPort[NUM_SEQDONE_OUTPUT_PORTS];

      //! Output port seqStartOut
      Svc::OutputCmdSeqInPort m_seqStartOut_OutputPort[NUM_SEQSTARTOUT_OUTPUT_PORTS];

  };

}

#endif
