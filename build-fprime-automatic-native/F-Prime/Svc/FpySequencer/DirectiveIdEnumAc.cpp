// ======================================================================
// \title  DirectiveIdEnumAc.cpp
// \author Generated by fpp-to-cpp
// \brief  cpp file for DirectiveId enum
// ======================================================================

#include <cstring>
#include <limits>

#include "Fw/Types/Assert.hpp"
#include "Svc/FpySequencer/DirectiveIdEnumAc.hpp"

namespace Svc {

  namespace Fpy {

    // ----------------------------------------------------------------------
    // Operators
    // ----------------------------------------------------------------------

    DirectiveId& DirectiveId ::
      operator=(const DirectiveId& obj)
    {
      this->e = obj.e;
      return *this;
    }

    DirectiveId& DirectiveId ::
      operator=(T e1)
    {
      this->e = e1;
      return *this;
    }

#ifdef BUILD_UT

    std::ostream& operator<<(std::ostream& os, const DirectiveId& obj) {
      Fw::String s;
      obj.toString(s);
      os << s;
      return os;
    }

#endif

    // ----------------------------------------------------------------------
    // Member functions
    // ----------------------------------------------------------------------

    bool DirectiveId ::
      isValid() const
    {
      return ((e >= INVALID) && (e <= STORE));
    }

    Fw::SerializeStatus DirectiveId ::
      serializeTo(
          Fw::SerialBufferBase& buffer,
          Fw::Endianness mode
      ) const
    {
      const Fw::SerializeStatus status = buffer.serializeFrom(
          static_cast<SerialType>(this->e),
          mode
      );
      return status;
    }

    Fw::SerializeStatus DirectiveId ::
      deserializeFrom(
          Fw::SerialBufferBase& buffer,
          Fw::Endianness mode
      )
    {
      SerialType es;
      Fw::SerializeStatus status = buffer.deserializeTo(es, mode);
      if (status == Fw::FW_SERIALIZE_OK) {
        this->e = static_cast<T>(es);
        if (!this->isValid()) {
          status = Fw::FW_DESERIALIZE_FORMAT_ERROR;
        }
      }
      return status;
    }

#if FW_SERIALIZABLE_TO_STRING

    void DirectiveId ::
      toString(Fw::StringBase& sb) const
    {
      Fw::String s;
      switch (e) {
        case INVALID:
          s = "INVALID";
          break;
        case WAIT_REL:
          s = "WAIT_REL";
          break;
        case WAIT_ABS:
          s = "WAIT_ABS";
          break;
        case GOTO:
          s = "GOTO";
          break;
        case IF:
          s = "IF";
          break;
        case NO_OP:
          s = "NO_OP";
          break;
        case PUSH_TLM_VAL:
          s = "PUSH_TLM_VAL";
          break;
        case PUSH_PRM:
          s = "PUSH_PRM";
          break;
        case CONST_CMD:
          s = "CONST_CMD";
          break;
        case OR:
          s = "OR";
          break;
        case AND:
          s = "AND";
          break;
        case IEQ:
          s = "IEQ";
          break;
        case INE:
          s = "INE";
          break;
        case ULT:
          s = "ULT";
          break;
        case ULE:
          s = "ULE";
          break;
        case UGT:
          s = "UGT";
          break;
        case UGE:
          s = "UGE";
          break;
        case SLT:
          s = "SLT";
          break;
        case SLE:
          s = "SLE";
          break;
        case SGT:
          s = "SGT";
          break;
        case SGE:
          s = "SGE";
          break;
        case FEQ:
          s = "FEQ";
          break;
        case FNE:
          s = "FNE";
          break;
        case FLT:
          s = "FLT";
          break;
        case FLE:
          s = "FLE";
          break;
        case FGT:
          s = "FGT";
          break;
        case FGE:
          s = "FGE";
          break;
        case NOT:
          s = "NOT";
          break;
        case FPTOSI:
          s = "FPTOSI";
          break;
        case FPTOUI:
          s = "FPTOUI";
          break;
        case SITOFP:
          s = "SITOFP";
          break;
        case UITOFP:
          s = "UITOFP";
          break;
        case ADD:
          s = "ADD";
          break;
        case SUB:
          s = "SUB";
          break;
        case MUL:
          s = "MUL";
          break;
        case UDIV:
          s = "UDIV";
          break;
        case SDIV:
          s = "SDIV";
          break;
        case UMOD:
          s = "UMOD";
          break;
        case SMOD:
          s = "SMOD";
          break;
        case FADD:
          s = "FADD";
          break;
        case FSUB:
          s = "FSUB";
          break;
        case FMUL:
          s = "FMUL";
          break;
        case FDIV:
          s = "FDIV";
          break;
        case FPOW:
          s = "FPOW";
          break;
        case FLOG:
          s = "FLOG";
          break;
        case FMOD:
          s = "FMOD";
          break;
        case FPEXT:
          s = "FPEXT";
          break;
        case FPTRUNC:
          s = "FPTRUNC";
          break;
        case SIEXT_8_64:
          s = "SIEXT_8_64";
          break;
        case SIEXT_16_64:
          s = "SIEXT_16_64";
          break;
        case SIEXT_32_64:
          s = "SIEXT_32_64";
          break;
        case ZIEXT_8_64:
          s = "ZIEXT_8_64";
          break;
        case ZIEXT_16_64:
          s = "ZIEXT_16_64";
          break;
        case ZIEXT_32_64:
          s = "ZIEXT_32_64";
          break;
        case ITRUNC_64_8:
          s = "ITRUNC_64_8";
          break;
        case ITRUNC_64_16:
          s = "ITRUNC_64_16";
          break;
        case ITRUNC_64_32:
          s = "ITRUNC_64_32";
          break;
        case EXIT:
          s = "EXIT";
          break;
        case ALLOCATE:
          s = "ALLOCATE";
          break;
        case STORE_CONST_OFFSET:
          s = "STORE_CONST_OFFSET";
          break;
        case LOAD:
          s = "LOAD";
          break;
        case PUSH_VAL:
          s = "PUSH_VAL";
          break;
        case DISCARD:
          s = "DISCARD";
          break;
        case MEMCMP:
          s = "MEMCMP";
          break;
        case STACK_CMD:
          s = "STACK_CMD";
          break;
        case PUSH_TLM_VAL_AND_TIME:
          s = "PUSH_TLM_VAL_AND_TIME";
          break;
        case PUSH_TIME:
          s = "PUSH_TIME";
          break;
        case SET_FLAG:
          s = "SET_FLAG";
          break;
        case GET_FLAG:
          s = "GET_FLAG";
          break;
        case GET_FIELD:
          s = "GET_FIELD";
          break;
        case PEEK:
          s = "PEEK";
          break;
        case STORE:
          s = "STORE";
          break;
        default:
          s = "[invalid]";
          break;
      }
      sb.format("%s (%" PRIu8 ")", s.toChar(), e);
    }

#elif FW_ENABLE_TEXT_LOGGING

    void DirectiveId ::
      toString(Fw::StringBase& sb) const
    {
      sb.format("%" PRIu8 "", e);
    }

#endif

  }

}
