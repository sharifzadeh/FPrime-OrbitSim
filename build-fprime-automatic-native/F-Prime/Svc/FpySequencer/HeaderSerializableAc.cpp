// ======================================================================
// \title  HeaderSerializableAc.cpp
// \author Generated by fpp-to-cpp
// \brief  cpp file for Header struct
// ======================================================================

#include "Fw/Types/Assert.hpp"
#include "Svc/FpySequencer/HeaderSerializableAc.hpp"

namespace Svc {

  namespace Fpy {

    // ----------------------------------------------------------------------
    // Constructors
    // ----------------------------------------------------------------------

    Header ::
      Header() :
        Serializable(),
        m_majorVersion(),
        m_minorVersion(),
        m_patchVersion(),
        m_schemaVersion(),
        m_argumentCount(),
        m_statementCount(),
        m_bodySize()
    {

    }

    Header ::
      Header(
          U8 majorVersion,
          U8 minorVersion,
          U8 patchVersion,
          U8 schemaVersion,
          U8 argumentCount,
          U16 statementCount,
          U32 bodySize
      ) :
        Serializable(),
        m_majorVersion(majorVersion),
        m_minorVersion(minorVersion),
        m_patchVersion(patchVersion),
        m_schemaVersion(schemaVersion),
        m_argumentCount(argumentCount),
        m_statementCount(statementCount),
        m_bodySize(bodySize)
    {

    }

    Header ::
      Header(const Header& obj) :
        Serializable(),
        m_majorVersion(obj.m_majorVersion),
        m_minorVersion(obj.m_minorVersion),
        m_patchVersion(obj.m_patchVersion),
        m_schemaVersion(obj.m_schemaVersion),
        m_argumentCount(obj.m_argumentCount),
        m_statementCount(obj.m_statementCount),
        m_bodySize(obj.m_bodySize)
    {

    }

    // ----------------------------------------------------------------------
    // Operators
    // ----------------------------------------------------------------------

    Header& Header ::
      operator=(const Header& obj)
    {
      if (this == &obj) {
        return *this;
      }

      set(obj.m_majorVersion, obj.m_minorVersion, obj.m_patchVersion, obj.m_schemaVersion, obj.m_argumentCount, obj.m_statementCount, obj.m_bodySize);
      return *this;
    }

    bool Header ::
      operator==(const Header& obj) const
    {
      if (this == &obj) { return true; }
      return (
        (this->m_majorVersion == obj.m_majorVersion) &&
        (this->m_minorVersion == obj.m_minorVersion) &&
        (this->m_patchVersion == obj.m_patchVersion) &&
        (this->m_schemaVersion == obj.m_schemaVersion) &&
        (this->m_argumentCount == obj.m_argumentCount) &&
        (this->m_statementCount == obj.m_statementCount) &&
        (this->m_bodySize == obj.m_bodySize)
      );
    }

    bool Header ::
      operator!=(const Header& obj) const
    {
      return !(*this == obj);
    }

#ifdef BUILD_UT

    std::ostream& operator<<(std::ostream& os, const Header& obj) {
      Fw::String s;
      obj.toString(s);
      os << s.toChar();
      return os;
    }

#endif

    // ----------------------------------------------------------------------
    // Member functions
    // ----------------------------------------------------------------------

    Fw::SerializeStatus Header ::
      serializeTo(
          Fw::SerialBufferBase& buffer,
          Fw::Endianness mode
      ) const
    {
      Fw::SerializeStatus status;

      status = buffer.serializeFrom(this->m_majorVersion, mode);
      if (status != Fw::FW_SERIALIZE_OK) {
        return status;
      }
      status = buffer.serializeFrom(this->m_minorVersion, mode);
      if (status != Fw::FW_SERIALIZE_OK) {
        return status;
      }
      status = buffer.serializeFrom(this->m_patchVersion, mode);
      if (status != Fw::FW_SERIALIZE_OK) {
        return status;
      }
      status = buffer.serializeFrom(this->m_schemaVersion, mode);
      if (status != Fw::FW_SERIALIZE_OK) {
        return status;
      }
      status = buffer.serializeFrom(this->m_argumentCount, mode);
      if (status != Fw::FW_SERIALIZE_OK) {
        return status;
      }
      status = buffer.serializeFrom(this->m_statementCount, mode);
      if (status != Fw::FW_SERIALIZE_OK) {
        return status;
      }
      status = buffer.serializeFrom(this->m_bodySize, mode);
      if (status != Fw::FW_SERIALIZE_OK) {
        return status;
      }

      return status;
    }

    Fw::SerializeStatus Header ::
      deserializeFrom(
          Fw::SerialBufferBase& buffer,
          Fw::Endianness mode
      )
    {
      Fw::SerializeStatus status;

      status = buffer.deserializeTo(this->m_majorVersion, mode);
      if (status != Fw::FW_SERIALIZE_OK) {
        return status;
      }
      status = buffer.deserializeTo(this->m_minorVersion, mode);
      if (status != Fw::FW_SERIALIZE_OK) {
        return status;
      }
      status = buffer.deserializeTo(this->m_patchVersion, mode);
      if (status != Fw::FW_SERIALIZE_OK) {
        return status;
      }
      status = buffer.deserializeTo(this->m_schemaVersion, mode);
      if (status != Fw::FW_SERIALIZE_OK) {
        return status;
      }
      status = buffer.deserializeTo(this->m_argumentCount, mode);
      if (status != Fw::FW_SERIALIZE_OK) {
        return status;
      }
      status = buffer.deserializeTo(this->m_statementCount, mode);
      if (status != Fw::FW_SERIALIZE_OK) {
        return status;
      }
      status = buffer.deserializeTo(this->m_bodySize, mode);
      if (status != Fw::FW_SERIALIZE_OK) {
        return status;
      }

      return status;
    }

    FwSizeType Header ::
      serializedSize() const
    {
      FwSizeType size = 0;
      size += sizeof(U8);
      size += sizeof(U8);
      size += sizeof(U8);
      size += sizeof(U8);
      size += sizeof(U8);
      size += sizeof(U16);
      size += sizeof(U32);
      return size;
    }

#if FW_SERIALIZABLE_TO_STRING

    void Header ::
      toString(Fw::StringBase& sb) const
    {
      Fw::String tmp;
      sb = "( ";

      // Format majorVersion
      sb += "majorVersion = ";
      tmp.format("%" PRIu8 "", this->m_majorVersion);
      sb += tmp;
      sb += ", ";

      // Format minorVersion
      sb += "minorVersion = ";
      tmp.format("%" PRIu8 "", this->m_minorVersion);
      sb += tmp;
      sb += ", ";

      // Format patchVersion
      sb += "patchVersion = ";
      tmp.format("%" PRIu8 "", this->m_patchVersion);
      sb += tmp;
      sb += ", ";

      // Format schemaVersion
      sb += "schemaVersion = ";
      tmp.format("%" PRIu8 "", this->m_schemaVersion);
      sb += tmp;
      sb += ", ";

      // Format argumentCount
      sb += "argumentCount = ";
      tmp.format("%" PRIu8 "", this->m_argumentCount);
      sb += tmp;
      sb += ", ";

      // Format statementCount
      sb += "statementCount = ";
      tmp.format("%" PRIu16 "", this->m_statementCount);
      sb += tmp;
      sb += ", ";

      // Format bodySize
      sb += "bodySize = ";
      tmp.format("%" PRIu32 "", this->m_bodySize);
      sb += tmp;
      sb += " )";
    }

#endif

    // ----------------------------------------------------------------------
    // Setter functions
    // ----------------------------------------------------------------------

    void Header ::
      set(
          U8 majorVersion,
          U8 minorVersion,
          U8 patchVersion,
          U8 schemaVersion,
          U8 argumentCount,
          U16 statementCount,
          U32 bodySize
      )
    {
      this->m_majorVersion = majorVersion;
      this->m_minorVersion = minorVersion;
      this->m_patchVersion = patchVersion;
      this->m_schemaVersion = schemaVersion;
      this->m_argumentCount = argumentCount;
      this->m_statementCount = statementCount;
      this->m_bodySize = bodySize;
    }

    void Header ::
      set_majorVersion(U8 majorVersion)
    {
      this->m_majorVersion = majorVersion;
    }

    void Header ::
      set_minorVersion(U8 minorVersion)
    {
      this->m_minorVersion = minorVersion;
    }

    void Header ::
      set_patchVersion(U8 patchVersion)
    {
      this->m_patchVersion = patchVersion;
    }

    void Header ::
      set_schemaVersion(U8 schemaVersion)
    {
      this->m_schemaVersion = schemaVersion;
    }

    void Header ::
      set_argumentCount(U8 argumentCount)
    {
      this->m_argumentCount = argumentCount;
    }

    void Header ::
      set_statementCount(U16 statementCount)
    {
      this->m_statementCount = statementCount;
    }

    void Header ::
      set_bodySize(U32 bodySize)
    {
      this->m_bodySize = bodySize;
    }

  }

}
