// ======================================================================
// \title  FpySequencerComponentAc.hpp
// \author Generated by fpp-to-cpp
// \brief  hpp file for FpySequencer component base class
// ======================================================================

#ifndef Svc_FpySequencerComponentAc_HPP
#define Svc_FpySequencerComponentAc_HPP

#include <atomic>

#include "Fw/Cmd/CmdPortAc.hpp"
#include "Fw/Cmd/CmdRegPortAc.hpp"
#include "Fw/Cmd/CmdResponseEnumAc.hpp"
#include "Fw/Cmd/CmdResponsePortAc.hpp"
#include "Fw/Cmd/CmdString.hpp"
#include "Fw/Com/ComPortAc.hpp"
#include "Fw/Comp/ActiveComponentBase.hpp"
#include "Fw/FPrimeBasicTypes.hpp"
#include "Fw/Log/LogPortAc.hpp"
#include "Fw/Log/LogString.hpp"
#if FW_ENABLE_TEXT_LOGGING == 1
#include "Fw/Log/LogTextPortAc.hpp"
#endif
#include "Fw/Port/InputSerializePort.hpp"
#include "Fw/Port/OutputSerializePort.hpp"
#include "Fw/Prm/PrmGetPortAc.hpp"
#include "Fw/Prm/PrmSetPortAc.hpp"
#include "Fw/Prm/PrmString.hpp"
#include "Fw/Time/TimePortAc.hpp"
#include "Fw/Tlm/TlmGetPortAc.hpp"
#include "Fw/Tlm/TlmPortAc.hpp"
#include "Fw/Tlm/TlmString.hpp"
#include "Fw/Types/InternalInterfaceString.hpp"
#include "Os/Mutex.hpp"
#include "Svc/FpySequencer/DirectiveErrorCodeEnumAc.hpp"
#include "Svc/FpySequencer/DirectiveIdEnumAc.hpp"
#include "Svc/FpySequencer/FlagIdEnumAc.hpp"
#include "Svc/FpySequencer/FpySequencer_AllocateDirectiveSerializableAc.hpp"
#include "Svc/FpySequencer/FpySequencer_BlockStateEnumAc.hpp"
#include "Svc/FpySequencer/FpySequencer_BreakpointArgsSerializableAc.hpp"
#include "Svc/FpySequencer/FpySequencer_ConstCmdDirectiveSerializableAc.hpp"
#include "Svc/FpySequencer/FpySequencer_DiscardDirectiveSerializableAc.hpp"
#include "Svc/FpySequencer/FpySequencer_ExitDirectiveSerializableAc.hpp"
#include "Svc/FpySequencer/FpySequencer_FileReadStageEnumAc.hpp"
#include "Svc/FpySequencer/FpySequencer_GetFieldDirectiveSerializableAc.hpp"
#include "Svc/FpySequencer/FpySequencer_GetFlagDirectiveSerializableAc.hpp"
#include "Svc/FpySequencer/FpySequencer_GotoDirectiveSerializableAc.hpp"
#include "Svc/FpySequencer/FpySequencer_IfDirectiveSerializableAc.hpp"
#include "Svc/FpySequencer/FpySequencer_LoadDirectiveSerializableAc.hpp"
#include "Svc/FpySequencer/FpySequencer_MemCmpDirectiveSerializableAc.hpp"
#include "Svc/FpySequencer/FpySequencer_NoOpDirectiveSerializableAc.hpp"
#include "Svc/FpySequencer/FpySequencer_PeekDirectiveSerializableAc.hpp"
#include "Svc/FpySequencer/FpySequencer_PushPrmDirectiveSerializableAc.hpp"
#include "Svc/FpySequencer/FpySequencer_PushTimeDirectiveSerializableAc.hpp"
#include "Svc/FpySequencer/FpySequencer_PushTlmValAndTimeDirectiveSerializableAc.hpp"
#include "Svc/FpySequencer/FpySequencer_PushTlmValDirectiveSerializableAc.hpp"
#include "Svc/FpySequencer/FpySequencer_PushValDirectiveSerializableAc.hpp"
#include "Svc/FpySequencer/FpySequencer_SequenceExecutionArgsSerializableAc.hpp"
#include "Svc/FpySequencer/FpySequencer_SequencerStateMachineStateMachineAc.hpp"
#include "Svc/FpySequencer/FpySequencer_SetFlagDirectiveSerializableAc.hpp"
#include "Svc/FpySequencer/FpySequencer_StackCmdDirectiveSerializableAc.hpp"
#include "Svc/FpySequencer/FpySequencer_StackOpDirectiveSerializableAc.hpp"
#include "Svc/FpySequencer/FpySequencer_StoreConstOffsetDirectiveSerializableAc.hpp"
#include "Svc/FpySequencer/FpySequencer_StoreDirectiveSerializableAc.hpp"
#include "Svc/FpySequencer/FpySequencer_WaitAbsDirectiveSerializableAc.hpp"
#include "Svc/FpySequencer/FpySequencer_WaitRelDirectiveSerializableAc.hpp"
#include "Svc/FpySequencer/StackSizeTypeAliasAc.hpp"
#include "Svc/Ping/PingPortAc.hpp"
#include "Svc/Sched/SchedPortAc.hpp"
#include "Svc/Seq/CmdSeqInPortAc.hpp"
#include "default/config/FwChanIdTypeAliasAc.hpp"
#include "default/config/FwEnumStoreTypeAliasAc.hpp"
#include "default/config/FwOpcodeTypeAliasAc.hpp"
#include "default/config/FwPrmIdTypeAliasAc.hpp"
#include "default/config/FwSizeTypeAliasAc.hpp"

namespace Svc {

  //! \class FpySequencerComponentBase
  //! \brief Auto-generated base for FpySequencer component
  //!
  //! Dispatches command sequences to available command sequencers
  class FpySequencerComponentBase :
    public Fw::ActiveComponentBase
  {

      // ----------------------------------------------------------------------
      // Friend classes
      // ----------------------------------------------------------------------

      //! Friend class tester to support autocoded test harness
      friend class FpySequencerTesterBase;
      //! Friend class tester implementation to support white-box testing
      friend class FpySequencerTester;

    protected:

      // ----------------------------------------------------------------------
      // Constants
      // ----------------------------------------------------------------------

      //! Enumerations for numbers of special input ports
      enum {
        NUM_CMDIN_INPUT_PORTS = 1,
      };

      //! Enumerations for numbers of typed input ports
      enum {
        NUM_CHECKTIMERS_INPUT_PORTS = 1,
        NUM_CMDRESPONSEIN_INPUT_PORTS = 1,
        NUM_PINGIN_INPUT_PORTS = 1,
        NUM_SEQRUNIN_INPUT_PORTS = 1,
        NUM_TLMWRITE_INPUT_PORTS = 1,
      };

      //! Enumerations for numbers of special output ports
      enum {
        NUM_CMDREGOUT_OUTPUT_PORTS = 1,
        NUM_CMDRESPONSEOUT_OUTPUT_PORTS = 1,
        NUM_LOGOUT_OUTPUT_PORTS = 1,
        NUM_LOGTEXTOUT_OUTPUT_PORTS = 1,
        NUM_PRMGET_OUTPUT_PORTS = 1,
        NUM_PRMSET_OUTPUT_PORTS = 1,
        NUM_TIMECALLER_OUTPUT_PORTS = 1,
        NUM_TLMOUT_OUTPUT_PORTS = 1,
      };

      //! Enumerations for numbers of typed output ports
      enum {
        NUM_CMDOUT_OUTPUT_PORTS = 1,
        NUM_GETPARAM_OUTPUT_PORTS = 1,
        NUM_GETTLMCHAN_OUTPUT_PORTS = 1,
        NUM_PINGOUT_OUTPUT_PORTS = 1,
        NUM_SEQDONEOUT_OUTPUT_PORTS = 1,
        NUM_SEQSTARTOUT_OUTPUT_PORTS = 1,
      };

      //! Command opcodes
      enum {
        OPCODE_RUN = 0x0, //!< Loads, validates and runs a sequence
        OPCODE_VALIDATE = 0x1, //!< Loads and validates a sequence
        OPCODE_RUN_VALIDATED = 0x2, //!< Must be called after VALIDATE. Runs the sequence that was validated.
        OPCODE_CANCEL = 0x3, //!< Cancels a running or validated sequence. After running CANCEL, the sequencer
                             //!< should return to IDLE
        OPCODE_SET_BREAKPOINT = 0x4, //!< Sets the breakpoint which will pause the execution of the sequencer when
                                     //!< reached, until unpaused by the CONTINUE command. Will pause just before
                                     //!< dispatching the specified directive. This command is valid in all states. Breakpoint
                                     //!< settings are cleared after a sequence ends execution.
        OPCODE_BREAK = 0x5, //!< Pauses the execution of the sequencer, just before it is about to dispatch the next directive,
                            //!< until unpaused by the CONTINUE command, or stepped by the STEP command. This command is only valid
                            //!< substates of the RUNNING state that are not RUNNING.PAUSED.
        OPCODE_CONTINUE = 0x6, //!< Continues the automatic execution of the sequence after it has been paused. If a breakpoint is still
                               //!< set, it may pause again on that breakpoint. This command is only valid in the RUNNING.PAUSED state.
        OPCODE_CLEAR_BREAKPOINT = 0x7, //!< Clears the breakpoint, but does not continue executing the sequence. This command
                                       //!< is valid in all states. This happens automatically when a sequence ends execution.
        OPCODE_STEP = 0x8, //!< Dispatches and awaits the result of the next directive, or ends the sequence if no more directives remain. Returns
                           //!< to the RUNNING.PAUSED state if the directive executes successfully. This command is only valid in the RUNNING.PAUSED state.
        OPCODE_SET_FLAG = 0x9, //!< Sets the value of a flag. See Fpy.FlagId docstrings for info on each flag.
                               //!< This command is only valid in the RUNNING state.
        OPCODE_DUMP_STACK_TO_FILE = 0xa, //!< Writes the contents of the stack to a file. This command is only valid in the RUNNING.PAUSED state.
        OPCODE_STATEMENT_TIMEOUT_SECS_SET = 0xb, //!< Opcode to set parameter STATEMENT_TIMEOUT_SECS
        OPCODE_STATEMENT_TIMEOUT_SECS_SAVE = 0xc, //!< Opcode to save parameter STATEMENT_TIMEOUT_SECS
        OPCODE_FLAG_DEFAULT_EXIT_ON_CMD_FAIL_SET = 0xd, //!< Opcode to set parameter FLAG_DEFAULT_EXIT_ON_CMD_FAIL
        OPCODE_FLAG_DEFAULT_EXIT_ON_CMD_FAIL_SAVE = 0xe, //!< Opcode to save parameter FLAG_DEFAULT_EXIT_ON_CMD_FAIL
      };

      //! Event IDs
      enum {
        EVENTID_INVALIDCOMMAND = 0x0,
        EVENTID_INVALIDSEQRUNCALL = 0x1,
        EVENTID_FILEOPENERROR = 0x2,
        EVENTID_FILEWRITEERROR = 0x3,
        EVENTID_FILEREADERROR = 0x4,
        EVENTID_ENDOFFILEERROR = 0x5,
        EVENTID_FILEREADDESERIALIZEERROR = 0x6,
        EVENTID_WRONGSCHEMAVERSION = 0x7,
        EVENTID_WRONGCRC = 0x8,
        EVENTID_EXTRABYTESINSEQUENCE = 0x9,
        EVENTID_INSUFFICIENTBUFFERSPACE = 0xa,
        EVENTID_COMMANDFAILED = 0xb,
        EVENTID_SEQUENCEDONE = 0xc,
        EVENTID_SEQUENCECANCELLED = 0xd,
        EVENTID_SEQUENCEEXITEDWITHERROR = 0xe,
        EVENTID_UNKNOWNSEQUENCERDIRECTIVE = 0xf,
        EVENTID_CMDRESPONSEWHILENOTRUNNINGSEQUENCE = 0x10,
        EVENTID_CMDRESPONSEFROMOLDSEQUENCE = 0x11,
        EVENTID_CMDRESPONSEWHILENOTAWAITING = 0x12,
        EVENTID_CMDRESPONSEWHILEAWAITINGDIRECTIVE = 0x13,
        EVENTID_WRONGCMDRESPONSEOPCODE = 0x14,
        EVENTID_WRONGCMDRESPONSEINDEX = 0x15,
        EVENTID_DIRECTIVEDESERIALIZEERROR = 0x16,
        EVENTID_MISMATCHEDTIMEBASE = 0x17,
        EVENTID_MISMATCHEDTIMECONTEXT = 0x18,
        EVENTID_COMMANDTIMEDOUT = 0x19,
        EVENTID_DIRECTIVETIMEDOUT = 0x1a,
        EVENTID_TOOMANYSEQUENCEARGS = 0x1b,
        EVENTID_TOOMANYSEQUENCEDIRECTIVES = 0x1c,
        EVENTID_SEQUENCEPAUSED = 0x1d,
        EVENTID_BREAKPOINTSET = 0x1e,
        EVENTID_BREAKPOINTCLEARED = 0x1f,
      };

      //! Channel IDs
      enum {
        CHANNELID_STATE = 0x0, //!< Channel ID for State
        CHANNELID_SEQUENCESSUCCEEDED = 0x1, //!< Channel ID for SequencesSucceeded
        CHANNELID_SEQUENCESFAILED = 0x2, //!< Channel ID for SequencesFailed
        CHANNELID_SEQUENCESCANCELLED = 0x3, //!< Channel ID for SequencesCancelled
        CHANNELID_STATEMENTSDISPATCHED = 0x4, //!< Channel ID for StatementsDispatched
        CHANNELID_STATEMENTSFAILED = 0x5, //!< Channel ID for StatementsFailed
        CHANNELID_LASTDIRECTIVEERROR = 0x6, //!< Channel ID for LastDirectiveError
        CHANNELID_DIRECTIVEERRORINDEX = 0x7, //!< Channel ID for DirectiveErrorIndex
        CHANNELID_DIRECTIVEERRORID = 0x8, //!< Channel ID for DirectiveErrorId
        CHANNELID_SEQPATH = 0x9, //!< Channel ID for SeqPath
        CHANNELID_DEBUG_REACHEDENDOFFILE = 0xa, //!< Channel ID for Debug_ReachedEndOfFile
        CHANNELID_DEBUG_NEXTSTATEMENTREADSUCCESS = 0xb, //!< Channel ID for Debug_NextStatementReadSuccess
        CHANNELID_DEBUG_NEXTSTATEMENTOPCODE = 0xc, //!< Channel ID for Debug_NextStatementOpcode
        CHANNELID_DEBUG_NEXTCMDOPCODE = 0xd, //!< Channel ID for Debug_NextCmdOpcode
        CHANNELID_DEBUG_STACKSIZE = 0xe, //!< Channel ID for Debug_StackSize
        CHANNELID_BREAKPOINTINUSE = 0xf, //!< Channel ID for BreakpointInUse
        CHANNELID_BREAKPOINTINDEX = 0x10, //!< Channel ID for BreakpointIndex
        CHANNELID_BREAKONLYONCEONBREAKPOINT = 0x11, //!< Channel ID for BreakOnlyOnceOnBreakpoint
        CHANNELID_BREAKBEFORENEXTLINE = 0x12, //!< Channel ID for BreakBeforeNextLine
        CHANNELID_PRM_STATEMENT_TIMEOUT_SECS = 0x13, //!< Channel ID for PRM_STATEMENT_TIMEOUT_SECS
        CHANNELID_PRM_FLAG_DEFAULT_EXIT_ON_CMD_FAIL = 0x14, //!< Channel ID for PRM_FLAG_DEFAULT_EXIT_ON_CMD_FAIL
      };

      //! Parameter IDs
      enum {
        PARAMID_STATEMENT_TIMEOUT_SECS = 0x0, //!< the number of seconds to wait before giving up
                                              //!< on a directive or command. if <= 0 or greater than U32 max, never time out.
                                              //!< accuracy of this timeout is determined by the rate group driving this
                                              //!< component. it will be rounded up
        PARAMID_FLAG_DEFAULT_EXIT_ON_CMD_FAIL = 0x1, //!< the default value of the EXIT_ON_CMD_FAIL sequence flag
      };

      //! State machine identifiers
      enum class SmId : FwEnumStoreType {
        sequencer,
      };

    protected:

      // ----------------------------------------------------------------------
      // Types for internal state machines
      // ----------------------------------------------------------------------

      //! Implementation of state machine Svc_FpySequencer_SequencerStateMachine
      class Svc_FpySequencer_SequencerStateMachine :
        public Svc::FpySequencer_SequencerStateMachineStateMachineBase
      {

          // ----------------------------------------------------------------------
          // Friend classes
          // ----------------------------------------------------------------------

          //! Autocoded test harness for the enclosing component
          friend class FpySequencerTesterBase;
          //! Test implementation for the enclosing component
          friend class FpySequencerTester;

        public:

          //! Constructor
          Svc_FpySequencer_SequencerStateMachine(
              FpySequencerComponentBase& component //!< The enclosing component
          );

        public:

          //! Initialize the state machine
          void init(
              FpySequencerComponentBase::SmId smId //!< The state machine id
          );

        public:

          //! Get the state machine id
          FpySequencerComponentBase::SmId getId() const;

        private:

          //! Implementation for action signalEntered
          void action_signalEntered(
              Signal signal //!< The signal
          );

          //! Implementation for action setSequenceFilePath
          void action_setSequenceFilePath(
              Signal signal, //!< The signal
              const Svc::FpySequencer_SequenceExecutionArgs& value //!< The value
          );

          //! Implementation for action setSequenceBlockState
          void action_setSequenceBlockState(
              Signal signal, //!< The signal
              const Svc::FpySequencer_SequenceExecutionArgs& value //!< The value
          );

          //! Implementation for action validate
          void action_validate(
              Signal signal //!< The signal
          );

          //! Implementation for action report_seqSucceeded
          void action_report_seqSucceeded(
              Signal signal //!< The signal
          );

          //! Implementation for action report_seqCancelled
          void action_report_seqCancelled(
              Signal signal //!< The signal
          );

          //! Implementation for action report_seqFailed
          void action_report_seqFailed(
              Signal signal //!< The signal
          );

          //! Implementation for action report_seqStarted
          void action_report_seqStarted(
              Signal signal //!< The signal
          );

          //! Implementation for action setGoalState_RUNNING
          void action_setGoalState_RUNNING(
              Signal signal //!< The signal
          );

          //! Implementation for action setGoalState_VALID
          void action_setGoalState_VALID(
              Signal signal //!< The signal
          );

          //! Implementation for action setGoalState_IDLE
          void action_setGoalState_IDLE(
              Signal signal //!< The signal
          );

          //! Implementation for action sendCmdResponse_OK
          void action_sendCmdResponse_OK(
              Signal signal //!< The signal
          );

          //! Implementation for action sendCmdResponse_EXECUTION_ERROR
          void action_sendCmdResponse_EXECUTION_ERROR(
              Signal signal //!< The signal
          );

          //! Implementation for action clearSequenceFile
          void action_clearSequenceFile(
              Signal signal //!< The signal
          );

          //! Implementation for action clearBreakpoint
          void action_clearBreakpoint(
              Signal signal //!< The signal
          );

          //! Implementation for action checkShouldWake
          void action_checkShouldWake(
              Signal signal //!< The signal
          );

          //! Implementation for action dispatchStatement
          void action_dispatchStatement(
              Signal signal //!< The signal
          );

          //! Implementation for action resetRuntime
          void action_resetRuntime(
              Signal signal //!< The signal
          );

          //! Implementation for action checkStatementTimeout
          void action_checkStatementTimeout(
              Signal signal //!< The signal
          );

          //! Implementation for action incrementSequenceCounter
          void action_incrementSequenceCounter(
              Signal signal //!< The signal
          );

          //! Implementation for action report_seqBroken
          void action_report_seqBroken(
              Signal signal //!< The signal
          );

          //! Implementation for action setBreakpoint
          void action_setBreakpoint(
              Signal signal, //!< The signal
              const Svc::FpySequencer_BreakpointArgs& value //!< The value
          );

          //! Implementation for action setBreakBeforeNextLine
          void action_setBreakBeforeNextLine(
              Signal signal //!< The signal
          );

          //! Implementation for action clearBreakBeforeNextLine
          void action_clearBreakBeforeNextLine(
              Signal signal //!< The signal
          );

        private:

          //! Implementation for guard goalStateIs_RUNNING
          bool guard_goalStateIs_RUNNING(
              Signal signal //!< The signal
          ) const;

          //! Implementation for guard shouldBreak
          bool guard_shouldBreak(
              Signal signal //!< The signal
          ) const;

          //! Implementation for guard breakOnce
          bool guard_breakOnce(
              Signal signal //!< The signal
          ) const;

        private:

          //! The enclosing component
          FpySequencerComponentBase& m_component;

      };

    public:

      // ----------------------------------------------------------------------
      // Component initialization
      // ----------------------------------------------------------------------

      //! Initialize FpySequencerComponentBase object
      void init(
          FwSizeType queueDepth, //!< The queue depth
          FwEnumStoreType instance = 0 //!< The instance number
      );

    public:

      // ----------------------------------------------------------------------
      // Getters for special input ports
      // ----------------------------------------------------------------------

      //! Get special input port at index
      //!
      //! \return cmdIn[portNum]
      Fw::InputCmdPort* get_cmdIn_InputPort(
          FwIndexType portNum //!< The port number
      );

    public:

      // ----------------------------------------------------------------------
      // Getters for typed input ports
      // ----------------------------------------------------------------------

      //! Get typed input port at index
      //!
      //! \return checkTimers[portNum]
      Svc::InputSchedPort* get_checkTimers_InputPort(
          FwIndexType portNum //!< The port number
      );

      //! Get typed input port at index
      //!
      //! \return cmdResponseIn[portNum]
      Fw::InputCmdResponsePort* get_cmdResponseIn_InputPort(
          FwIndexType portNum //!< The port number
      );

      //! Get typed input port at index
      //!
      //! \return pingIn[portNum]
      Svc::InputPingPort* get_pingIn_InputPort(
          FwIndexType portNum //!< The port number
      );

      //! Get typed input port at index
      //!
      //! \return seqRunIn[portNum]
      Svc::InputCmdSeqInPort* get_seqRunIn_InputPort(
          FwIndexType portNum //!< The port number
      );

      //! Get typed input port at index
      //!
      //! \return tlmWrite[portNum]
      Svc::InputSchedPort* get_tlmWrite_InputPort(
          FwIndexType portNum //!< The port number
      );

    public:

      // ----------------------------------------------------------------------
      // Connect input ports to special output ports
      // ----------------------------------------------------------------------

      //! Connect port to cmdRegOut[portNum]
      void set_cmdRegOut_OutputPort(
          FwIndexType portNum, //!< The port number
          Fw::InputCmdRegPort* port //!< The input port
      );

      //! Connect port to cmdResponseOut[portNum]
      void set_cmdResponseOut_OutputPort(
          FwIndexType portNum, //!< The port number
          Fw::InputCmdResponsePort* port //!< The input port
      );

      //! Connect port to logOut[portNum]
      void set_logOut_OutputPort(
          FwIndexType portNum, //!< The port number
          Fw::InputLogPort* port //!< The input port
      );

#if FW_ENABLE_TEXT_LOGGING == 1

      //! Connect port to logTextOut[portNum]
      void set_logTextOut_OutputPort(
          FwIndexType portNum, //!< The port number
          Fw::InputLogTextPort* port //!< The input port
      );

#endif

      //! Connect port to prmGet[portNum]
      void set_prmGet_OutputPort(
          FwIndexType portNum, //!< The port number
          Fw::InputPrmGetPort* port //!< The input port
      );

      //! Connect port to prmSet[portNum]
      void set_prmSet_OutputPort(
          FwIndexType portNum, //!< The port number
          Fw::InputPrmSetPort* port //!< The input port
      );

      //! Connect port to timeCaller[portNum]
      void set_timeCaller_OutputPort(
          FwIndexType portNum, //!< The port number
          Fw::InputTimePort* port //!< The input port
      );

      //! Connect port to tlmOut[portNum]
      void set_tlmOut_OutputPort(
          FwIndexType portNum, //!< The port number
          Fw::InputTlmPort* port //!< The input port
      );

    public:

      // ----------------------------------------------------------------------
      // Connect typed input ports to typed output ports
      // ----------------------------------------------------------------------

      //! Connect port to cmdOut[portNum]
      void set_cmdOut_OutputPort(
          FwIndexType portNum, //!< The port number
          Fw::InputComPort* port //!< The input port
      );

      //! Connect port to getParam[portNum]
      void set_getParam_OutputPort(
          FwIndexType portNum, //!< The port number
          Fw::InputPrmGetPort* port //!< The input port
      );

      //! Connect port to getTlmChan[portNum]
      void set_getTlmChan_OutputPort(
          FwIndexType portNum, //!< The port number
          Fw::InputTlmGetPort* port //!< The input port
      );

      //! Connect port to pingOut[portNum]
      void set_pingOut_OutputPort(
          FwIndexType portNum, //!< The port number
          Svc::InputPingPort* port //!< The input port
      );

      //! Connect port to seqDoneOut[portNum]
      void set_seqDoneOut_OutputPort(
          FwIndexType portNum, //!< The port number
          Fw::InputCmdResponsePort* port //!< The input port
      );

      //! Connect port to seqStartOut[portNum]
      void set_seqStartOut_OutputPort(
          FwIndexType portNum, //!< The port number
          Svc::InputCmdSeqInPort* port //!< The input port
      );

#if FW_PORT_SERIALIZATION

    public:

      // ----------------------------------------------------------------------
      // Connect serial input ports to special output ports
      // ----------------------------------------------------------------------

      //! Connect port to cmdRegOut[portNum]
      void set_cmdRegOut_OutputPort(
          FwIndexType portNum, //!< The port number
          Fw::InputSerializePort* port //!< The port
      );

      //! Connect port to cmdResponseOut[portNum]
      void set_cmdResponseOut_OutputPort(
          FwIndexType portNum, //!< The port number
          Fw::InputSerializePort* port //!< The port
      );

      //! Connect port to logOut[portNum]
      void set_logOut_OutputPort(
          FwIndexType portNum, //!< The port number
          Fw::InputSerializePort* port //!< The port
      );

#if FW_ENABLE_TEXT_LOGGING == 1

      //! Connect port to logTextOut[portNum]
      void set_logTextOut_OutputPort(
          FwIndexType portNum, //!< The port number
          Fw::InputSerializePort* port //!< The port
      );

#endif

      //! Connect port to prmSet[portNum]
      void set_prmSet_OutputPort(
          FwIndexType portNum, //!< The port number
          Fw::InputSerializePort* port //!< The port
      );

      //! Connect port to timeCaller[portNum]
      void set_timeCaller_OutputPort(
          FwIndexType portNum, //!< The port number
          Fw::InputSerializePort* port //!< The port
      );

      //! Connect port to tlmOut[portNum]
      void set_tlmOut_OutputPort(
          FwIndexType portNum, //!< The port number
          Fw::InputSerializePort* port //!< The port
      );

#endif

#if FW_PORT_SERIALIZATION

    public:

      // ----------------------------------------------------------------------
      // Connect serial input ports to typed output ports
      // ----------------------------------------------------------------------

      //! Connect port to cmdOut[portNum]
      void set_cmdOut_OutputPort(
          FwIndexType portNum, //!< The port number
          Fw::InputSerializePort* port //!< The port
      );

      //! Connect port to pingOut[portNum]
      void set_pingOut_OutputPort(
          FwIndexType portNum, //!< The port number
          Fw::InputSerializePort* port //!< The port
      );

      //! Connect port to seqDoneOut[portNum]
      void set_seqDoneOut_OutputPort(
          FwIndexType portNum, //!< The port number
          Fw::InputSerializePort* port //!< The port
      );

      //! Connect port to seqStartOut[portNum]
      void set_seqStartOut_OutputPort(
          FwIndexType portNum, //!< The port number
          Fw::InputSerializePort* port //!< The port
      );

#endif

    public:

      // ----------------------------------------------------------------------
      // Command registration
      // ----------------------------------------------------------------------

      //! \brief Register commands with the Command Dispatcher
      //!
      //! Connect the dispatcher first
      void regCommands();

    public:

      // ----------------------------------------------------------------------
      // Parameter loading
      // ----------------------------------------------------------------------

      //! \brief Load the parameters from a parameter source
      //!
      //! Connect the parameter first
      void loadParameters();

    protected:

      // ----------------------------------------------------------------------
      // Component construction and destruction
      // ----------------------------------------------------------------------

      //! Construct FpySequencerComponentBase object
      FpySequencerComponentBase(
          const char* compName = "" //!< The component name
      );

      //! Destroy FpySequencerComponentBase object
      virtual ~FpySequencerComponentBase();

    protected:

      // ----------------------------------------------------------------------
      // Getters for numbers of special input ports
      // ----------------------------------------------------------------------

      //! Get the number of cmdIn input ports
      //!
      //! \return The number of cmdIn input ports
      static constexpr FwIndexType getNum_cmdIn_InputPorts() {
        return NUM_CMDIN_INPUT_PORTS;
      }

    protected:

      // ----------------------------------------------------------------------
      // Getters for numbers of typed input ports
      // ----------------------------------------------------------------------

      //! Get the number of checkTimers input ports
      //!
      //! \return The number of checkTimers input ports
      static constexpr FwIndexType getNum_checkTimers_InputPorts() {
        return NUM_CHECKTIMERS_INPUT_PORTS;
      }

      //! Get the number of cmdResponseIn input ports
      //!
      //! \return The number of cmdResponseIn input ports
      static constexpr FwIndexType getNum_cmdResponseIn_InputPorts() {
        return NUM_CMDRESPONSEIN_INPUT_PORTS;
      }

      //! Get the number of pingIn input ports
      //!
      //! \return The number of pingIn input ports
      static constexpr FwIndexType getNum_pingIn_InputPorts() {
        return NUM_PINGIN_INPUT_PORTS;
      }

      //! Get the number of seqRunIn input ports
      //!
      //! \return The number of seqRunIn input ports
      static constexpr FwIndexType getNum_seqRunIn_InputPorts() {
        return NUM_SEQRUNIN_INPUT_PORTS;
      }

      //! Get the number of tlmWrite input ports
      //!
      //! \return The number of tlmWrite input ports
      static constexpr FwIndexType getNum_tlmWrite_InputPorts() {
        return NUM_TLMWRITE_INPUT_PORTS;
      }

    protected:

      // ----------------------------------------------------------------------
      // Getters for numbers of special output ports
      // ----------------------------------------------------------------------

      //! Get the number of cmdRegOut output ports
      //!
      //! \return The number of cmdRegOut output ports
      static constexpr FwIndexType getNum_cmdRegOut_OutputPorts() {
        return NUM_CMDREGOUT_OUTPUT_PORTS;
      }

      //! Get the number of cmdResponseOut output ports
      //!
      //! \return The number of cmdResponseOut output ports
      static constexpr FwIndexType getNum_cmdResponseOut_OutputPorts() {
        return NUM_CMDRESPONSEOUT_OUTPUT_PORTS;
      }

      //! Get the number of logOut output ports
      //!
      //! \return The number of logOut output ports
      static constexpr FwIndexType getNum_logOut_OutputPorts() {
        return NUM_LOGOUT_OUTPUT_PORTS;
      }

#if FW_ENABLE_TEXT_LOGGING == 1

      //! Get the number of logTextOut output ports
      //!
      //! \return The number of logTextOut output ports
      static constexpr FwIndexType getNum_logTextOut_OutputPorts() {
        return NUM_LOGTEXTOUT_OUTPUT_PORTS;
      }

#endif

      //! Get the number of prmGet output ports
      //!
      //! \return The number of prmGet output ports
      static constexpr FwIndexType getNum_prmGet_OutputPorts() {
        return NUM_PRMGET_OUTPUT_PORTS;
      }

      //! Get the number of prmSet output ports
      //!
      //! \return The number of prmSet output ports
      static constexpr FwIndexType getNum_prmSet_OutputPorts() {
        return NUM_PRMSET_OUTPUT_PORTS;
      }

      //! Get the number of timeCaller output ports
      //!
      //! \return The number of timeCaller output ports
      static constexpr FwIndexType getNum_timeCaller_OutputPorts() {
        return NUM_TIMECALLER_OUTPUT_PORTS;
      }

      //! Get the number of tlmOut output ports
      //!
      //! \return The number of tlmOut output ports
      static constexpr FwIndexType getNum_tlmOut_OutputPorts() {
        return NUM_TLMOUT_OUTPUT_PORTS;
      }

    protected:

      // ----------------------------------------------------------------------
      // Getters for numbers of typed output ports
      // ----------------------------------------------------------------------

      //! Get the number of cmdOut output ports
      //!
      //! \return The number of cmdOut output ports
      static constexpr FwIndexType getNum_cmdOut_OutputPorts() {
        return NUM_CMDOUT_OUTPUT_PORTS;
      }

      //! Get the number of getParam output ports
      //!
      //! \return The number of getParam output ports
      static constexpr FwIndexType getNum_getParam_OutputPorts() {
        return NUM_GETPARAM_OUTPUT_PORTS;
      }

      //! Get the number of getTlmChan output ports
      //!
      //! \return The number of getTlmChan output ports
      static constexpr FwIndexType getNum_getTlmChan_OutputPorts() {
        return NUM_GETTLMCHAN_OUTPUT_PORTS;
      }

      //! Get the number of pingOut output ports
      //!
      //! \return The number of pingOut output ports
      static constexpr FwIndexType getNum_pingOut_OutputPorts() {
        return NUM_PINGOUT_OUTPUT_PORTS;
      }

      //! Get the number of seqDoneOut output ports
      //!
      //! \return The number of seqDoneOut output ports
      static constexpr FwIndexType getNum_seqDoneOut_OutputPorts() {
        return NUM_SEQDONEOUT_OUTPUT_PORTS;
      }

      //! Get the number of seqStartOut output ports
      //!
      //! \return The number of seqStartOut output ports
      static constexpr FwIndexType getNum_seqStartOut_OutputPorts() {
        return NUM_SEQSTARTOUT_OUTPUT_PORTS;
      }

    protected:

      // ----------------------------------------------------------------------
      // Connection status queries for special output ports
      // ----------------------------------------------------------------------

      //! Check whether port cmdRegOut is connected
      //!
      //! \return Whether port cmdRegOut is connected
      bool isConnected_cmdRegOut_OutputPort(
          FwIndexType portNum //!< The port number
      );

      //! Check whether port cmdResponseOut is connected
      //!
      //! \return Whether port cmdResponseOut is connected
      bool isConnected_cmdResponseOut_OutputPort(
          FwIndexType portNum //!< The port number
      );

      //! Check whether port logOut is connected
      //!
      //! \return Whether port logOut is connected
      bool isConnected_logOut_OutputPort(
          FwIndexType portNum //!< The port number
      );

#if FW_ENABLE_TEXT_LOGGING == 1

      //! Check whether port logTextOut is connected
      //!
      //! \return Whether port logTextOut is connected
      bool isConnected_logTextOut_OutputPort(
          FwIndexType portNum //!< The port number
      );

#endif

      //! Check whether port prmGet is connected
      //!
      //! \return Whether port prmGet is connected
      bool isConnected_prmGet_OutputPort(
          FwIndexType portNum //!< The port number
      );

      //! Check whether port prmSet is connected
      //!
      //! \return Whether port prmSet is connected
      bool isConnected_prmSet_OutputPort(
          FwIndexType portNum //!< The port number
      );

      //! Check whether port timeCaller is connected
      //!
      //! \return Whether port timeCaller is connected
      bool isConnected_timeCaller_OutputPort(
          FwIndexType portNum //!< The port number
      );

      //! Check whether port tlmOut is connected
      //!
      //! \return Whether port tlmOut is connected
      bool isConnected_tlmOut_OutputPort(
          FwIndexType portNum //!< The port number
      );

    protected:

      // ----------------------------------------------------------------------
      // Connection status queries for typed output ports
      // ----------------------------------------------------------------------

      //! Check whether port cmdOut is connected
      //!
      //! \return Whether port cmdOut is connected
      bool isConnected_cmdOut_OutputPort(
          FwIndexType portNum //!< The port number
      );

      //! Check whether port getParam is connected
      //!
      //! \return Whether port getParam is connected
      bool isConnected_getParam_OutputPort(
          FwIndexType portNum //!< The port number
      );

      //! Check whether port getTlmChan is connected
      //!
      //! \return Whether port getTlmChan is connected
      bool isConnected_getTlmChan_OutputPort(
          FwIndexType portNum //!< The port number
      );

      //! Check whether port pingOut is connected
      //!
      //! \return Whether port pingOut is connected
      bool isConnected_pingOut_OutputPort(
          FwIndexType portNum //!< The port number
      );

      //! Check whether port seqDoneOut is connected
      //!
      //! \return Whether port seqDoneOut is connected
      bool isConnected_seqDoneOut_OutputPort(
          FwIndexType portNum //!< The port number
      );

      //! Check whether port seqStartOut is connected
      //!
      //! \return Whether port seqStartOut is connected
      bool isConnected_seqStartOut_OutputPort(
          FwIndexType portNum //!< The port number
      );

    protected:

      // ----------------------------------------------------------------------
      // Handlers to implement for typed input ports
      // ----------------------------------------------------------------------

      //! Handler for input port checkTimers
      virtual void checkTimers_handler(
          FwIndexType portNum, //!< The port number
          U32 context //!< The call order
      ) = 0;

      //! Handler for input port cmdResponseIn
      virtual void cmdResponseIn_handler(
          FwIndexType portNum, //!< The port number
          FwOpcodeType opCode, //!< Command Op Code
          U32 cmdSeq, //!< Command Sequence
          const Fw::CmdResponse& response //!< The command response argument
      ) = 0;

      //! Handler for input port pingIn
      virtual void pingIn_handler(
          FwIndexType portNum, //!< The port number
          U32 key //!< Value to return to pinger
      ) = 0;

      //! Handler for input port seqRunIn
      virtual void seqRunIn_handler(
          FwIndexType portNum, //!< The port number
          const Fw::StringBase& filename //!< The sequence file
      ) = 0;

      //! Handler for input port tlmWrite
      virtual void tlmWrite_handler(
          FwIndexType portNum, //!< The port number
          U32 context //!< The call order
      ) = 0;

    protected:

      // ----------------------------------------------------------------------
      // Port handler base-class functions for typed input ports
      //
      // Call these functions directly to bypass the corresponding ports
      // ----------------------------------------------------------------------

      //! Handler base-class function for input port checkTimers
      void checkTimers_handlerBase(
          FwIndexType portNum, //!< The port number
          U32 context //!< The call order
      );

      //! Handler base-class function for input port cmdResponseIn
      void cmdResponseIn_handlerBase(
          FwIndexType portNum, //!< The port number
          FwOpcodeType opCode, //!< Command Op Code
          U32 cmdSeq, //!< Command Sequence
          const Fw::CmdResponse& response //!< The command response argument
      );

      //! Handler base-class function for input port pingIn
      void pingIn_handlerBase(
          FwIndexType portNum, //!< The port number
          U32 key //!< Value to return to pinger
      );

      //! Handler base-class function for input port seqRunIn
      void seqRunIn_handlerBase(
          FwIndexType portNum, //!< The port number
          const Fw::StringBase& filename //!< The sequence file
      );

      //! Handler base-class function for input port tlmWrite
      void tlmWrite_handlerBase(
          FwIndexType portNum, //!< The port number
          U32 context //!< The call order
      );

    protected:

      // ----------------------------------------------------------------------
      // Pre-message hooks for typed async input ports
      //
      // Each of these functions is invoked just before processing a message
      // on the corresponding port. By default, they do nothing. You can
      // override them to provide specific pre-message behavior.
      // ----------------------------------------------------------------------

      //! Pre-message hook for async input port checkTimers
      virtual void checkTimers_preMsgHook(
          FwIndexType portNum, //!< The port number
          U32 context //!< The call order
      );

      //! Pre-message hook for async input port cmdResponseIn
      virtual void cmdResponseIn_preMsgHook(
          FwIndexType portNum, //!< The port number
          FwOpcodeType opCode, //!< Command Op Code
          U32 cmdSeq, //!< Command Sequence
          const Fw::CmdResponse& response //!< The command response argument
      );

      //! Pre-message hook for async input port pingIn
      virtual void pingIn_preMsgHook(
          FwIndexType portNum, //!< The port number
          U32 key //!< Value to return to pinger
      );

      //! Pre-message hook for async input port seqRunIn
      virtual void seqRunIn_preMsgHook(
          FwIndexType portNum, //!< The port number
          const Fw::StringBase& filename //!< The sequence file
      );

      //! Pre-message hook for async input port tlmWrite
      virtual void tlmWrite_preMsgHook(
          FwIndexType portNum, //!< The port number
          U32 context //!< The call order
      );

    protected:

      // ----------------------------------------------------------------------
      // Invocation functions for typed output ports
      // ----------------------------------------------------------------------

      //! Invoke output port cmdOut
      void cmdOut_out(
          FwIndexType portNum, //!< The port number
          Fw::ComBuffer& data, //!< Buffer containing packet data
          U32 context //!< Call context value; meaning chosen by user
      );

      //! Invoke output port getParam
      Fw::ParamValid getParam_out(
          FwIndexType portNum, //!< The port number
          FwPrmIdType id, //!< Parameter ID
          Fw::ParamBuffer& val //!< Buffer containing serialized parameter value.
                               //!< Unmodified if param not found.
      );

      //! Invoke output port getTlmChan
      Fw::TlmValid getTlmChan_out(
          FwIndexType portNum, //!< The port number
          FwChanIdType id, //!< Telemetry Channel ID
          Fw::Time& timeTag, //!< Time Tag
          Fw::TlmBuffer& val //!< Buffer containing serialized telemetry value.
                             //!< Size set to 0 if channel not found, or if no value
                             //!< has been received for this channel yet.
      );

      //! Invoke output port pingOut
      void pingOut_out(
          FwIndexType portNum, //!< The port number
          U32 key //!< Value to return to pinger
      );

      //! Invoke output port seqDoneOut
      void seqDoneOut_out(
          FwIndexType portNum, //!< The port number
          FwOpcodeType opCode, //!< Command Op Code
          U32 cmdSeq, //!< Command Sequence
          const Fw::CmdResponse& response //!< The command response argument
      );

      //! Invoke output port seqStartOut
      void seqStartOut_out(
          FwIndexType portNum, //!< The port number
          const Fw::StringBase& filename //!< The sequence file
      );

    protected:

      // ----------------------------------------------------------------------
      // Internal interface handlers
      // ----------------------------------------------------------------------

      //! Internal interface handler for directive_allocate
      virtual void directive_allocate_internalInterfaceHandler(const Svc::FpySequencer_AllocateDirective& directive) = 0;

      //! Internal interface handler for directive_constCmd
      virtual void directive_constCmd_internalInterfaceHandler(const Svc::FpySequencer_ConstCmdDirective& directive) = 0;

      //! Internal interface handler for directive_discard
      virtual void directive_discard_internalInterfaceHandler(const Svc::FpySequencer_DiscardDirective& directive) = 0;

      //! Internal interface handler for directive_exit
      virtual void directive_exit_internalInterfaceHandler(const Svc::FpySequencer_ExitDirective& directive) = 0;

      //! Internal interface handler for directive_getField
      virtual void directive_getField_internalInterfaceHandler(const Svc::FpySequencer_GetFieldDirective& directive) = 0;

      //! Internal interface handler for directive_getFlag
      virtual void directive_getFlag_internalInterfaceHandler(const Svc::FpySequencer_GetFlagDirective& directive) = 0;

      //! Internal interface handler for directive_goto
      virtual void directive_goto_internalInterfaceHandler(const Svc::FpySequencer_GotoDirective& directive) = 0;

      //! Internal interface handler for directive_if
      virtual void directive_if_internalInterfaceHandler(const Svc::FpySequencer_IfDirective& directive) = 0;

      //! Internal interface handler for directive_load
      virtual void directive_load_internalInterfaceHandler(const Svc::FpySequencer_LoadDirective& directive) = 0;

      //! Internal interface handler for directive_memCmp
      virtual void directive_memCmp_internalInterfaceHandler(const Svc::FpySequencer_MemCmpDirective& directive) = 0;

      //! Internal interface handler for directive_noOp
      virtual void directive_noOp_internalInterfaceHandler(const Svc::FpySequencer_NoOpDirective& directive) = 0;

      //! Internal interface handler for directive_peek
      virtual void directive_peek_internalInterfaceHandler(const Svc::FpySequencer_PeekDirective& directive) = 0;

      //! Internal interface handler for directive_pushPrm
      virtual void directive_pushPrm_internalInterfaceHandler(const Svc::FpySequencer_PushPrmDirective& directive) = 0;

      //! Internal interface handler for directive_pushTime
      virtual void directive_pushTime_internalInterfaceHandler(const Svc::FpySequencer_PushTimeDirective& directive) = 0;

      //! Internal interface handler for directive_pushTlmVal
      virtual void directive_pushTlmVal_internalInterfaceHandler(const Svc::FpySequencer_PushTlmValDirective& directive) = 0;

      //! Internal interface handler for directive_pushTlmValAndTime
      virtual void directive_pushTlmValAndTime_internalInterfaceHandler(const Svc::FpySequencer_PushTlmValAndTimeDirective& directive) = 0;

      //! Internal interface handler for directive_pushVal
      virtual void directive_pushVal_internalInterfaceHandler(const Svc::FpySequencer_PushValDirective& directive) = 0;

      //! Internal interface handler for directive_setFlag
      virtual void directive_setFlag_internalInterfaceHandler(const Svc::FpySequencer_SetFlagDirective& directive) = 0;

      //! Internal interface handler for directive_stackCmd
      virtual void directive_stackCmd_internalInterfaceHandler(const Svc::FpySequencer_StackCmdDirective& directive) = 0;

      //! Internal interface handler for directive_stackOp
      virtual void directive_stackOp_internalInterfaceHandler(const Svc::FpySequencer_StackOpDirective& directive) = 0;

      //! Internal interface handler for directive_store
      virtual void directive_store_internalInterfaceHandler(const Svc::FpySequencer_StoreDirective& directive) = 0;

      //! Internal interface handler for directive_storeConstOffset
      virtual void directive_storeConstOffset_internalInterfaceHandler(const Svc::FpySequencer_StoreConstOffsetDirective& directive) = 0;

      //! Internal interface handler for directive_waitAbs
      virtual void directive_waitAbs_internalInterfaceHandler(const Svc::FpySequencer_WaitAbsDirective& directive) = 0;

      //! Internal interface handler for directive_waitRel
      virtual void directive_waitRel_internalInterfaceHandler(const Svc::FpySequencer_WaitRelDirective& directive) = 0;

    protected:

      // ----------------------------------------------------------------------
      // Internal interface base-class functions
      // ----------------------------------------------------------------------

      //! Internal interface base-class function for directive_allocate
      void directive_allocate_internalInterfaceInvoke(const Svc::FpySequencer_AllocateDirective& directive);

      //! Internal interface base-class function for directive_constCmd
      void directive_constCmd_internalInterfaceInvoke(const Svc::FpySequencer_ConstCmdDirective& directive);

      //! Internal interface base-class function for directive_discard
      void directive_discard_internalInterfaceInvoke(const Svc::FpySequencer_DiscardDirective& directive);

      //! Internal interface base-class function for directive_exit
      void directive_exit_internalInterfaceInvoke(const Svc::FpySequencer_ExitDirective& directive);

      //! Internal interface base-class function for directive_getField
      void directive_getField_internalInterfaceInvoke(const Svc::FpySequencer_GetFieldDirective& directive);

      //! Internal interface base-class function for directive_getFlag
      void directive_getFlag_internalInterfaceInvoke(const Svc::FpySequencer_GetFlagDirective& directive);

      //! Internal interface base-class function for directive_goto
      void directive_goto_internalInterfaceInvoke(const Svc::FpySequencer_GotoDirective& directive);

      //! Internal interface base-class function for directive_if
      void directive_if_internalInterfaceInvoke(const Svc::FpySequencer_IfDirective& directive);

      //! Internal interface base-class function for directive_load
      void directive_load_internalInterfaceInvoke(const Svc::FpySequencer_LoadDirective& directive);

      //! Internal interface base-class function for directive_memCmp
      void directive_memCmp_internalInterfaceInvoke(const Svc::FpySequencer_MemCmpDirective& directive);

      //! Internal interface base-class function for directive_noOp
      void directive_noOp_internalInterfaceInvoke(const Svc::FpySequencer_NoOpDirective& directive);

      //! Internal interface base-class function for directive_peek
      void directive_peek_internalInterfaceInvoke(const Svc::FpySequencer_PeekDirective& directive);

      //! Internal interface base-class function for directive_pushPrm
      void directive_pushPrm_internalInterfaceInvoke(const Svc::FpySequencer_PushPrmDirective& directive);

      //! Internal interface base-class function for directive_pushTime
      void directive_pushTime_internalInterfaceInvoke(const Svc::FpySequencer_PushTimeDirective& directive);

      //! Internal interface base-class function for directive_pushTlmVal
      void directive_pushTlmVal_internalInterfaceInvoke(const Svc::FpySequencer_PushTlmValDirective& directive);

      //! Internal interface base-class function for directive_pushTlmValAndTime
      void directive_pushTlmValAndTime_internalInterfaceInvoke(const Svc::FpySequencer_PushTlmValAndTimeDirective& directive);

      //! Internal interface base-class function for directive_pushVal
      void directive_pushVal_internalInterfaceInvoke(const Svc::FpySequencer_PushValDirective& directive);

      //! Internal interface base-class function for directive_setFlag
      void directive_setFlag_internalInterfaceInvoke(const Svc::FpySequencer_SetFlagDirective& directive);

      //! Internal interface base-class function for directive_stackCmd
      void directive_stackCmd_internalInterfaceInvoke(const Svc::FpySequencer_StackCmdDirective& directive);

      //! Internal interface base-class function for directive_stackOp
      void directive_stackOp_internalInterfaceInvoke(const Svc::FpySequencer_StackOpDirective& directive);

      //! Internal interface base-class function for directive_store
      void directive_store_internalInterfaceInvoke(const Svc::FpySequencer_StoreDirective& directive);

      //! Internal interface base-class function for directive_storeConstOffset
      void directive_storeConstOffset_internalInterfaceInvoke(const Svc::FpySequencer_StoreConstOffsetDirective& directive);

      //! Internal interface base-class function for directive_waitAbs
      void directive_waitAbs_internalInterfaceInvoke(const Svc::FpySequencer_WaitAbsDirective& directive);

      //! Internal interface base-class function for directive_waitRel
      void directive_waitRel_internalInterfaceInvoke(const Svc::FpySequencer_WaitRelDirective& directive);

    protected:

      // ----------------------------------------------------------------------
      // State getter functions
      // ----------------------------------------------------------------------

      //! Get the state of state machine instance sequencer
      Svc_FpySequencer_SequencerStateMachine::State sequencer_getState() const;

    protected:

      // ----------------------------------------------------------------------
      // Signal send functions
      // ----------------------------------------------------------------------

      //! Send signal cmd_VALIDATE to state machine sequencer
      void sequencer_sendSignal_cmd_VALIDATE(
          const Svc::FpySequencer_SequenceExecutionArgs& value //!< The value
      );

      //! Send signal cmd_RUN to state machine sequencer
      void sequencer_sendSignal_cmd_RUN(
          const Svc::FpySequencer_SequenceExecutionArgs& value //!< The value
      );

      //! Send signal cmd_RUN_VALIDATED to state machine sequencer
      void sequencer_sendSignal_cmd_RUN_VALIDATED(
          const Svc::FpySequencer_SequenceExecutionArgs& value //!< The value
      );

      //! Send signal cmd_CANCEL to state machine sequencer
      void sequencer_sendSignal_cmd_CANCEL();

      //! Send signal cmd_SET_BREAKPOINT to state machine sequencer
      void sequencer_sendSignal_cmd_SET_BREAKPOINT(
          const Svc::FpySequencer_BreakpointArgs& value //!< The value
      );

      //! Send signal cmd_CLEAR_BREAKPOINT to state machine sequencer
      void sequencer_sendSignal_cmd_CLEAR_BREAKPOINT();

      //! Send signal result_failure to state machine sequencer
      void sequencer_sendSignal_result_failure();

      //! Send signal result_success to state machine sequencer
      void sequencer_sendSignal_result_success();

      //! Send signal entered to state machine sequencer
      void sequencer_sendSignal_entered();

      //! Send signal result_dispatchStatement_success to state machine sequencer
      void sequencer_sendSignal_result_dispatchStatement_success();

      //! Send signal result_dispatchStatement_failure to state machine sequencer
      void sequencer_sendSignal_result_dispatchStatement_failure();

      //! Send signal result_dispatchStatement_noMoreStatements to state machine sequencer
      void sequencer_sendSignal_result_dispatchStatement_noMoreStatements();

      //! Send signal checkTimersIn to state machine sequencer
      void sequencer_sendSignal_checkTimersIn();

      //! Send signal result_checkShouldWake_wakeup to state machine sequencer
      void sequencer_sendSignal_result_checkShouldWake_wakeup();

      //! Send signal result_checkShouldWake_keepSleeping to state machine sequencer
      void sequencer_sendSignal_result_checkShouldWake_keepSleeping();

      //! Send signal result_timeOpFailed to state machine sequencer
      void sequencer_sendSignal_result_timeOpFailed();

      //! Send signal stmtResponse_beginSleep to state machine sequencer
      void sequencer_sendSignal_stmtResponse_beginSleep();

      //! Send signal stmtResponse_success to state machine sequencer
      void sequencer_sendSignal_stmtResponse_success();

      //! Send signal stmtResponse_failure to state machine sequencer
      void sequencer_sendSignal_stmtResponse_failure();

      //! Send signal stmtResponse_unexpected to state machine sequencer
      void sequencer_sendSignal_stmtResponse_unexpected();

      //! Send signal stmtResponse_keepWaiting to state machine sequencer
      void sequencer_sendSignal_stmtResponse_keepWaiting();

      //! Send signal result_checkStatementTimeout_statementTimeout to state machine sequencer
      void sequencer_sendSignal_result_checkStatementTimeout_statementTimeout();

      //! Send signal result_checkStatementTimeout_noTimeout to state machine sequencer
      void sequencer_sendSignal_result_checkStatementTimeout_noTimeout();

      //! Send signal cmd_CONTINUE to state machine sequencer
      void sequencer_sendSignal_cmd_CONTINUE();

      //! Send signal cmd_BREAK to state machine sequencer
      void sequencer_sendSignal_cmd_BREAK();

      //! Send signal cmd_STEP to state machine sequencer
      void sequencer_sendSignal_cmd_STEP();

    protected:

      // ----------------------------------------------------------------------
      // Functions to implement for internal state machine actions
      // ----------------------------------------------------------------------

      //! Implementation for action signalEntered of state machine Svc_FpySequencer_SequencerStateMachine
      //!
      //! simply raises the "entered" signal
      virtual void Svc_FpySequencer_SequencerStateMachine_action_signalEntered(
          SmId smId, //!< The state machine id
          Svc_FpySequencer_SequencerStateMachine::Signal signal //!< The signal
      ) = 0;

      //! Implementation for action setSequenceFilePath of state machine Svc_FpySequencer_SequencerStateMachine
      //!
      //! sets the current sequence file path member var
      virtual void Svc_FpySequencer_SequencerStateMachine_action_setSequenceFilePath(
          SmId smId, //!< The state machine id
          Svc_FpySequencer_SequencerStateMachine::Signal signal, //!< The signal
          const Svc::FpySequencer_SequenceExecutionArgs& value //!< The value
      ) = 0;

      //! Implementation for action setSequenceBlockState of state machine Svc_FpySequencer_SequencerStateMachine
      //!
      //! sets the block state of the sequence to be run
      virtual void Svc_FpySequencer_SequencerStateMachine_action_setSequenceBlockState(
          SmId smId, //!< The state machine id
          Svc_FpySequencer_SequencerStateMachine::Signal signal, //!< The signal
          const Svc::FpySequencer_SequenceExecutionArgs& value //!< The value
      ) = 0;

      //! Implementation for action validate of state machine Svc_FpySequencer_SequencerStateMachine
      //!
      //! performs all steps necessary for sequence validation, and raises a signal result_success or result_failure
      virtual void Svc_FpySequencer_SequencerStateMachine_action_validate(
          SmId smId, //!< The state machine id
          Svc_FpySequencer_SequencerStateMachine::Signal signal //!< The signal
      ) = 0;

      //! Implementation for action report_seqSucceeded of state machine Svc_FpySequencer_SequencerStateMachine
      //!
      //! reports that a sequence succeeded
      virtual void Svc_FpySequencer_SequencerStateMachine_action_report_seqSucceeded(
          SmId smId, //!< The state machine id
          Svc_FpySequencer_SequencerStateMachine::Signal signal //!< The signal
      ) = 0;

      //! Implementation for action report_seqCancelled of state machine Svc_FpySequencer_SequencerStateMachine
      //!
      //! reports that a sequence was cancelled
      virtual void Svc_FpySequencer_SequencerStateMachine_action_report_seqCancelled(
          SmId smId, //!< The state machine id
          Svc_FpySequencer_SequencerStateMachine::Signal signal //!< The signal
      ) = 0;

      //! Implementation for action report_seqFailed of state machine Svc_FpySequencer_SequencerStateMachine
      //!
      //! called when a sequence failed to execute successfully
      virtual void Svc_FpySequencer_SequencerStateMachine_action_report_seqFailed(
          SmId smId, //!< The state machine id
          Svc_FpySequencer_SequencerStateMachine::Signal signal //!< The signal
      ) = 0;

      //! Implementation for action report_seqStarted of state machine Svc_FpySequencer_SequencerStateMachine
      //!
      //! called when a sequence starts
      virtual void Svc_FpySequencer_SequencerStateMachine_action_report_seqStarted(
          SmId smId, //!< The state machine id
          Svc_FpySequencer_SequencerStateMachine::Signal signal //!< The signal
      ) = 0;

      //! Implementation for action setGoalState_RUNNING of state machine Svc_FpySequencer_SequencerStateMachine
      //!
      //! sets the goal state to RUNNING
      virtual void Svc_FpySequencer_SequencerStateMachine_action_setGoalState_RUNNING(
          SmId smId, //!< The state machine id
          Svc_FpySequencer_SequencerStateMachine::Signal signal //!< The signal
      ) = 0;

      //! Implementation for action setGoalState_VALID of state machine Svc_FpySequencer_SequencerStateMachine
      //!
      //! sets the goal state to VALID
      virtual void Svc_FpySequencer_SequencerStateMachine_action_setGoalState_VALID(
          SmId smId, //!< The state machine id
          Svc_FpySequencer_SequencerStateMachine::Signal signal //!< The signal
      ) = 0;

      //! Implementation for action setGoalState_IDLE of state machine Svc_FpySequencer_SequencerStateMachine
      //!
      //! sets the goal state to IDLE
      virtual void Svc_FpySequencer_SequencerStateMachine_action_setGoalState_IDLE(
          SmId smId, //!< The state machine id
          Svc_FpySequencer_SequencerStateMachine::Signal signal //!< The signal
      ) = 0;

      //! Implementation for action sendCmdResponse_OK of state machine Svc_FpySequencer_SequencerStateMachine
      //!
      //! responds to the calling command with OK
      virtual void Svc_FpySequencer_SequencerStateMachine_action_sendCmdResponse_OK(
          SmId smId, //!< The state machine id
          Svc_FpySequencer_SequencerStateMachine::Signal signal //!< The signal
      ) = 0;

      //! Implementation for action sendCmdResponse_EXECUTION_ERROR of state machine Svc_FpySequencer_SequencerStateMachine
      //!
      //! responds to the calling command with EXECUTION_ERROR
      virtual void Svc_FpySequencer_SequencerStateMachine_action_sendCmdResponse_EXECUTION_ERROR(
          SmId smId, //!< The state machine id
          Svc_FpySequencer_SequencerStateMachine::Signal signal //!< The signal
      ) = 0;

      //! Implementation for action clearSequenceFile of state machine Svc_FpySequencer_SequencerStateMachine
      //!
      //! clears all variables related to the loading/validating of the sequence file
      virtual void Svc_FpySequencer_SequencerStateMachine_action_clearSequenceFile(
          SmId smId, //!< The state machine id
          Svc_FpySequencer_SequencerStateMachine::Signal signal //!< The signal
      ) = 0;

      //! Implementation for action clearBreakpoint of state machine Svc_FpySequencer_SequencerStateMachine
      //!
      //! clears the breakpoint setting
      virtual void Svc_FpySequencer_SequencerStateMachine_action_clearBreakpoint(
          SmId smId, //!< The state machine id
          Svc_FpySequencer_SequencerStateMachine::Signal signal //!< The signal
      ) = 0;

      //! Implementation for action checkShouldWake of state machine Svc_FpySequencer_SequencerStateMachine
      //!
      //! checks if sequencer should wake from sleep
      virtual void Svc_FpySequencer_SequencerStateMachine_action_checkShouldWake(
          SmId smId, //!< The state machine id
          Svc_FpySequencer_SequencerStateMachine::Signal signal //!< The signal
      ) = 0;

      //! Implementation for action dispatchStatement of state machine Svc_FpySequencer_SequencerStateMachine
      //!
      //! iterates to the next statement and dispatches it
      virtual void Svc_FpySequencer_SequencerStateMachine_action_dispatchStatement(
          SmId smId, //!< The state machine id
          Svc_FpySequencer_SequencerStateMachine::Signal signal //!< The signal
      ) = 0;

      //! Implementation for action resetRuntime of state machine Svc_FpySequencer_SequencerStateMachine
      //!
      //! resets the sequence runtime
      virtual void Svc_FpySequencer_SequencerStateMachine_action_resetRuntime(
          SmId smId, //!< The state machine id
          Svc_FpySequencer_SequencerStateMachine::Signal signal //!< The signal
      ) = 0;

      //! Implementation for action checkStatementTimeout of state machine Svc_FpySequencer_SequencerStateMachine
      //!
      //! checks if the current statement has timed out
      virtual void Svc_FpySequencer_SequencerStateMachine_action_checkStatementTimeout(
          SmId smId, //!< The state machine id
          Svc_FpySequencer_SequencerStateMachine::Signal signal //!< The signal
      ) = 0;

      //! Implementation for action incrementSequenceCounter of state machine Svc_FpySequencer_SequencerStateMachine
      //!
      //! increments the m_sequencesStarted counter
      virtual void Svc_FpySequencer_SequencerStateMachine_action_incrementSequenceCounter(
          SmId smId, //!< The state machine id
          Svc_FpySequencer_SequencerStateMachine::Signal signal //!< The signal
      ) = 0;

      //! Implementation for action report_seqBroken of state machine Svc_FpySequencer_SequencerStateMachine
      //!
      //! reports that a breakpoint was hit
      virtual void Svc_FpySequencer_SequencerStateMachine_action_report_seqBroken(
          SmId smId, //!< The state machine id
          Svc_FpySequencer_SequencerStateMachine::Signal signal //!< The signal
      ) = 0;

      //! Implementation for action setBreakpoint of state machine Svc_FpySequencer_SequencerStateMachine
      //!
      //! sets the breakpoint to the provided args
      virtual void Svc_FpySequencer_SequencerStateMachine_action_setBreakpoint(
          SmId smId, //!< The state machine id
          Svc_FpySequencer_SequencerStateMachine::Signal signal, //!< The signal
          const Svc::FpySequencer_BreakpointArgs& value //!< The value
      ) = 0;

      //! Implementation for action setBreakBeforeNextLine of state machine Svc_FpySequencer_SequencerStateMachine
      //!
      //! sets the "break on next line" flag to true
      virtual void Svc_FpySequencer_SequencerStateMachine_action_setBreakBeforeNextLine(
          SmId smId, //!< The state machine id
          Svc_FpySequencer_SequencerStateMachine::Signal signal //!< The signal
      ) = 0;

      //! Implementation for action clearBreakBeforeNextLine of state machine Svc_FpySequencer_SequencerStateMachine
      //!
      //! sets the "break on next line" flag to false
      virtual void Svc_FpySequencer_SequencerStateMachine_action_clearBreakBeforeNextLine(
          SmId smId, //!< The state machine id
          Svc_FpySequencer_SequencerStateMachine::Signal signal //!< The signal
      ) = 0;

    protected:

      // ----------------------------------------------------------------------
      // Functions to implement for internal state machine guards
      // ----------------------------------------------------------------------

      //! Implementation for guard goalStateIs_RUNNING of state machine Svc_FpySequencer_SequencerStateMachine
      //!
      //! return true if the goal state is RUNNING
      virtual bool Svc_FpySequencer_SequencerStateMachine_guard_goalStateIs_RUNNING(
          SmId smId, //!< The state machine id
          Svc_FpySequencer_SequencerStateMachine::Signal signal //!< The signal
      ) const = 0;

      //! Implementation for guard shouldBreak of state machine Svc_FpySequencer_SequencerStateMachine
      //!
      //! return true if should break at this point in execution, before dispatching
      //! next stmt
      virtual bool Svc_FpySequencer_SequencerStateMachine_guard_shouldBreak(
          SmId smId, //!< The state machine id
          Svc_FpySequencer_SequencerStateMachine::Signal signal //!< The signal
      ) const = 0;

      //! Implementation for guard breakOnce of state machine Svc_FpySequencer_SequencerStateMachine
      //!
      //! return true if this breakpoint should only happen once
      virtual bool Svc_FpySequencer_SequencerStateMachine_guard_breakOnce(
          SmId smId, //!< The state machine id
          Svc_FpySequencer_SequencerStateMachine::Signal signal //!< The signal
      ) const = 0;

    protected:

      // ----------------------------------------------------------------------
      // Command response
      // ----------------------------------------------------------------------

      //! Emit command response
      void cmdResponse_out(
          FwOpcodeType opCode, //!< The opcode
          U32 cmdSeq, //!< The command sequence number
          Fw::CmdResponse response //!< The command response
      );

    protected:

      // ----------------------------------------------------------------------
      // Command handlers to implement
      // ----------------------------------------------------------------------

      //! Handler for command RUN
      //!
      //! Loads, validates and runs a sequence
      virtual void RUN_cmdHandler(
          FwOpcodeType opCode, //!< The opcode
          U32 cmdSeq, //!< The command sequence number
          const Fw::CmdStringArg& fileName, //!< The name of the sequence file
          Svc::FpySequencer_BlockState block //!< Return command status when complete or not
      ) = 0;

      //! Handler for command VALIDATE
      //!
      //! Loads and validates a sequence
      virtual void VALIDATE_cmdHandler(
          FwOpcodeType opCode, //!< The opcode
          U32 cmdSeq, //!< The command sequence number
          const Fw::CmdStringArg& fileName //!< The name of the sequence file
      ) = 0;

      //! Handler for command RUN_VALIDATED
      //!
      //! Must be called after VALIDATE. Runs the sequence that was validated.
      virtual void RUN_VALIDATED_cmdHandler(
          FwOpcodeType opCode, //!< The opcode
          U32 cmdSeq, //!< The command sequence number
          Svc::FpySequencer_BlockState block //!< Return command status when complete or not
      ) = 0;

      //! Handler for command CANCEL
      //!
      //! Cancels a running or validated sequence. After running CANCEL, the sequencer
      //! should return to IDLE
      virtual void CANCEL_cmdHandler(
          FwOpcodeType opCode, //!< The opcode
          U32 cmdSeq //!< The command sequence number
      ) = 0;

      //! Handler for command SET_BREAKPOINT
      //!
      //! Sets the breakpoint which will pause the execution of the sequencer when
      //! reached, until unpaused by the CONTINUE command. Will pause just before
      //! dispatching the specified directive. This command is valid in all states. Breakpoint
      //! settings are cleared after a sequence ends execution.
      virtual void SET_BREAKPOINT_cmdHandler(
          FwOpcodeType opCode, //!< The opcode
          U32 cmdSeq, //!< The command sequence number
          U32 stmtIdx, //!< The directive index to pause execution before.
          bool breakOnce //!< Whether or not to break only once at this breakpoint
      ) = 0;

      //! Handler for command BREAK
      //!
      //! Pauses the execution of the sequencer, just before it is about to dispatch the next directive,
      //! until unpaused by the CONTINUE command, or stepped by the STEP command. This command is only valid
      //! substates of the RUNNING state that are not RUNNING.PAUSED.
      virtual void BREAK_cmdHandler(
          FwOpcodeType opCode, //!< The opcode
          U32 cmdSeq //!< The command sequence number
      ) = 0;

      //! Handler for command CONTINUE
      //!
      //! Continues the automatic execution of the sequence after it has been paused. If a breakpoint is still
      //! set, it may pause again on that breakpoint. This command is only valid in the RUNNING.PAUSED state.
      virtual void CONTINUE_cmdHandler(
          FwOpcodeType opCode, //!< The opcode
          U32 cmdSeq //!< The command sequence number
      ) = 0;

      //! Handler for command CLEAR_BREAKPOINT
      //!
      //! Clears the breakpoint, but does not continue executing the sequence. This command
      //! is valid in all states. This happens automatically when a sequence ends execution.
      virtual void CLEAR_BREAKPOINT_cmdHandler(
          FwOpcodeType opCode, //!< The opcode
          U32 cmdSeq //!< The command sequence number
      ) = 0;

      //! Handler for command STEP
      //!
      //! Dispatches and awaits the result of the next directive, or ends the sequence if no more directives remain. Returns
      //! to the RUNNING.PAUSED state if the directive executes successfully. This command is only valid in the RUNNING.PAUSED state.
      virtual void STEP_cmdHandler(
          FwOpcodeType opCode, //!< The opcode
          U32 cmdSeq //!< The command sequence number
      ) = 0;

      //! Handler for command SET_FLAG
      //!
      //! Sets the value of a flag. See Fpy.FlagId docstrings for info on each flag.
      //! This command is only valid in the RUNNING state.
      virtual void SET_FLAG_cmdHandler(
          FwOpcodeType opCode, //!< The opcode
          U32 cmdSeq, //!< The command sequence number
          Svc::Fpy::FlagId flag,
          bool value
      ) = 0;

      //! Handler for command DUMP_STACK_TO_FILE
      //!
      //! Writes the contents of the stack to a file. This command is only valid in the RUNNING.PAUSED state.
      virtual void DUMP_STACK_TO_FILE_cmdHandler(
          FwOpcodeType opCode, //!< The opcode
          U32 cmdSeq, //!< The command sequence number
          const Fw::CmdStringArg& fileName //!< The name of the output file
      ) = 0;

    protected:

      // ----------------------------------------------------------------------
      // Command handler base-class functions
      //
      // Call these functions directly to bypass the command input port
      // ----------------------------------------------------------------------

      //! Base-class handler function for command RUN
      //!
      //! Loads, validates and runs a sequence
      void RUN_cmdHandlerBase(
          FwOpcodeType opCode, //!< The opcode
          U32 cmdSeq, //!< The command sequence number
          Fw::CmdArgBuffer& args //!< The command argument buffer
      );

      //! Base-class handler function for command VALIDATE
      //!
      //! Loads and validates a sequence
      void VALIDATE_cmdHandlerBase(
          FwOpcodeType opCode, //!< The opcode
          U32 cmdSeq, //!< The command sequence number
          Fw::CmdArgBuffer& args //!< The command argument buffer
      );

      //! Base-class handler function for command RUN_VALIDATED
      //!
      //! Must be called after VALIDATE. Runs the sequence that was validated.
      void RUN_VALIDATED_cmdHandlerBase(
          FwOpcodeType opCode, //!< The opcode
          U32 cmdSeq, //!< The command sequence number
          Fw::CmdArgBuffer& args //!< The command argument buffer
      );

      //! Base-class handler function for command CANCEL
      //!
      //! Cancels a running or validated sequence. After running CANCEL, the sequencer
      //! should return to IDLE
      void CANCEL_cmdHandlerBase(
          FwOpcodeType opCode, //!< The opcode
          U32 cmdSeq, //!< The command sequence number
          Fw::CmdArgBuffer& args //!< The command argument buffer
      );

      //! Base-class handler function for command SET_BREAKPOINT
      //!
      //! Sets the breakpoint which will pause the execution of the sequencer when
      //! reached, until unpaused by the CONTINUE command. Will pause just before
      //! dispatching the specified directive. This command is valid in all states. Breakpoint
      //! settings are cleared after a sequence ends execution.
      void SET_BREAKPOINT_cmdHandlerBase(
          FwOpcodeType opCode, //!< The opcode
          U32 cmdSeq, //!< The command sequence number
          Fw::CmdArgBuffer& args //!< The command argument buffer
      );

      //! Base-class handler function for command BREAK
      //!
      //! Pauses the execution of the sequencer, just before it is about to dispatch the next directive,
      //! until unpaused by the CONTINUE command, or stepped by the STEP command. This command is only valid
      //! substates of the RUNNING state that are not RUNNING.PAUSED.
      void BREAK_cmdHandlerBase(
          FwOpcodeType opCode, //!< The opcode
          U32 cmdSeq, //!< The command sequence number
          Fw::CmdArgBuffer& args //!< The command argument buffer
      );

      //! Base-class handler function for command CONTINUE
      //!
      //! Continues the automatic execution of the sequence after it has been paused. If a breakpoint is still
      //! set, it may pause again on that breakpoint. This command is only valid in the RUNNING.PAUSED state.
      void CONTINUE_cmdHandlerBase(
          FwOpcodeType opCode, //!< The opcode
          U32 cmdSeq, //!< The command sequence number
          Fw::CmdArgBuffer& args //!< The command argument buffer
      );

      //! Base-class handler function for command CLEAR_BREAKPOINT
      //!
      //! Clears the breakpoint, but does not continue executing the sequence. This command
      //! is valid in all states. This happens automatically when a sequence ends execution.
      void CLEAR_BREAKPOINT_cmdHandlerBase(
          FwOpcodeType opCode, //!< The opcode
          U32 cmdSeq, //!< The command sequence number
          Fw::CmdArgBuffer& args //!< The command argument buffer
      );

      //! Base-class handler function for command STEP
      //!
      //! Dispatches and awaits the result of the next directive, or ends the sequence if no more directives remain. Returns
      //! to the RUNNING.PAUSED state if the directive executes successfully. This command is only valid in the RUNNING.PAUSED state.
      void STEP_cmdHandlerBase(
          FwOpcodeType opCode, //!< The opcode
          U32 cmdSeq, //!< The command sequence number
          Fw::CmdArgBuffer& args //!< The command argument buffer
      );

      //! Base-class handler function for command SET_FLAG
      //!
      //! Sets the value of a flag. See Fpy.FlagId docstrings for info on each flag.
      //! This command is only valid in the RUNNING state.
      void SET_FLAG_cmdHandlerBase(
          FwOpcodeType opCode, //!< The opcode
          U32 cmdSeq, //!< The command sequence number
          Fw::CmdArgBuffer& args //!< The command argument buffer
      );

      //! Base-class handler function for command DUMP_STACK_TO_FILE
      //!
      //! Writes the contents of the stack to a file. This command is only valid in the RUNNING.PAUSED state.
      void DUMP_STACK_TO_FILE_cmdHandlerBase(
          FwOpcodeType opCode, //!< The opcode
          U32 cmdSeq, //!< The command sequence number
          Fw::CmdArgBuffer& args //!< The command argument buffer
      );

    protected:

      // ----------------------------------------------------------------------
      // Pre-message hooks for async commands
      //
      // Each of these functions is invoked just before processing the
      // corresponding command. By default they do nothing. You can
      // override them to provide specific pre-command behavior.
      // ----------------------------------------------------------------------

      //! Pre-message hook for command RUN
      virtual void RUN_preMsgHook(
          FwOpcodeType opCode, //!< The opcode
          U32 cmdSeq //!< The command sequence number
      );

      //! Pre-message hook for command VALIDATE
      virtual void VALIDATE_preMsgHook(
          FwOpcodeType opCode, //!< The opcode
          U32 cmdSeq //!< The command sequence number
      );

      //! Pre-message hook for command RUN_VALIDATED
      virtual void RUN_VALIDATED_preMsgHook(
          FwOpcodeType opCode, //!< The opcode
          U32 cmdSeq //!< The command sequence number
      );

      //! Pre-message hook for command CANCEL
      virtual void CANCEL_preMsgHook(
          FwOpcodeType opCode, //!< The opcode
          U32 cmdSeq //!< The command sequence number
      );

      //! Pre-message hook for command SET_BREAKPOINT
      virtual void SET_BREAKPOINT_preMsgHook(
          FwOpcodeType opCode, //!< The opcode
          U32 cmdSeq //!< The command sequence number
      );

      //! Pre-message hook for command BREAK
      virtual void BREAK_preMsgHook(
          FwOpcodeType opCode, //!< The opcode
          U32 cmdSeq //!< The command sequence number
      );

      //! Pre-message hook for command CONTINUE
      virtual void CONTINUE_preMsgHook(
          FwOpcodeType opCode, //!< The opcode
          U32 cmdSeq //!< The command sequence number
      );

      //! Pre-message hook for command CLEAR_BREAKPOINT
      virtual void CLEAR_BREAKPOINT_preMsgHook(
          FwOpcodeType opCode, //!< The opcode
          U32 cmdSeq //!< The command sequence number
      );

      //! Pre-message hook for command STEP
      virtual void STEP_preMsgHook(
          FwOpcodeType opCode, //!< The opcode
          U32 cmdSeq //!< The command sequence number
      );

      //! Pre-message hook for command SET_FLAG
      virtual void SET_FLAG_preMsgHook(
          FwOpcodeType opCode, //!< The opcode
          U32 cmdSeq //!< The command sequence number
      );

      //! Pre-message hook for command DUMP_STACK_TO_FILE
      virtual void DUMP_STACK_TO_FILE_preMsgHook(
          FwOpcodeType opCode, //!< The opcode
          U32 cmdSeq //!< The command sequence number
      );

    protected:

      // ----------------------------------------------------------------------
      // Event logging functions
      // ----------------------------------------------------------------------

      //! Log event InvalidCommand
      void log_WARNING_HI_InvalidCommand(I32 state) const;

      //! Log event InvalidSeqRunCall
      void log_WARNING_HI_InvalidSeqRunCall(I32 state) const;

      //! Log event FileOpenError
      void log_WARNING_HI_FileOpenError(
          const Fw::StringBase& filePath,
          I32 errorCode
      ) const;

      //! Log event FileWriteError
      void log_WARNING_HI_FileWriteError(
          FwSizeType writeSize,
          const Fw::StringBase& filePath,
          I32 errorCode
      ) const;

      //! Log event FileReadError
      void log_WARNING_HI_FileReadError(
          Svc::FpySequencer_FileReadStage readStage,
          const Fw::StringBase& filePath,
          I32 errorCode
      ) const;

      //! Log event EndOfFileError
      void log_WARNING_HI_EndOfFileError(
          Svc::FpySequencer_FileReadStage readStage,
          const Fw::StringBase& filePath
      ) const;

      //! Log event FileReadDeserializeError
      void log_WARNING_HI_FileReadDeserializeError(
          Svc::FpySequencer_FileReadStage readStage,
          const Fw::StringBase& filePath,
          I32 errorCode,
          U64 buffLeft,
          U64 buffLength
      ) const;

      //! Log event WrongSchemaVersion
      void log_WARNING_HI_WrongSchemaVersion(
          U8 expected,
          U8 actual
      ) const;

      //! Log event WrongCRC
      void log_WARNING_HI_WrongCRC(
          U32 expected,
          U32 actual
      ) const;

      //! Log event ExtraBytesInSequence
      void log_WARNING_HI_ExtraBytesInSequence(FwSizeType remaining) const;

      //! Log event InsufficientBufferSpace
      void log_WARNING_HI_InsufficientBufferSpace(
          U64 bufferSize,
          const Fw::StringBase& filePath
      ) const;

      //! Log event CommandFailed
      void log_WARNING_HI_CommandFailed(
          FwOpcodeType opCode,
          U32 stmtIdx,
          const Fw::StringBase& filePath,
          Fw::CmdResponse response
      ) const;

      //! Log event SequenceDone
      void log_ACTIVITY_HI_SequenceDone(const Fw::StringBase& filePath) const;

      //! Log event SequenceCancelled
      void log_ACTIVITY_HI_SequenceCancelled(const Fw::StringBase& filePath) const;

      //! Log event SequenceExitedWithError
      void log_WARNING_HI_SequenceExitedWithError(
          const Fw::StringBase& filePath,
          U8 errorCode
      ) const;

      //! Log event UnknownSequencerDirective
      void log_WARNING_HI_UnknownSequencerDirective(
          U8 opcode,
          U32 stmtIdx,
          const Fw::StringBase& filePath
      ) const;

      //! Log event CmdResponseWhileNotRunningSequence
      void log_WARNING_LO_CmdResponseWhileNotRunningSequence(
          I32 state,
          FwOpcodeType opcode,
          Fw::CmdResponse response
      ) const;

      //! Log event CmdResponseFromOldSequence
      void log_WARNING_LO_CmdResponseFromOldSequence(
          FwOpcodeType opcode,
          Fw::CmdResponse response,
          U16 oldSequenceIdx,
          U16 currentSequenceIdx
      ) const;

      //! Log event CmdResponseWhileNotAwaiting
      void log_WARNING_HI_CmdResponseWhileNotAwaiting(
          FwOpcodeType opcode,
          Fw::CmdResponse response
      ) const;

      //! Log event CmdResponseWhileAwaitingDirective
      void log_WARNING_HI_CmdResponseWhileAwaitingDirective(
          FwOpcodeType opcode,
          Fw::CmdResponse response,
          U8 expectedDirectiveOpcode
      ) const;

      //! Log event WrongCmdResponseOpcode
      void log_WARNING_HI_WrongCmdResponseOpcode(
          FwOpcodeType opcode,
          Fw::CmdResponse response,
          FwOpcodeType expectedOpcode
      ) const;

      //! Log event WrongCmdResponseIndex
      void log_WARNING_HI_WrongCmdResponseIndex(
          FwOpcodeType opcode,
          Fw::CmdResponse response,
          U16 actualCmdIdx,
          U16 expectedCmdIdx
      ) const;

      //! Log event DirectiveDeserializeError
      void log_WARNING_HI_DirectiveDeserializeError(
          U8 opcode,
          U32 stmtIdx,
          I32 errorCode,
          U64 buffLeft,
          U64 buffLength
      ) const;

      //! Log event MismatchedTimeBase
      void log_WARNING_HI_MismatchedTimeBase(
          I32 internalTimeBase,
          I32 otherTimeBase
      ) const;

      //! Log event MismatchedTimeContext
      void log_WARNING_HI_MismatchedTimeContext(
          I32 internalTimeContext,
          I32 otherTimeContext
      ) const;

      //! Log event CommandTimedOut
      void log_WARNING_HI_CommandTimedOut(
          FwOpcodeType opCode,
          U32 stmtIdx,
          const Fw::StringBase& filePath
      ) const;

      //! Log event DirectiveTimedOut
      void log_WARNING_HI_DirectiveTimedOut(
          U8 opCode,
          U32 stmtIdx,
          const Fw::StringBase& filePath
      ) const;

      //! Log event TooManySequenceArgs
      void log_WARNING_HI_TooManySequenceArgs(
          U8 count,
          U8 max
      ) const;

      //! Log event TooManySequenceDirectives
      void log_WARNING_HI_TooManySequenceDirectives(
          U16 count,
          U16 max
      ) const;

      //! Log event SequencePaused
      void log_ACTIVITY_HI_SequencePaused(U32 stmtIdx) const;

      //! Log event BreakpointSet
      void log_ACTIVITY_HI_BreakpointSet(
          U32 breakpointIdx,
          bool breakOnce
      ) const;

      //! Log event BreakpointCleared
      void log_ACTIVITY_HI_BreakpointCleared() const;

    protected:

      // ----------------------------------------------------------------------
      // Telemetry write functions
      // ----------------------------------------------------------------------

      //! Write telemetry channel State
      //!
      //! the current state of the sequencer
      void tlmWrite_State(
          FwEnumStoreType arg, //!< The telemetry value
          Fw::Time _tlmTime = Fw::Time() //!< Timestamp. Default: unspecified, request from getTime port
      );

      //! Write telemetry channel SequencesSucceeded
      //!
      //! the number of sequences successfully completed
      void tlmWrite_SequencesSucceeded(
          U64 arg, //!< The telemetry value
          Fw::Time _tlmTime = Fw::Time() //!< Timestamp. Default: unspecified, request from getTime port
      );

      //! Write telemetry channel SequencesFailed
      //!
      //! the number of sequences that failed to validate or execute
      void tlmWrite_SequencesFailed(
          U64 arg, //!< The telemetry value
          Fw::Time _tlmTime = Fw::Time() //!< Timestamp. Default: unspecified, request from getTime port
      );

      //! Write telemetry channel SequencesCancelled
      //!
      //! the number of sequences that were cancelled
      void tlmWrite_SequencesCancelled(
          U64 arg, //!< The telemetry value
          Fw::Time _tlmTime = Fw::Time() //!< Timestamp. Default: unspecified, request from getTime port
      );

      //! Write telemetry channel StatementsDispatched
      //!
      //! the number of statements dispatched (successfully or otherwise) total.
      //! Note this is distinct from the number of statements executed. This
      //! number just tracks how many we've sent out
      void tlmWrite_StatementsDispatched(
          U64 arg, //!< The telemetry value
          Fw::Time _tlmTime = Fw::Time() //!< Timestamp. Default: unspecified, request from getTime port
      );

      //! Write telemetry channel StatementsFailed
      //!
      //! the number of statements that failed to execute
      void tlmWrite_StatementsFailed(
          U64 arg, //!< The telemetry value
          Fw::Time _tlmTime = Fw::Time() //!< Timestamp. Default: unspecified, request from getTime port
      );

      //! Write telemetry channel LastDirectiveError
      //!
      //! the error code of the last directive that ran
      void tlmWrite_LastDirectiveError(
          const Svc::Fpy::DirectiveErrorCode& arg, //!< The telemetry value
          Fw::Time _tlmTime = Fw::Time() //!< Timestamp. Default: unspecified, request from getTime port
      );

      //! Write telemetry channel DirectiveErrorIndex
      //!
      //! the index of the last directive to error
      void tlmWrite_DirectiveErrorIndex(
          U64 arg, //!< The telemetry value
          Fw::Time _tlmTime = Fw::Time() //!< Timestamp. Default: unspecified, request from getTime port
      );

      //! Write telemetry channel DirectiveErrorId
      //!
      //! the id of the last directive to error
      void tlmWrite_DirectiveErrorId(
          const Svc::Fpy::DirectiveId& arg, //!< The telemetry value
          Fw::Time _tlmTime = Fw::Time() //!< Timestamp. Default: unspecified, request from getTime port
      );

      //! Write telemetry channel SeqPath
      //!
      //! the currently running sequence
      void tlmWrite_SeqPath(
          const Fw::StringBase& arg, //!< The telemetry value
          Fw::Time _tlmTime = Fw::Time() //!< Timestamp. Default: unspecified, request from getTime port
      );

      //! Write telemetry channel Debug_ReachedEndOfFile
      //!
      //! true if there are no statements remaining in the sequence file
      void tlmWrite_Debug_ReachedEndOfFile(
          bool arg, //!< The telemetry value
          Fw::Time _tlmTime = Fw::Time() //!< Timestamp. Default: unspecified, request from getTime port
      );

      //! Write telemetry channel Debug_NextStatementReadSuccess
      //!
      //! true if we were able to deserialize the next statement successfully
      void tlmWrite_Debug_NextStatementReadSuccess(
          bool arg, //!< The telemetry value
          Fw::Time _tlmTime = Fw::Time() //!< Timestamp. Default: unspecified, request from getTime port
      );

      //! Write telemetry channel Debug_NextStatementOpcode
      //!
      //! the opcode of the next statement to dispatch.
      void tlmWrite_Debug_NextStatementOpcode(
          U8 arg, //!< The telemetry value
          Fw::Time _tlmTime = Fw::Time() //!< Timestamp. Default: unspecified, request from getTime port
      );

      //! Write telemetry channel Debug_NextCmdOpcode
      //!
      //! if the next statement is a cmd directive, the opcode of that cmd
      void tlmWrite_Debug_NextCmdOpcode(
          FwOpcodeType arg, //!< The telemetry value
          Fw::Time _tlmTime = Fw::Time() //!< Timestamp. Default: unspecified, request from getTime port
      );

      //! Write telemetry channel Debug_StackSize
      //!
      //! the size of the stack in bytes
      void tlmWrite_Debug_StackSize(
          Svc::Fpy::StackSizeType arg, //!< The telemetry value
          Fw::Time _tlmTime = Fw::Time() //!< Timestamp. Default: unspecified, request from getTime port
      );

      //! Write telemetry channel BreakpointInUse
      //!
      //! whether or not to break at the breakpoint index
      void tlmWrite_BreakpointInUse(
          bool arg, //!< The telemetry value
          Fw::Time _tlmTime = Fw::Time() //!< Timestamp. Default: unspecified, request from getTime port
      );

      //! Write telemetry channel BreakpointIndex
      //!
      //! the current breakpoint index. The sequence will break at this point
      //! just before dispatching the directive at this index
      void tlmWrite_BreakpointIndex(
          U32 arg, //!< The telemetry value
          Fw::Time _tlmTime = Fw::Time() //!< Timestamp. Default: unspecified, request from getTime port
      );

      //! Write telemetry channel BreakOnlyOnceOnBreakpoint
      //!
      //! whether or not to remove the breakpoint after breaking on it
      void tlmWrite_BreakOnlyOnceOnBreakpoint(
          bool arg, //!< The telemetry value
          Fw::Time _tlmTime = Fw::Time() //!< Timestamp. Default: unspecified, request from getTime port
      );

      //! Write telemetry channel BreakBeforeNextLine
      //!
      //! whether or not to break before dispatching the next line,
      //! independent of what line it is.
      //! can be used in combination with breakpointIndex
      void tlmWrite_BreakBeforeNextLine(
          bool arg, //!< The telemetry value
          Fw::Time _tlmTime = Fw::Time() //!< Timestamp. Default: unspecified, request from getTime port
      );

      //! Write telemetry channel PRM_STATEMENT_TIMEOUT_SECS
      //!
      //! value of prm STATEMENT_TIMEOUT_SECS
      void tlmWrite_PRM_STATEMENT_TIMEOUT_SECS(
          F32 arg, //!< The telemetry value
          Fw::Time _tlmTime = Fw::Time() //!< Timestamp. Default: unspecified, request from getTime port
      );

      //! Write telemetry channel PRM_FLAG_DEFAULT_EXIT_ON_CMD_FAIL
      //!
      //! value of prm FLAG_DEFAULT_EXIT_ON_CMD_FAIL
      void tlmWrite_PRM_FLAG_DEFAULT_EXIT_ON_CMD_FAIL(
          bool arg, //!< The telemetry value
          Fw::Time _tlmTime = Fw::Time() //!< Timestamp. Default: unspecified, request from getTime port
      );

    protected:

      // ----------------------------------------------------------------------
      // Parameter update hook
      // ----------------------------------------------------------------------

      //! \brief Called whenever a parameter is updated
      //!
      //! This function does nothing by default. You may override it.
      virtual void parameterUpdated(
          FwPrmIdType id //!< The parameter ID
      );

      // ----------------------------------------------------------------------
      // Parameter load hook
      // ----------------------------------------------------------------------

      //! \brief Called whenever parameters are loaded
      //!
      //! This function does nothing by default. You may override it.
      virtual void parametersLoaded();

    protected:

      // ----------------------------------------------------------------------
      // Parameter get functions
      // ----------------------------------------------------------------------

      //! Get parameter STATEMENT_TIMEOUT_SECS
      //!
      //! \return The parameter value
      //!
      //! the number of seconds to wait before giving up
      //! on a directive or command. if <= 0 or greater than U32 max, never time out.
      //! accuracy of this timeout is determined by the rate group driving this
      //! component. it will be rounded up
      F32 paramGet_STATEMENT_TIMEOUT_SECS(
          Fw::ParamValid& valid //!< Whether the parameter is valid
      );

      //! Get parameter FLAG_DEFAULT_EXIT_ON_CMD_FAIL
      //!
      //! \return The parameter value
      //!
      //! the default value of the EXIT_ON_CMD_FAIL sequence flag
      bool paramGet_FLAG_DEFAULT_EXIT_ON_CMD_FAIL(
          Fw::ParamValid& valid //!< Whether the parameter is valid
      );

    protected:

      // ----------------------------------------------------------------------
      // Time
      // ----------------------------------------------------------------------

      //! Get the time
      //!
      //! \\return The current time
      Fw::Time getTime() const;

    private:

      // ----------------------------------------------------------------------
      // Message dispatch functions
      // ----------------------------------------------------------------------

      //! Called in the message loop to dispatch a message from the queue
      virtual MsgDispatchStatus doDispatch();

    private:

      // ----------------------------------------------------------------------
      // Calls for messages received on special input ports
      // ----------------------------------------------------------------------

      //! Callback for port cmdIn
      static void m_p_cmdIn_in(
          Fw::PassiveComponentBase* callComp, //!< The component instance
          FwIndexType portNum, //!< The port number
          FwOpcodeType opCode, //!< Command Op Code
          U32 cmdSeq, //!< Command Sequence
          Fw::CmdArgBuffer& args //!< Buffer containing arguments
      );

    private:

      // ----------------------------------------------------------------------
      // Calls for messages received on typed input ports
      // ----------------------------------------------------------------------

      //! Callback for port checkTimers
      static void m_p_checkTimers_in(
          Fw::PassiveComponentBase* callComp, //!< The component instance
          FwIndexType portNum, //!< The port number
          U32 context //!< The call order
      );

      //! Callback for port cmdResponseIn
      static void m_p_cmdResponseIn_in(
          Fw::PassiveComponentBase* callComp, //!< The component instance
          FwIndexType portNum, //!< The port number
          FwOpcodeType opCode, //!< Command Op Code
          U32 cmdSeq, //!< Command Sequence
          const Fw::CmdResponse& response //!< The command response argument
      );

      //! Callback for port pingIn
      static void m_p_pingIn_in(
          Fw::PassiveComponentBase* callComp, //!< The component instance
          FwIndexType portNum, //!< The port number
          U32 key //!< Value to return to pinger
      );

      //! Callback for port seqRunIn
      static void m_p_seqRunIn_in(
          Fw::PassiveComponentBase* callComp, //!< The component instance
          FwIndexType portNum, //!< The port number
          const Fw::StringBase& filename //!< The sequence file
      );

      //! Callback for port tlmWrite
      static void m_p_tlmWrite_in(
          Fw::PassiveComponentBase* callComp, //!< The component instance
          FwIndexType portNum, //!< The port number
          U32 context //!< The call order
      );

    private:

      // ----------------------------------------------------------------------
      // Send signal helper functions
      // ----------------------------------------------------------------------

      //! Start sending a signal to a state machine
      void sendSignalStart(
          SmId smId, //!< The state machine ID (input)
          FwEnumStoreType signal, //!< The signal (input)
          Fw::SerialBufferBase& buffer //!< The message buffer (output)
      );

      //! Finish sending a signal to a state machine
      void sequencer_sendSignalFinish(
          Fw::LinearBufferBase& buffer //!< The buffer with the data to send
      );

    private:

      // ----------------------------------------------------------------------
      // Helper functions for state machine dispatch
      // ----------------------------------------------------------------------

      //! Dispatch a signal to a state machine instance
      void smDispatch(
          Fw::SerialBufferBase& buffer //!< The message buffer
      );

      //! Deserialize the state machine ID and signal from the message buffer
      static void deserializeSmIdAndSignal(
          Fw::SerialBufferBase& buffer, //!< The message buffer (input and output)
          FwEnumStoreType& smId, //!< The state machine ID (output)
          FwEnumStoreType& signal //!< The signal (output)
      );

      //! Dispatch a signal to a state machine instance of type Svc_FpySequencer_SequencerStateMachine
      void Svc_FpySequencer_SequencerStateMachine_smDispatch(
          Fw::SerialBufferBase& buffer, //!< The message buffer
          Svc_FpySequencer_SequencerStateMachine& sm, //!< The state machine
          Svc_FpySequencer_SequencerStateMachine::Signal signal //!< The signal
      );

    private:

      // ----------------------------------------------------------------------
      // Parameter set functions
      // ----------------------------------------------------------------------

      //! Set parameter STATEMENT_TIMEOUT_SECS
      //!
      //! \return The command response
      Fw::CmdResponse paramSet_STATEMENT_TIMEOUT_SECS(
          Fw::SerialBufferBase& val //!< The serialization buffer
      );

      //! Set parameter FLAG_DEFAULT_EXIT_ON_CMD_FAIL
      //!
      //! \return The command response
      Fw::CmdResponse paramSet_FLAG_DEFAULT_EXIT_ON_CMD_FAIL(
          Fw::SerialBufferBase& val //!< The serialization buffer
      );

    private:

      // ----------------------------------------------------------------------
      // Parameter save functions
      // ----------------------------------------------------------------------

      //! Save parameter STATEMENT_TIMEOUT_SECS
      //!
      //! \return The command response
      Fw::CmdResponse paramSave_STATEMENT_TIMEOUT_SECS();

      //! Save parameter FLAG_DEFAULT_EXIT_ON_CMD_FAIL
      //!
      //! \return The command response
      Fw::CmdResponse paramSave_FLAG_DEFAULT_EXIT_ON_CMD_FAIL();

    private:

      // ----------------------------------------------------------------------
      // Special input ports
      // ----------------------------------------------------------------------

      //! Input port cmdIn
      Fw::InputCmdPort m_cmdIn_InputPort[NUM_CMDIN_INPUT_PORTS];

    private:

      // ----------------------------------------------------------------------
      // Typed input ports
      // ----------------------------------------------------------------------

      //! Input port checkTimers
      Svc::InputSchedPort m_checkTimers_InputPort[NUM_CHECKTIMERS_INPUT_PORTS];

      //! Input port cmdResponseIn
      Fw::InputCmdResponsePort m_cmdResponseIn_InputPort[NUM_CMDRESPONSEIN_INPUT_PORTS];

      //! Input port pingIn
      Svc::InputPingPort m_pingIn_InputPort[NUM_PINGIN_INPUT_PORTS];

      //! Input port seqRunIn
      Svc::InputCmdSeqInPort m_seqRunIn_InputPort[NUM_SEQRUNIN_INPUT_PORTS];

      //! Input port tlmWrite
      Svc::InputSchedPort m_tlmWrite_InputPort[NUM_TLMWRITE_INPUT_PORTS];

    private:

      // ----------------------------------------------------------------------
      // Special output ports
      // ----------------------------------------------------------------------

      //! Output port cmdRegOut
      Fw::OutputCmdRegPort m_cmdRegOut_OutputPort[NUM_CMDREGOUT_OUTPUT_PORTS];

      //! Output port cmdResponseOut
      Fw::OutputCmdResponsePort m_cmdResponseOut_OutputPort[NUM_CMDRESPONSEOUT_OUTPUT_PORTS];

      //! Output port logOut
      Fw::OutputLogPort m_logOut_OutputPort[NUM_LOGOUT_OUTPUT_PORTS];

#if FW_ENABLE_TEXT_LOGGING == 1

      //! Output port logTextOut
      Fw::OutputLogTextPort m_logTextOut_OutputPort[NUM_LOGTEXTOUT_OUTPUT_PORTS];

#endif

      //! Output port prmGet
      Fw::OutputPrmGetPort m_prmGet_OutputPort[NUM_PRMGET_OUTPUT_PORTS];

      //! Output port prmSet
      Fw::OutputPrmSetPort m_prmSet_OutputPort[NUM_PRMSET_OUTPUT_PORTS];

      //! Output port timeCaller
      Fw::OutputTimePort m_timeCaller_OutputPort[NUM_TIMECALLER_OUTPUT_PORTS];

      //! Output port tlmOut
      Fw::OutputTlmPort m_tlmOut_OutputPort[NUM_TLMOUT_OUTPUT_PORTS];

    private:

      // ----------------------------------------------------------------------
      // Typed output ports
      // ----------------------------------------------------------------------

      //! Output port cmdOut
      Fw::OutputComPort m_cmdOut_OutputPort[NUM_CMDOUT_OUTPUT_PORTS];

      //! Output port getParam
      Fw::OutputPrmGetPort m_getParam_OutputPort[NUM_GETPARAM_OUTPUT_PORTS];

      //! Output port getTlmChan
      Fw::OutputTlmGetPort m_getTlmChan_OutputPort[NUM_GETTLMCHAN_OUTPUT_PORTS];

      //! Output port pingOut
      Svc::OutputPingPort m_pingOut_OutputPort[NUM_PINGOUT_OUTPUT_PORTS];

      //! Output port seqDoneOut
      Fw::OutputCmdResponsePort m_seqDoneOut_OutputPort[NUM_SEQDONEOUT_OUTPUT_PORTS];

      //! Output port seqStartOut
      Svc::OutputCmdSeqInPort m_seqStartOut_OutputPort[NUM_SEQSTARTOUT_OUTPUT_PORTS];

    private:

      // ----------------------------------------------------------------------
      // First update flags for telemetry channels
      // ----------------------------------------------------------------------

      //! Initialized to true; cleared when channel State is first updated
      bool m_first_update_State = true;

      //! Initialized to true; cleared when channel SequencesSucceeded is first updated
      bool m_first_update_SequencesSucceeded = true;

      //! Initialized to true; cleared when channel SequencesFailed is first updated
      bool m_first_update_SequencesFailed = true;

      //! Initialized to true; cleared when channel SequencesCancelled is first updated
      bool m_first_update_SequencesCancelled = true;

      //! Initialized to true; cleared when channel StatementsDispatched is first updated
      bool m_first_update_StatementsDispatched = true;

      //! Initialized to true; cleared when channel StatementsFailed is first updated
      bool m_first_update_StatementsFailed = true;

      //! Initialized to true; cleared when channel LastDirectiveError is first updated
      bool m_first_update_LastDirectiveError = true;

      //! Initialized to true; cleared when channel DirectiveErrorIndex is first updated
      bool m_first_update_DirectiveErrorIndex = true;

      //! Initialized to true; cleared when channel DirectiveErrorId is first updated
      bool m_first_update_DirectiveErrorId = true;

      //! Initialized to true; cleared when channel SeqPath is first updated
      bool m_first_update_SeqPath = true;

      //! Initialized to true; cleared when channel Debug_ReachedEndOfFile is first updated
      bool m_first_update_Debug_ReachedEndOfFile = true;

      //! Initialized to true; cleared when channel Debug_NextStatementReadSuccess is first updated
      bool m_first_update_Debug_NextStatementReadSuccess = true;

      //! Initialized to true; cleared when channel Debug_NextStatementOpcode is first updated
      bool m_first_update_Debug_NextStatementOpcode = true;

      //! Initialized to true; cleared when channel Debug_NextCmdOpcode is first updated
      bool m_first_update_Debug_NextCmdOpcode = true;

      //! Initialized to true; cleared when channel Debug_StackSize is first updated
      bool m_first_update_Debug_StackSize = true;

      //! Initialized to true; cleared when channel BreakpointInUse is first updated
      bool m_first_update_BreakpointInUse = true;

      //! Initialized to true; cleared when channel BreakpointIndex is first updated
      bool m_first_update_BreakpointIndex = true;

      //! Initialized to true; cleared when channel BreakOnlyOnceOnBreakpoint is first updated
      bool m_first_update_BreakOnlyOnceOnBreakpoint = true;

      //! Initialized to true; cleared when channel BreakBeforeNextLine is first updated
      bool m_first_update_BreakBeforeNextLine = true;

      //! Initialized to true; cleared when channel PRM_STATEMENT_TIMEOUT_SECS is first updated
      bool m_first_update_PRM_STATEMENT_TIMEOUT_SECS = true;

      //! Initialized to true; cleared when channel PRM_FLAG_DEFAULT_EXIT_ON_CMD_FAIL is first updated
      bool m_first_update_PRM_FLAG_DEFAULT_EXIT_ON_CMD_FAIL = true;

    private:

      // ----------------------------------------------------------------------
      // Last value storage for telemetry channels
      // ----------------------------------------------------------------------

      //! Records the last emitted value for channel State
      FwEnumStoreType m_last_State = {};

      //! Records the last emitted value for channel SequencesSucceeded
      U64 m_last_SequencesSucceeded = {};

      //! Records the last emitted value for channel SequencesFailed
      U64 m_last_SequencesFailed = {};

      //! Records the last emitted value for channel SequencesCancelled
      U64 m_last_SequencesCancelled = {};

      //! Records the last emitted value for channel StatementsDispatched
      U64 m_last_StatementsDispatched = {};

      //! Records the last emitted value for channel StatementsFailed
      U64 m_last_StatementsFailed = {};

      //! Records the last emitted value for channel LastDirectiveError
      Svc::Fpy::DirectiveErrorCode m_last_LastDirectiveError = {};

      //! Records the last emitted value for channel DirectiveErrorIndex
      U64 m_last_DirectiveErrorIndex = {};

      //! Records the last emitted value for channel DirectiveErrorId
      Svc::Fpy::DirectiveId m_last_DirectiveErrorId = {};

      //! Records the last emitted value for channel SeqPath
      Fw::TlmString m_last_SeqPath = {};

      //! Records the last emitted value for channel Debug_ReachedEndOfFile
      bool m_last_Debug_ReachedEndOfFile = {};

      //! Records the last emitted value for channel Debug_NextStatementReadSuccess
      bool m_last_Debug_NextStatementReadSuccess = {};

      //! Records the last emitted value for channel Debug_NextStatementOpcode
      U8 m_last_Debug_NextStatementOpcode = {};

      //! Records the last emitted value for channel Debug_NextCmdOpcode
      FwOpcodeType m_last_Debug_NextCmdOpcode = {};

      //! Records the last emitted value for channel Debug_StackSize
      Svc::Fpy::StackSizeType m_last_Debug_StackSize = {};

      //! Records the last emitted value for channel BreakpointInUse
      bool m_last_BreakpointInUse = {};

      //! Records the last emitted value for channel BreakpointIndex
      U32 m_last_BreakpointIndex = {};

      //! Records the last emitted value for channel BreakOnlyOnceOnBreakpoint
      bool m_last_BreakOnlyOnceOnBreakpoint = {};

      //! Records the last emitted value for channel BreakBeforeNextLine
      bool m_last_BreakBeforeNextLine = {};

      //! Records the last emitted value for channel PRM_STATEMENT_TIMEOUT_SECS
      F32 m_last_PRM_STATEMENT_TIMEOUT_SECS = {};

      //! Records the last emitted value for channel PRM_FLAG_DEFAULT_EXIT_ON_CMD_FAIL
      bool m_last_PRM_FLAG_DEFAULT_EXIT_ON_CMD_FAIL = {};

    private:

      // ----------------------------------------------------------------------
      // Parameter validity flags
      // ----------------------------------------------------------------------

      //! True if STATEMENT_TIMEOUT_SECS was successfully received
      Fw::ParamValid m_param_STATEMENT_TIMEOUT_SECS_valid;

      //! True if FLAG_DEFAULT_EXIT_ON_CMD_FAIL was successfully received
      Fw::ParamValid m_param_FLAG_DEFAULT_EXIT_ON_CMD_FAIL_valid;

    private:

      // ----------------------------------------------------------------------
      // Parameter variables
      // ----------------------------------------------------------------------

      //! Parameter STATEMENT_TIMEOUT_SECS
      //!
      //! the number of seconds to wait before giving up
      //! on a directive or command. if <= 0 or greater than U32 max, never time out.
      //! accuracy of this timeout is determined by the rate group driving this
      //! component. it will be rounded up
      F32 m_STATEMENT_TIMEOUT_SECS;

      //! Parameter FLAG_DEFAULT_EXIT_ON_CMD_FAIL
      //!
      //! the default value of the EXIT_ON_CMD_FAIL sequence flag
      bool m_FLAG_DEFAULT_EXIT_ON_CMD_FAIL;

    private:

      // ----------------------------------------------------------------------
      // State machine instances
      // ----------------------------------------------------------------------

      //! State machine sequencer
      Svc_FpySequencer_SequencerStateMachine m_stateMachine_sequencer;

    private:

      // ----------------------------------------------------------------------
      // Mutexes
      // ----------------------------------------------------------------------

      //! Mutex for locking parameters during sets and saves
      Os::Mutex m_paramLock;

  };

}

#endif
