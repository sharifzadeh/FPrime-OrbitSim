// ======================================================================
// \title  StatementSerializableAc.cpp
// \author Generated by fpp-to-cpp
// \brief  cpp file for Statement struct
// ======================================================================

#include "Fw/Types/Assert.hpp"
#include "Svc/FpySequencer/StatementSerializableAc.hpp"

namespace Svc {

  namespace Fpy {

    // ----------------------------------------------------------------------
    // Constructors
    // ----------------------------------------------------------------------

    Statement ::
      Statement() :
        Serializable(),
        m_opCode(),
        m_argBuf()
    {

    }

    Statement ::
      Statement(
          Svc::Fpy::DirectiveId::T opCode,
          const Fw::StatementArgBuffer& argBuf
      ) :
        Serializable(),
        m_opCode(opCode),
        m_argBuf(argBuf)
    {

    }

    Statement ::
      Statement(const Statement& obj) :
        Serializable(),
        m_opCode(obj.m_opCode),
        m_argBuf(obj.m_argBuf)
    {

    }

    // ----------------------------------------------------------------------
    // Operators
    // ----------------------------------------------------------------------

    Statement& Statement ::
      operator=(const Statement& obj)
    {
      if (this == &obj) {
        return *this;
      }

      set(obj.m_opCode, obj.m_argBuf);
      return *this;
    }

    bool Statement ::
      operator==(const Statement& obj) const
    {
      if (this == &obj) { return true; }
      return (
        (this->m_opCode == obj.m_opCode) &&
        (this->m_argBuf == obj.m_argBuf)
      );
    }

    bool Statement ::
      operator!=(const Statement& obj) const
    {
      return !(*this == obj);
    }

#ifdef BUILD_UT

    std::ostream& operator<<(std::ostream& os, const Statement& obj) {
      Fw::String s;
      obj.toString(s);
      os << s.toChar();
      return os;
    }

#endif

    // ----------------------------------------------------------------------
    // Member functions
    // ----------------------------------------------------------------------

    Fw::SerializeStatus Statement ::
      serializeTo(
          Fw::SerialBufferBase& buffer,
          Fw::Endianness mode
      ) const
    {
      Fw::SerializeStatus status;

      status = buffer.serializeFrom(this->m_opCode, mode);
      if (status != Fw::FW_SERIALIZE_OK) {
        return status;
      }
      status = buffer.serializeFrom(this->m_argBuf, mode);
      if (status != Fw::FW_SERIALIZE_OK) {
        return status;
      }

      return status;
    }

    Fw::SerializeStatus Statement ::
      deserializeFrom(
          Fw::SerialBufferBase& buffer,
          Fw::Endianness mode
      )
    {
      Fw::SerializeStatus status;

      status = buffer.deserializeTo(this->m_opCode, mode);
      if (status != Fw::FW_SERIALIZE_OK) {
        return status;
      }
      status = buffer.deserializeTo(this->m_argBuf, mode);
      if (status != Fw::FW_SERIALIZE_OK) {
        return status;
      }

      return status;
    }

    FwSizeType Statement ::
      serializedSize() const
    {
      FwSizeType size = 0;
      size += Svc::Fpy::DirectiveId::SERIALIZED_SIZE;
      size += Fw::StatementArgBuffer::SERIALIZED_SIZE;
      return size;
    }

#if FW_SERIALIZABLE_TO_STRING

    void Statement ::
      toString(Fw::StringBase& sb) const
    {
      Fw::String tmp;
      sb = "( ";

      // Format opCode
      sb += "opCode = ";
      this->m_opCode.toString(tmp);
      sb += tmp;
      sb += ", ";

      // Format argBuf
      sb += "argBuf = ";
      this->m_argBuf.toString(tmp);
      sb += tmp;
      sb += " )";
    }

#endif

    // ----------------------------------------------------------------------
    // Setter functions
    // ----------------------------------------------------------------------

    void Statement ::
      set(
          Svc::Fpy::DirectiveId::T opCode,
          const Fw::StatementArgBuffer& argBuf
      )
    {
      this->m_opCode = opCode;
      this->m_argBuf = argBuf;
    }

    void Statement ::
      set_opCode(Svc::Fpy::DirectiveId::T opCode)
    {
      this->m_opCode = opCode;
    }

    void Statement ::
      set_argBuf(const Fw::StatementArgBuffer& argBuf)
    {
      this->m_argBuf = argBuf;
    }

  }

}
