// ======================================================================
// \title  FpySequencer_SequencerStateMachineStateMachineAc.hpp
// \author Generated by fpp-to-cpp
// \brief  hpp file for FpySequencer_SequencerStateMachine state machine
// ======================================================================

#ifndef Svc_FpySequencer_FpySequencer_SequencerStateMachineStateMachineAc_HPP
#define Svc_FpySequencer_FpySequencer_SequencerStateMachineStateMachineAc_HPP

#include "Fw/FPrimeBasicTypes.hpp"
#include "Fw/Types/ExternalString.hpp"
#include "Fw/Types/Serializable.hpp"
#include "Fw/Types/String.hpp"
#include "Svc/FpySequencer/FpySequencer_BreakpointArgsSerializableAc.hpp"
#include "Svc/FpySequencer/FpySequencer_SequenceExecutionArgsSerializableAc.hpp"

namespace Svc {

  class FpySequencer_SequencerStateMachineStateMachineBase {

      // ----------------------------------------------------------------------
      // Friend classes
      // ----------------------------------------------------------------------

      //! Tester class for the state machine
      friend class FpySequencer_SequencerStateMachineTester;

    public:

      // ----------------------------------------------------------------------
      // Types
      // ----------------------------------------------------------------------

      //! The state type
      enum class State : FwEnumStoreType {
        //! The uninitialized state
        __FPRIME_AC_UNINITIALIZED,
        //! sequencer has validated the sequence and is waiting for a command to run it
        AWAITING_CMD_RUN_VALIDATED,
        //! sequencer is ready to load, validate and run a sequence
        IDLE,
        RUNNING_AWAITING_STATEMENT_RESPONSE,
        //! sequencer is stepping into a single statement and dispatching it
        RUNNING_DISPATCH_STATEMENT,
        //! a breakpoint was hit or the sequence was broken via command.
        //! sequencer is not taking any action, or allowing timeouts.
        //! must be exited via command, either CANCEL or CONTINUE
        RUNNING_PAUSED,
        //! sequencer is not taking any action, waiting for a time in the future to continue
        RUNNING_SLEEPING,
        VALIDATING,
      };

      //! The signal type
      enum class Signal : FwEnumStoreType {
        //! The initial transition
        __FPRIME_AC_INITIAL_TRANSITION,
        //! raised whenever the checkTimers port is called
        checkTimersIn,
        //! called in BREAK cmd. only raised in RUNNING state
        cmd_BREAK,
        //! called on CANCEL cmd. raised in all states except IDLE
        cmd_CANCEL,
        //! called in CLEAR_BREAKPOINT cmd. raised in any state
        cmd_CLEAR_BREAKPOINT,
        //! called in CONTINUE cmd. only raised in RUNNING.PAUSED state
        cmd_CONTINUE,
        //! called on RUN cmd with the path of the sequence file to run. only raised in IDLE state
        cmd_RUN,
        //! called on RUN_VALIDATED cmd. only raised in AWAITING_CMD_RUN_VALIDATED state
        cmd_RUN_VALIDATED,
        //! called in SET_BREAKPOINT cmd. raised in any state
        cmd_SET_BREAKPOINT,
        //! called in STEP cmd. only raised in RUNNING.PAUSED state
        cmd_STEP,
        //! called on VALIDATE cmd with the path of the sequence file to validate. only raised in IDLE state
        cmd_VALIDATE,
        //! generic entry of a state
        entered,
        //! raised when we should keep sleeping
        result_checkShouldWake_keepSleeping,
        //! raised when we are done sleeping
        result_checkShouldWake_wakeup,
        //! raised when the statement has not timed out yet
        result_checkStatementTimeout_noTimeout,
        //! raised when the statement times out, according to the timeout parameter
        result_checkStatementTimeout_statementTimeout,
        //! called in dispatchStatement method when a statement was unable to be sent out
        result_dispatchStatement_failure,
        //! called in dispatchStatement method when there were no more statements in the sequence
        result_dispatchStatement_noMoreStatements,
        //! called in dispatchStatement method when a statement was successfully dispatched
        result_dispatchStatement_success,
        //! generic failure of an action
        result_failure,
        //! generic success of an action
        result_success,
        //! raised when an operation could not be performed on a Fw::Time object due to a
        //! mismatched time base or context
        result_timeOpFailed,
        //! a statement is telling the sequencer to go to sleep
        stmtResponse_beginSleep,
        //! called when the statement unsuccessfully executed. only raised in the RUNNING.AWAITING_CMD_RESPONSE state
        stmtResponse_failure,
        //! called when the statement is telling the sequencer to await a later stmt response
        stmtResponse_keepWaiting,
        //! called when statement successfully executed. only raised in the RUNNING.AWAITING_CMD_RESPONSE state
        stmtResponse_success,
        //! called when an unexpected or incorrect statement response comes in. only raised in the RUNNING state
        stmtResponse_unexpected,
      };

    protected:

      // ----------------------------------------------------------------------
      // Constructors and Destructors
      // ----------------------------------------------------------------------

      //! Constructor
      FpySequencer_SequencerStateMachineStateMachineBase();

      //! Destructor
      virtual ~FpySequencer_SequencerStateMachineStateMachineBase();

    protected:

      // ----------------------------------------------------------------------
      // Initialization
      // ----------------------------------------------------------------------

      //! Initialize the state machine
      void initBase(
          const FwEnumStoreType id //!< The state machine ID
      );

    public:

      // ----------------------------------------------------------------------
      // Getter functions
      // ----------------------------------------------------------------------

      //! Get the state
      FpySequencer_SequencerStateMachineStateMachineBase::State getState() const;

    public:

      // ----------------------------------------------------------------------
      // Send signal functions
      // ----------------------------------------------------------------------

      //! called on VALIDATE cmd with the path of the sequence file to validate. only raised in IDLE state
      void sendSignal_cmd_VALIDATE(
          const Svc::FpySequencer_SequenceExecutionArgs& value //!< The value
      );

      //! called on RUN cmd with the path of the sequence file to run. only raised in IDLE state
      void sendSignal_cmd_RUN(
          const Svc::FpySequencer_SequenceExecutionArgs& value //!< The value
      );

      //! called on RUN_VALIDATED cmd. only raised in AWAITING_CMD_RUN_VALIDATED state
      void sendSignal_cmd_RUN_VALIDATED(
          const Svc::FpySequencer_SequenceExecutionArgs& value //!< The value
      );

      //! called on CANCEL cmd. raised in all states except IDLE
      void sendSignal_cmd_CANCEL();

      //! called in SET_BREAKPOINT cmd. raised in any state
      void sendSignal_cmd_SET_BREAKPOINT(
          const Svc::FpySequencer_BreakpointArgs& value //!< The value
      );

      //! called in CLEAR_BREAKPOINT cmd. raised in any state
      void sendSignal_cmd_CLEAR_BREAKPOINT();

      //! generic failure of an action
      void sendSignal_result_failure();

      //! generic success of an action
      void sendSignal_result_success();

      //! generic entry of a state
      void sendSignal_entered();

      //! called in dispatchStatement method when a statement was successfully dispatched
      void sendSignal_result_dispatchStatement_success();

      //! called in dispatchStatement method when a statement was unable to be sent out
      void sendSignal_result_dispatchStatement_failure();

      //! called in dispatchStatement method when there were no more statements in the sequence
      void sendSignal_result_dispatchStatement_noMoreStatements();

      //! raised whenever the checkTimers port is called
      void sendSignal_checkTimersIn();

      //! raised when we are done sleeping
      void sendSignal_result_checkShouldWake_wakeup();

      //! raised when we should keep sleeping
      void sendSignal_result_checkShouldWake_keepSleeping();

      //! raised when an operation could not be performed on a Fw::Time object due to a
      //! mismatched time base or context
      void sendSignal_result_timeOpFailed();

      //! a statement is telling the sequencer to go to sleep
      void sendSignal_stmtResponse_beginSleep();

      //! called when statement successfully executed. only raised in the RUNNING.AWAITING_CMD_RESPONSE state
      void sendSignal_stmtResponse_success();

      //! called when the statement unsuccessfully executed. only raised in the RUNNING.AWAITING_CMD_RESPONSE state
      void sendSignal_stmtResponse_failure();

      //! called when an unexpected or incorrect statement response comes in. only raised in the RUNNING state
      void sendSignal_stmtResponse_unexpected();

      //! called when the statement is telling the sequencer to await a later stmt response
      void sendSignal_stmtResponse_keepWaiting();

      //! raised when the statement times out, according to the timeout parameter
      void sendSignal_result_checkStatementTimeout_statementTimeout();

      //! raised when the statement has not timed out yet
      void sendSignal_result_checkStatementTimeout_noTimeout();

      //! called in CONTINUE cmd. only raised in RUNNING.PAUSED state
      void sendSignal_cmd_CONTINUE();

      //! called in BREAK cmd. only raised in RUNNING state
      void sendSignal_cmd_BREAK();

      //! called in STEP cmd. only raised in RUNNING.PAUSED state
      void sendSignal_cmd_STEP();

    protected:

      // ----------------------------------------------------------------------
      // Actions
      // ----------------------------------------------------------------------

      //! simply raises the "entered" signal
      virtual void action_signalEntered(
          Signal signal //!< The signal
      ) = 0;

      //! sets the current sequence file path member var
      virtual void action_setSequenceFilePath(
          Signal signal, //!< The signal
          const Svc::FpySequencer_SequenceExecutionArgs& value //!< The value
      ) = 0;

      //! sets the block state of the sequence to be run
      virtual void action_setSequenceBlockState(
          Signal signal, //!< The signal
          const Svc::FpySequencer_SequenceExecutionArgs& value //!< The value
      ) = 0;

      //! performs all steps necessary for sequence validation, and raises a signal result_success or result_failure
      virtual void action_validate(
          Signal signal //!< The signal
      ) = 0;

      //! reports that a sequence succeeded
      virtual void action_report_seqSucceeded(
          Signal signal //!< The signal
      ) = 0;

      //! reports that a sequence was cancelled
      virtual void action_report_seqCancelled(
          Signal signal //!< The signal
      ) = 0;

      //! called when a sequence failed to execute successfully
      virtual void action_report_seqFailed(
          Signal signal //!< The signal
      ) = 0;

      //! called when a sequence starts
      virtual void action_report_seqStarted(
          Signal signal //!< The signal
      ) = 0;

      //! sets the goal state to RUNNING
      virtual void action_setGoalState_RUNNING(
          Signal signal //!< The signal
      ) = 0;

      //! sets the goal state to VALID
      virtual void action_setGoalState_VALID(
          Signal signal //!< The signal
      ) = 0;

      //! sets the goal state to IDLE
      virtual void action_setGoalState_IDLE(
          Signal signal //!< The signal
      ) = 0;

      //! responds to the calling command with OK
      virtual void action_sendCmdResponse_OK(
          Signal signal //!< The signal
      ) = 0;

      //! responds to the calling command with EXECUTION_ERROR
      virtual void action_sendCmdResponse_EXECUTION_ERROR(
          Signal signal //!< The signal
      ) = 0;

      //! clears all variables related to the loading/validating of the sequence file
      virtual void action_clearSequenceFile(
          Signal signal //!< The signal
      ) = 0;

      //! clears the breakpoint setting
      virtual void action_clearBreakpoint(
          Signal signal //!< The signal
      ) = 0;

      //! checks if sequencer should wake from sleep
      virtual void action_checkShouldWake(
          Signal signal //!< The signal
      ) = 0;

      //! iterates to the next statement and dispatches it
      virtual void action_dispatchStatement(
          Signal signal //!< The signal
      ) = 0;

      //! resets the sequence runtime
      virtual void action_resetRuntime(
          Signal signal //!< The signal
      ) = 0;

      //! checks if the current statement has timed out
      virtual void action_checkStatementTimeout(
          Signal signal //!< The signal
      ) = 0;

      //! increments the m_sequencesStarted counter
      virtual void action_incrementSequenceCounter(
          Signal signal //!< The signal
      ) = 0;

      //! reports that a breakpoint was hit
      virtual void action_report_seqBroken(
          Signal signal //!< The signal
      ) = 0;

      //! sets the breakpoint to the provided args
      virtual void action_setBreakpoint(
          Signal signal, //!< The signal
          const Svc::FpySequencer_BreakpointArgs& value //!< The value
      ) = 0;

      //! sets the "break on next line" flag to true
      virtual void action_setBreakBeforeNextLine(
          Signal signal //!< The signal
      ) = 0;

      //! sets the "break on next line" flag to false
      virtual void action_clearBreakBeforeNextLine(
          Signal signal //!< The signal
      ) = 0;

    protected:

      // ----------------------------------------------------------------------
      // Guards
      // ----------------------------------------------------------------------

      //! return true if the goal state is RUNNING
      virtual bool guard_goalStateIs_RUNNING(
          Signal signal //!< The signal
      ) const = 0;

      //! return true if should break at this point in execution, before dispatching
      //! next stmt
      virtual bool guard_shouldBreak(
          Signal signal //!< The signal
      ) const = 0;

      //! return true if this breakpoint should only happen once
      virtual bool guard_breakOnce(
          Signal signal //!< The signal
      ) const = 0;

    private:

      // ----------------------------------------------------------------------
      // State and choice entry
      // ----------------------------------------------------------------------

      //! Enter state RUNNING
      void enter_RUNNING(
          Signal signal //!< The signal
      );

      //! Enter choice RUNNING_BREAK_CHECK
      void enter_RUNNING_BREAK_CHECK(
          Signal signal //!< The signal
      );

      //! Enter state RUNNING_DISPATCH_STATEMENT
      void enter_RUNNING_DISPATCH_STATEMENT(
          Signal signal //!< The signal
      );

      //! Enter state RUNNING_AWAITING_STATEMENT_RESPONSE
      void enter_RUNNING_AWAITING_STATEMENT_RESPONSE(
          Signal signal //!< The signal
      );

      //! Enter state RUNNING_SLEEPING
      void enter_RUNNING_SLEEPING(
          Signal signal //!< The signal
      );

      //! Enter state RUNNING_PAUSED
      void enter_RUNNING_PAUSED(
          Signal signal //!< The signal
      );

      //! Enter state AWAITING_CMD_RUN_VALIDATED
      void enter_AWAITING_CMD_RUN_VALIDATED(
          Signal signal //!< The signal
      );

      //! Enter choice VALID
      void enter_VALID(
          Signal signal //!< The signal
      );

      //! Enter state VALIDATING
      void enter_VALIDATING(
          Signal signal //!< The signal
      );

      //! Enter state IDLE
      void enter_IDLE(
          Signal signal //!< The signal
      );

    protected:

      // ----------------------------------------------------------------------
      // Member variables
      // ----------------------------------------------------------------------

      //! The state machine ID
      FwEnumStoreType m_id = 0;

      //! The state
      State m_state = State::__FPRIME_AC_UNINITIALIZED;

  };

}

#endif
