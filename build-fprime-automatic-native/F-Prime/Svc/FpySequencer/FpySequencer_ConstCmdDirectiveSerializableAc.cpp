// ======================================================================
// \title  FpySequencer_ConstCmdDirectiveSerializableAc.cpp
// \author Generated by fpp-to-cpp
// \brief  cpp file for FpySequencer_ConstCmdDirective struct
// ======================================================================

#include "Fw/Types/Assert.hpp"
#include "Svc/FpySequencer/FpySequencer_ConstCmdDirectiveSerializableAc.hpp"

namespace Svc {

  // ----------------------------------------------------------------------
  // Constructors
  // ----------------------------------------------------------------------

  FpySequencer_ConstCmdDirective ::
    FpySequencer_ConstCmdDirective() :
      Serializable(),
      m_opCode(),
      m_argBuf(),
      m__argBufSize()
  {

  }

  FpySequencer_ConstCmdDirective ::
    FpySequencer_ConstCmdDirective(
        FwOpcodeType opCode,
        const Type_of_argBuf& argBuf,
        FwSizeType _argBufSize
    ) :
      Serializable(),
      m_opCode(opCode),
      m__argBufSize(_argBufSize)
  {
    for (FwSizeType i = 0; i < 2048; i++) {
      this->m_argBuf[i] = argBuf[i];
    }
  }

  FpySequencer_ConstCmdDirective ::
    FpySequencer_ConstCmdDirective(const FpySequencer_ConstCmdDirective& obj) :
      Serializable(),
      m_opCode(obj.m_opCode),
      m__argBufSize(obj.m__argBufSize)
  {
    for (FwSizeType i = 0; i < 2048; i++) {
      this->m_argBuf[i] = obj.m_argBuf[i];
    }
  }

  FpySequencer_ConstCmdDirective ::
    FpySequencer_ConstCmdDirective(
        FwOpcodeType opCode,
        U8 argBuf,
        FwSizeType _argBufSize
    ) :
      Serializable(),
      m_opCode(opCode),
      m__argBufSize(_argBufSize)
  {
    for (FwSizeType i = 0; i < 2048; i++) {
      this->m_argBuf[i] = argBuf;
    }
  }

  // ----------------------------------------------------------------------
  // Operators
  // ----------------------------------------------------------------------

  FpySequencer_ConstCmdDirective& FpySequencer_ConstCmdDirective ::
    operator=(const FpySequencer_ConstCmdDirective& obj)
  {
    if (this == &obj) {
      return *this;
    }

    set(obj.m_opCode, obj.m_argBuf, obj.m__argBufSize);
    return *this;
  }

  bool FpySequencer_ConstCmdDirective ::
    operator==(const FpySequencer_ConstCmdDirective& obj) const
  {
    if (this == &obj) { return true; }

    // Compare non-array members
    if (!(
      (this->m_opCode == obj.m_opCode) &&
      (this->m__argBufSize == obj.m__argBufSize)
    )) {
      return false;
    }

    // Compare array members
    for (FwSizeType i = 0; i < 2048; i++) {
      if (!(this->m_argBuf[i] == obj.m_argBuf[i])) {
        return false;
      }
    }

    return true;
  }

  bool FpySequencer_ConstCmdDirective ::
    operator!=(const FpySequencer_ConstCmdDirective& obj) const
  {
    return !(*this == obj);
  }

#ifdef BUILD_UT

  std::ostream& operator<<(std::ostream& os, const FpySequencer_ConstCmdDirective& obj) {
    Fw::String s;
    obj.toString(s);
    os << s.toChar();
    return os;
  }

#endif

  // ----------------------------------------------------------------------
  // Member functions
  // ----------------------------------------------------------------------

  Fw::SerializeStatus FpySequencer_ConstCmdDirective ::
    serializeTo(
        Fw::SerialBufferBase& buffer,
        Fw::Endianness mode
    ) const
  {
    Fw::SerializeStatus status;

    status = buffer.serializeFrom(this->m_opCode, mode);
    if (status != Fw::FW_SERIALIZE_OK) {
      return status;
    }
    for (FwSizeType i = 0; i < 2048; i++) {
      status = buffer.serializeFrom(this->m_argBuf[i], mode);
      if (status != Fw::FW_SERIALIZE_OK) {
        return status;
      }
    }
    status = buffer.serializeFrom(this->m__argBufSize, mode);
    if (status != Fw::FW_SERIALIZE_OK) {
      return status;
    }

    return status;
  }

  Fw::SerializeStatus FpySequencer_ConstCmdDirective ::
    deserializeFrom(
        Fw::SerialBufferBase& buffer,
        Fw::Endianness mode
    )
  {
    Fw::SerializeStatus status;

    status = buffer.deserializeTo(this->m_opCode, mode);
    if (status != Fw::FW_SERIALIZE_OK) {
      return status;
    }
    for (FwSizeType i = 0; i < 2048; i++) {
      status = buffer.deserializeTo(this->m_argBuf[i], mode);
      if (status != Fw::FW_SERIALIZE_OK) {
        return status;
      }
    }
    status = buffer.deserializeTo(this->m__argBufSize, mode);
    if (status != Fw::FW_SERIALIZE_OK) {
      return status;
    }

    return status;
  }

  FwSizeType FpySequencer_ConstCmdDirective ::
    serializedSize() const
  {
    FwSizeType size = 0;
    size += sizeof(FwOpcodeType);
    size += sizeof(U8) * 2048;
    size += sizeof(FwSizeType);
    return size;
  }

#if FW_SERIALIZABLE_TO_STRING

  void FpySequencer_ConstCmdDirective ::
    toString(Fw::StringBase& sb) const
  {
    Fw::String tmp;
    sb = "( ";

    // Format opCode
    sb += "opCode = ";
    tmp.format("%" PRIu32 "", this->m_opCode);
    sb += tmp;
    sb += ", ";

    // Format argBuf
    sb += "argBuf = ";
    sb += "[ ";
    for (FwSizeType i = 0; i < 2048; i++) {
      tmp.format("%" PRIu8 "", this->m_argBuf[i]);
      if (i > 0) {
        sb += ", ";
      }
      sb += tmp;
    }
    sb += " ]";
    sb += ", ";

    // Format _argBufSize
    sb += "_argBufSize = ";
    tmp.format("%" PRIu64 "", this->m__argBufSize);
    sb += tmp;
    sb += " )";
  }

#endif

  // ----------------------------------------------------------------------
  // Setter functions
  // ----------------------------------------------------------------------

  void FpySequencer_ConstCmdDirective ::
    set(
        FwOpcodeType opCode,
        const Type_of_argBuf& argBuf,
        FwSizeType _argBufSize
    )
  {
    this->m_opCode = opCode;
    this->m__argBufSize = _argBufSize;

    for (FwSizeType i = 0; i < 2048; i++) {
      this->m_argBuf[i] = argBuf[i];
    }
  }

  void FpySequencer_ConstCmdDirective ::
    set_opCode(FwOpcodeType opCode)
  {
    this->m_opCode = opCode;
  }

  void FpySequencer_ConstCmdDirective ::
    set_argBuf(const Type_of_argBuf& argBuf)
  {
    for (FwSizeType i = 0; i < 2048; i++) {
      this->m_argBuf[i] = argBuf[i];
    }
  }

  void FpySequencer_ConstCmdDirective ::
    set__argBufSize(FwSizeType _argBufSize)
  {
    this->m__argBufSize = _argBufSize;
  }

}
