// ======================================================================
// \title  FpySequencer_SequencerStateMachineStateMachineAc.cpp
// \author Generated by fpp-to-cpp
// \brief  cpp file for FpySequencer_SequencerStateMachine state machine
// ======================================================================

#include "Fw/Types/Assert.hpp"
#include "Svc/FpySequencer/FpySequencer_SequencerStateMachineStateMachineAc.hpp"

namespace Svc {

  // ----------------------------------------------------------------------
  // Constructors and Destructors
  // ----------------------------------------------------------------------

  FpySequencer_SequencerStateMachineStateMachineBase ::
    FpySequencer_SequencerStateMachineStateMachineBase()
  {

  }

  FpySequencer_SequencerStateMachineStateMachineBase ::
    ~FpySequencer_SequencerStateMachineStateMachineBase()
  {

  }

  // ----------------------------------------------------------------------
  // Initialization
  // ----------------------------------------------------------------------

  void FpySequencer_SequencerStateMachineStateMachineBase ::
    initBase(const FwEnumStoreType id)
  {
    this->m_id = id;
    // Enter the initial target of the state machine
    this->enter_IDLE(Signal::__FPRIME_AC_INITIAL_TRANSITION);
  }

  // ----------------------------------------------------------------------
  // Getter functions
  // ----------------------------------------------------------------------

  FpySequencer_SequencerStateMachineStateMachineBase::State FpySequencer_SequencerStateMachineStateMachineBase ::
    getState() const
  {
    return this->m_state;
  }

  // ----------------------------------------------------------------------
  // Send signal functions
  // ----------------------------------------------------------------------

  void FpySequencer_SequencerStateMachineStateMachineBase ::
    sendSignal_cmd_VALIDATE(const Svc::FpySequencer_SequenceExecutionArgs& value)
  {
    switch (this->m_state) {
      case State::AWAITING_CMD_RUN_VALIDATED:
        break;
      case State::IDLE:
        // Do the actions for the transition
        this->action_setGoalState_VALID(Signal::cmd_VALIDATE);
        this->action_setSequenceFilePath(Signal::cmd_VALIDATE, value);
        // Enter the target
        this->enter_VALIDATING(Signal::cmd_VALIDATE);
        break;
      case State::RUNNING_AWAITING_STATEMENT_RESPONSE:
        break;
      case State::RUNNING_DISPATCH_STATEMENT:
        break;
      case State::RUNNING_PAUSED:
        break;
      case State::RUNNING_SLEEPING:
        break;
      case State::VALIDATING:
        break;
      default:
        FW_ASSERT(0, static_cast<FwAssertArgType>(this->m_state));
        break;
    }
  }

  void FpySequencer_SequencerStateMachineStateMachineBase ::
    sendSignal_cmd_RUN(const Svc::FpySequencer_SequenceExecutionArgs& value)
  {
    switch (this->m_state) {
      case State::AWAITING_CMD_RUN_VALIDATED:
        break;
      case State::IDLE:
        // Do the actions for the transition
        this->action_setGoalState_RUNNING(Signal::cmd_RUN);
        this->action_setSequenceFilePath(Signal::cmd_RUN, value);
        this->action_setSequenceBlockState(Signal::cmd_RUN, value);
        // Enter the target
        this->enter_VALIDATING(Signal::cmd_RUN);
        break;
      case State::RUNNING_AWAITING_STATEMENT_RESPONSE:
        break;
      case State::RUNNING_DISPATCH_STATEMENT:
        break;
      case State::RUNNING_PAUSED:
        break;
      case State::RUNNING_SLEEPING:
        break;
      case State::VALIDATING:
        break;
      default:
        FW_ASSERT(0, static_cast<FwAssertArgType>(this->m_state));
        break;
    }
  }

  void FpySequencer_SequencerStateMachineStateMachineBase ::
    sendSignal_cmd_RUN_VALIDATED(const Svc::FpySequencer_SequenceExecutionArgs& value)
  {
    switch (this->m_state) {
      case State::AWAITING_CMD_RUN_VALIDATED:
        // Do the actions for the transition
        this->action_setSequenceBlockState(Signal::cmd_RUN_VALIDATED, value);
        // Enter the target
        this->enter_RUNNING(Signal::cmd_RUN_VALIDATED);
        break;
      case State::IDLE:
        break;
      case State::RUNNING_AWAITING_STATEMENT_RESPONSE:
        break;
      case State::RUNNING_DISPATCH_STATEMENT:
        break;
      case State::RUNNING_PAUSED:
        break;
      case State::RUNNING_SLEEPING:
        break;
      case State::VALIDATING:
        break;
      default:
        FW_ASSERT(0, static_cast<FwAssertArgType>(this->m_state));
        break;
    }
  }

  void FpySequencer_SequencerStateMachineStateMachineBase ::
    sendSignal_cmd_CANCEL()
  {
    switch (this->m_state) {
      case State::AWAITING_CMD_RUN_VALIDATED:
        // Do the actions for the transition
        this->action_report_seqCancelled(Signal::cmd_CANCEL);
        // Enter the target
        this->enter_IDLE(Signal::cmd_CANCEL);
        break;
      case State::IDLE:
        break;
      case State::RUNNING_AWAITING_STATEMENT_RESPONSE:
        // Do the actions for the transition
        this->action_report_seqCancelled(Signal::cmd_CANCEL);
        this->action_sendCmdResponse_EXECUTION_ERROR(Signal::cmd_CANCEL);
        // Enter the target
        this->enter_IDLE(Signal::cmd_CANCEL);
        break;
      case State::RUNNING_DISPATCH_STATEMENT:
        // Do the actions for the transition
        this->action_report_seqCancelled(Signal::cmd_CANCEL);
        this->action_sendCmdResponse_EXECUTION_ERROR(Signal::cmd_CANCEL);
        // Enter the target
        this->enter_IDLE(Signal::cmd_CANCEL);
        break;
      case State::RUNNING_PAUSED:
        // Do the actions for the transition
        this->action_report_seqCancelled(Signal::cmd_CANCEL);
        this->action_sendCmdResponse_EXECUTION_ERROR(Signal::cmd_CANCEL);
        // Enter the target
        this->enter_IDLE(Signal::cmd_CANCEL);
        break;
      case State::RUNNING_SLEEPING:
        // Do the actions for the transition
        this->action_report_seqCancelled(Signal::cmd_CANCEL);
        this->action_sendCmdResponse_EXECUTION_ERROR(Signal::cmd_CANCEL);
        // Enter the target
        this->enter_IDLE(Signal::cmd_CANCEL);
        break;
      case State::VALIDATING:
        // Do the actions for the transition
        this->action_report_seqCancelled(Signal::cmd_CANCEL);
        this->action_sendCmdResponse_EXECUTION_ERROR(Signal::cmd_CANCEL);
        // Enter the target
        this->enter_IDLE(Signal::cmd_CANCEL);
        break;
      default:
        FW_ASSERT(0, static_cast<FwAssertArgType>(this->m_state));
        break;
    }
  }

  void FpySequencer_SequencerStateMachineStateMachineBase ::
    sendSignal_cmd_SET_BREAKPOINT(const Svc::FpySequencer_BreakpointArgs& value)
  {
    switch (this->m_state) {
      case State::AWAITING_CMD_RUN_VALIDATED:
        // Do the actions for the transition
        this->action_setBreakpoint(Signal::cmd_SET_BREAKPOINT, value);
        break;
      case State::IDLE:
        // Do the actions for the transition
        this->action_setBreakpoint(Signal::cmd_SET_BREAKPOINT, value);
        break;
      case State::RUNNING_AWAITING_STATEMENT_RESPONSE:
        // Do the actions for the transition
        this->action_setBreakpoint(Signal::cmd_SET_BREAKPOINT, value);
        break;
      case State::RUNNING_DISPATCH_STATEMENT:
        // Do the actions for the transition
        this->action_setBreakpoint(Signal::cmd_SET_BREAKPOINT, value);
        break;
      case State::RUNNING_PAUSED:
        // Do the actions for the transition
        this->action_setBreakpoint(Signal::cmd_SET_BREAKPOINT, value);
        break;
      case State::RUNNING_SLEEPING:
        // Do the actions for the transition
        this->action_setBreakpoint(Signal::cmd_SET_BREAKPOINT, value);
        break;
      case State::VALIDATING:
        // Do the actions for the transition
        this->action_setBreakpoint(Signal::cmd_SET_BREAKPOINT, value);
        break;
      default:
        FW_ASSERT(0, static_cast<FwAssertArgType>(this->m_state));
        break;
    }
  }

  void FpySequencer_SequencerStateMachineStateMachineBase ::
    sendSignal_cmd_CLEAR_BREAKPOINT()
  {
    switch (this->m_state) {
      case State::AWAITING_CMD_RUN_VALIDATED:
        // Do the actions for the transition
        this->action_clearBreakpoint(Signal::cmd_CLEAR_BREAKPOINT);
        break;
      case State::IDLE:
        // Do the actions for the transition
        this->action_clearBreakpoint(Signal::cmd_CLEAR_BREAKPOINT);
        break;
      case State::RUNNING_AWAITING_STATEMENT_RESPONSE:
        // Do the actions for the transition
        this->action_clearBreakpoint(Signal::cmd_CLEAR_BREAKPOINT);
        break;
      case State::RUNNING_DISPATCH_STATEMENT:
        // Do the actions for the transition
        this->action_clearBreakpoint(Signal::cmd_CLEAR_BREAKPOINT);
        break;
      case State::RUNNING_PAUSED:
        // Do the actions for the transition
        this->action_clearBreakpoint(Signal::cmd_CLEAR_BREAKPOINT);
        break;
      case State::RUNNING_SLEEPING:
        // Do the actions for the transition
        this->action_clearBreakpoint(Signal::cmd_CLEAR_BREAKPOINT);
        break;
      case State::VALIDATING:
        // Do the actions for the transition
        this->action_clearBreakpoint(Signal::cmd_CLEAR_BREAKPOINT);
        break;
      default:
        FW_ASSERT(0, static_cast<FwAssertArgType>(this->m_state));
        break;
    }
  }

  void FpySequencer_SequencerStateMachineStateMachineBase ::
    sendSignal_result_failure()
  {
    switch (this->m_state) {
      case State::AWAITING_CMD_RUN_VALIDATED:
        break;
      case State::IDLE:
        break;
      case State::RUNNING_AWAITING_STATEMENT_RESPONSE:
        break;
      case State::RUNNING_DISPATCH_STATEMENT:
        break;
      case State::RUNNING_PAUSED:
        break;
      case State::RUNNING_SLEEPING:
        break;
      case State::VALIDATING:
        // Do the actions for the transition
        this->action_report_seqFailed(Signal::result_failure);
        this->action_sendCmdResponse_EXECUTION_ERROR(Signal::result_failure);
        // Enter the target
        this->enter_IDLE(Signal::result_failure);
        break;
      default:
        FW_ASSERT(0, static_cast<FwAssertArgType>(this->m_state));
        break;
    }
  }

  void FpySequencer_SequencerStateMachineStateMachineBase ::
    sendSignal_result_success()
  {
    switch (this->m_state) {
      case State::AWAITING_CMD_RUN_VALIDATED:
        break;
      case State::IDLE:
        break;
      case State::RUNNING_AWAITING_STATEMENT_RESPONSE:
        break;
      case State::RUNNING_DISPATCH_STATEMENT:
        break;
      case State::RUNNING_PAUSED:
        break;
      case State::RUNNING_SLEEPING:
        break;
      case State::VALIDATING:
        // Enter the target
        this->enter_VALID(Signal::result_success);
        break;
      default:
        FW_ASSERT(0, static_cast<FwAssertArgType>(this->m_state));
        break;
    }
  }

  void FpySequencer_SequencerStateMachineStateMachineBase ::
    sendSignal_entered()
  {
    switch (this->m_state) {
      case State::AWAITING_CMD_RUN_VALIDATED:
        break;
      case State::IDLE:
        break;
      case State::RUNNING_AWAITING_STATEMENT_RESPONSE:
        break;
      case State::RUNNING_DISPATCH_STATEMENT:
        break;
      case State::RUNNING_PAUSED:
        if (this->guard_breakOnce(Signal::entered)) {
          // Do the actions for the transition
          this->action_clearBreakpoint(Signal::entered);
        }
        break;
      case State::RUNNING_SLEEPING:
        break;
      case State::VALIDATING:
        // Do the actions for the transition
        this->action_validate(Signal::entered);
        break;
      default:
        FW_ASSERT(0, static_cast<FwAssertArgType>(this->m_state));
        break;
    }
  }

  void FpySequencer_SequencerStateMachineStateMachineBase ::
    sendSignal_result_dispatchStatement_success()
  {
    switch (this->m_state) {
      case State::AWAITING_CMD_RUN_VALIDATED:
        break;
      case State::IDLE:
        break;
      case State::RUNNING_AWAITING_STATEMENT_RESPONSE:
        break;
      case State::RUNNING_DISPATCH_STATEMENT:
        // Enter the target
        this->enter_RUNNING_AWAITING_STATEMENT_RESPONSE(Signal::result_dispatchStatement_success);
        break;
      case State::RUNNING_PAUSED:
        break;
      case State::RUNNING_SLEEPING:
        break;
      case State::VALIDATING:
        break;
      default:
        FW_ASSERT(0, static_cast<FwAssertArgType>(this->m_state));
        break;
    }
  }

  void FpySequencer_SequencerStateMachineStateMachineBase ::
    sendSignal_result_dispatchStatement_failure()
  {
    switch (this->m_state) {
      case State::AWAITING_CMD_RUN_VALIDATED:
        break;
      case State::IDLE:
        break;
      case State::RUNNING_AWAITING_STATEMENT_RESPONSE:
        break;
      case State::RUNNING_DISPATCH_STATEMENT:
        // Do the actions for the transition
        this->action_report_seqFailed(Signal::result_dispatchStatement_failure);
        this->action_sendCmdResponse_EXECUTION_ERROR(Signal::result_dispatchStatement_failure);
        // Enter the target
        this->enter_IDLE(Signal::result_dispatchStatement_failure);
        break;
      case State::RUNNING_PAUSED:
        break;
      case State::RUNNING_SLEEPING:
        break;
      case State::VALIDATING:
        break;
      default:
        FW_ASSERT(0, static_cast<FwAssertArgType>(this->m_state));
        break;
    }
  }

  void FpySequencer_SequencerStateMachineStateMachineBase ::
    sendSignal_result_dispatchStatement_noMoreStatements()
  {
    switch (this->m_state) {
      case State::AWAITING_CMD_RUN_VALIDATED:
        break;
      case State::IDLE:
        break;
      case State::RUNNING_AWAITING_STATEMENT_RESPONSE:
        break;
      case State::RUNNING_DISPATCH_STATEMENT:
        // Do the actions for the transition
        this->action_report_seqSucceeded(Signal::result_dispatchStatement_noMoreStatements);
        this->action_sendCmdResponse_OK(Signal::result_dispatchStatement_noMoreStatements);
        // Enter the target
        this->enter_IDLE(Signal::result_dispatchStatement_noMoreStatements);
        break;
      case State::RUNNING_PAUSED:
        break;
      case State::RUNNING_SLEEPING:
        break;
      case State::VALIDATING:
        break;
      default:
        FW_ASSERT(0, static_cast<FwAssertArgType>(this->m_state));
        break;
    }
  }

  void FpySequencer_SequencerStateMachineStateMachineBase ::
    sendSignal_checkTimersIn()
  {
    switch (this->m_state) {
      case State::AWAITING_CMD_RUN_VALIDATED:
        break;
      case State::IDLE:
        break;
      case State::RUNNING_AWAITING_STATEMENT_RESPONSE:
        // Do the actions for the transition
        this->action_checkStatementTimeout(Signal::checkTimersIn);
        break;
      case State::RUNNING_DISPATCH_STATEMENT:
        break;
      case State::RUNNING_PAUSED:
        break;
      case State::RUNNING_SLEEPING:
        // Do the actions for the transition
        this->action_checkShouldWake(Signal::checkTimersIn);
        this->action_checkStatementTimeout(Signal::checkTimersIn);
        break;
      case State::VALIDATING:
        break;
      default:
        FW_ASSERT(0, static_cast<FwAssertArgType>(this->m_state));
        break;
    }
  }

  void FpySequencer_SequencerStateMachineStateMachineBase ::
    sendSignal_result_checkShouldWake_wakeup()
  {
    switch (this->m_state) {
      case State::AWAITING_CMD_RUN_VALIDATED:
        break;
      case State::IDLE:
        break;
      case State::RUNNING_AWAITING_STATEMENT_RESPONSE:
        break;
      case State::RUNNING_DISPATCH_STATEMENT:
        break;
      case State::RUNNING_PAUSED:
        break;
      case State::RUNNING_SLEEPING:
        // Enter the target
        this->enter_RUNNING_BREAK_CHECK(Signal::result_checkShouldWake_wakeup);
        break;
      case State::VALIDATING:
        break;
      default:
        FW_ASSERT(0, static_cast<FwAssertArgType>(this->m_state));
        break;
    }
  }

  void FpySequencer_SequencerStateMachineStateMachineBase ::
    sendSignal_result_checkShouldWake_keepSleeping()
  {
    switch (this->m_state) {
      case State::AWAITING_CMD_RUN_VALIDATED:
        break;
      case State::IDLE:
        break;
      case State::RUNNING_AWAITING_STATEMENT_RESPONSE:
        break;
      case State::RUNNING_DISPATCH_STATEMENT:
        break;
      case State::RUNNING_PAUSED:
        break;
      case State::RUNNING_SLEEPING:
        break;
      case State::VALIDATING:
        break;
      default:
        FW_ASSERT(0, static_cast<FwAssertArgType>(this->m_state));
        break;
    }
  }

  void FpySequencer_SequencerStateMachineStateMachineBase ::
    sendSignal_result_timeOpFailed()
  {
    switch (this->m_state) {
      case State::AWAITING_CMD_RUN_VALIDATED:
        break;
      case State::IDLE:
        break;
      case State::RUNNING_AWAITING_STATEMENT_RESPONSE:
        // Do the actions for the transition
        this->action_report_seqFailed(Signal::result_timeOpFailed);
        this->action_sendCmdResponse_EXECUTION_ERROR(Signal::result_timeOpFailed);
        // Enter the target
        this->enter_IDLE(Signal::result_timeOpFailed);
        break;
      case State::RUNNING_DISPATCH_STATEMENT:
        break;
      case State::RUNNING_PAUSED:
        break;
      case State::RUNNING_SLEEPING:
        // Do the actions for the transition
        this->action_report_seqFailed(Signal::result_timeOpFailed);
        this->action_sendCmdResponse_EXECUTION_ERROR(Signal::result_timeOpFailed);
        // Enter the target
        this->enter_IDLE(Signal::result_timeOpFailed);
        break;
      case State::VALIDATING:
        break;
      default:
        FW_ASSERT(0, static_cast<FwAssertArgType>(this->m_state));
        break;
    }
  }

  void FpySequencer_SequencerStateMachineStateMachineBase ::
    sendSignal_stmtResponse_beginSleep()
  {
    switch (this->m_state) {
      case State::AWAITING_CMD_RUN_VALIDATED:
        break;
      case State::IDLE:
        break;
      case State::RUNNING_AWAITING_STATEMENT_RESPONSE:
        // Enter the target
        this->enter_RUNNING_SLEEPING(Signal::stmtResponse_beginSleep);
        break;
      case State::RUNNING_DISPATCH_STATEMENT:
        break;
      case State::RUNNING_PAUSED:
        break;
      case State::RUNNING_SLEEPING:
        break;
      case State::VALIDATING:
        break;
      default:
        FW_ASSERT(0, static_cast<FwAssertArgType>(this->m_state));
        break;
    }
  }

  void FpySequencer_SequencerStateMachineStateMachineBase ::
    sendSignal_stmtResponse_success()
  {
    switch (this->m_state) {
      case State::AWAITING_CMD_RUN_VALIDATED:
        break;
      case State::IDLE:
        break;
      case State::RUNNING_AWAITING_STATEMENT_RESPONSE:
        // Enter the target
        this->enter_RUNNING_BREAK_CHECK(Signal::stmtResponse_success);
        break;
      case State::RUNNING_DISPATCH_STATEMENT:
        break;
      case State::RUNNING_PAUSED:
        break;
      case State::RUNNING_SLEEPING:
        break;
      case State::VALIDATING:
        break;
      default:
        FW_ASSERT(0, static_cast<FwAssertArgType>(this->m_state));
        break;
    }
  }

  void FpySequencer_SequencerStateMachineStateMachineBase ::
    sendSignal_stmtResponse_failure()
  {
    switch (this->m_state) {
      case State::AWAITING_CMD_RUN_VALIDATED:
        break;
      case State::IDLE:
        break;
      case State::RUNNING_AWAITING_STATEMENT_RESPONSE:
        // Do the actions for the transition
        this->action_report_seqFailed(Signal::stmtResponse_failure);
        this->action_sendCmdResponse_EXECUTION_ERROR(Signal::stmtResponse_failure);
        // Enter the target
        this->enter_IDLE(Signal::stmtResponse_failure);
        break;
      case State::RUNNING_DISPATCH_STATEMENT:
        break;
      case State::RUNNING_PAUSED:
        break;
      case State::RUNNING_SLEEPING:
        break;
      case State::VALIDATING:
        break;
      default:
        FW_ASSERT(0, static_cast<FwAssertArgType>(this->m_state));
        break;
    }
  }

  void FpySequencer_SequencerStateMachineStateMachineBase ::
    sendSignal_stmtResponse_unexpected()
  {
    switch (this->m_state) {
      case State::AWAITING_CMD_RUN_VALIDATED:
        break;
      case State::IDLE:
        break;
      case State::RUNNING_AWAITING_STATEMENT_RESPONSE:
        // Do the actions for the transition
        this->action_report_seqFailed(Signal::stmtResponse_unexpected);
        this->action_sendCmdResponse_EXECUTION_ERROR(Signal::stmtResponse_unexpected);
        // Enter the target
        this->enter_IDLE(Signal::stmtResponse_unexpected);
        break;
      case State::RUNNING_DISPATCH_STATEMENT:
        // Do the actions for the transition
        this->action_report_seqFailed(Signal::stmtResponse_unexpected);
        this->action_sendCmdResponse_EXECUTION_ERROR(Signal::stmtResponse_unexpected);
        // Enter the target
        this->enter_IDLE(Signal::stmtResponse_unexpected);
        break;
      case State::RUNNING_PAUSED:
        // Do the actions for the transition
        this->action_report_seqFailed(Signal::stmtResponse_unexpected);
        this->action_sendCmdResponse_EXECUTION_ERROR(Signal::stmtResponse_unexpected);
        // Enter the target
        this->enter_IDLE(Signal::stmtResponse_unexpected);
        break;
      case State::RUNNING_SLEEPING:
        // Do the actions for the transition
        this->action_report_seqFailed(Signal::stmtResponse_unexpected);
        this->action_sendCmdResponse_EXECUTION_ERROR(Signal::stmtResponse_unexpected);
        // Enter the target
        this->enter_IDLE(Signal::stmtResponse_unexpected);
        break;
      case State::VALIDATING:
        break;
      default:
        FW_ASSERT(0, static_cast<FwAssertArgType>(this->m_state));
        break;
    }
  }

  void FpySequencer_SequencerStateMachineStateMachineBase ::
    sendSignal_stmtResponse_keepWaiting()
  {
    switch (this->m_state) {
      case State::AWAITING_CMD_RUN_VALIDATED:
        break;
      case State::IDLE:
        break;
      case State::RUNNING_AWAITING_STATEMENT_RESPONSE:
        break;
      case State::RUNNING_DISPATCH_STATEMENT:
        break;
      case State::RUNNING_PAUSED:
        break;
      case State::RUNNING_SLEEPING:
        break;
      case State::VALIDATING:
        break;
      default:
        FW_ASSERT(0, static_cast<FwAssertArgType>(this->m_state));
        break;
    }
  }

  void FpySequencer_SequencerStateMachineStateMachineBase ::
    sendSignal_result_checkStatementTimeout_statementTimeout()
  {
    switch (this->m_state) {
      case State::AWAITING_CMD_RUN_VALIDATED:
        break;
      case State::IDLE:
        break;
      case State::RUNNING_AWAITING_STATEMENT_RESPONSE:
        // Do the actions for the transition
        this->action_report_seqFailed(Signal::result_checkStatementTimeout_statementTimeout);
        this->action_sendCmdResponse_EXECUTION_ERROR(Signal::result_checkStatementTimeout_statementTimeout);
        // Enter the target
        this->enter_IDLE(Signal::result_checkStatementTimeout_statementTimeout);
        break;
      case State::RUNNING_DISPATCH_STATEMENT:
        break;
      case State::RUNNING_PAUSED:
        break;
      case State::RUNNING_SLEEPING:
        // Do the actions for the transition
        this->action_report_seqFailed(Signal::result_checkStatementTimeout_statementTimeout);
        this->action_sendCmdResponse_EXECUTION_ERROR(Signal::result_checkStatementTimeout_statementTimeout);
        // Enter the target
        this->enter_IDLE(Signal::result_checkStatementTimeout_statementTimeout);
        break;
      case State::VALIDATING:
        break;
      default:
        FW_ASSERT(0, static_cast<FwAssertArgType>(this->m_state));
        break;
    }
  }

  void FpySequencer_SequencerStateMachineStateMachineBase ::
    sendSignal_result_checkStatementTimeout_noTimeout()
  {
    switch (this->m_state) {
      case State::AWAITING_CMD_RUN_VALIDATED:
        break;
      case State::IDLE:
        break;
      case State::RUNNING_AWAITING_STATEMENT_RESPONSE:
        break;
      case State::RUNNING_DISPATCH_STATEMENT:
        break;
      case State::RUNNING_PAUSED:
        break;
      case State::RUNNING_SLEEPING:
        break;
      case State::VALIDATING:
        break;
      default:
        FW_ASSERT(0, static_cast<FwAssertArgType>(this->m_state));
        break;
    }
  }

  void FpySequencer_SequencerStateMachineStateMachineBase ::
    sendSignal_cmd_CONTINUE()
  {
    switch (this->m_state) {
      case State::AWAITING_CMD_RUN_VALIDATED:
        break;
      case State::IDLE:
        break;
      case State::RUNNING_AWAITING_STATEMENT_RESPONSE:
        break;
      case State::RUNNING_DISPATCH_STATEMENT:
        break;
      case State::RUNNING_PAUSED:
        // Enter the target
        this->enter_RUNNING_DISPATCH_STATEMENT(Signal::cmd_CONTINUE);
        break;
      case State::RUNNING_SLEEPING:
        break;
      case State::VALIDATING:
        break;
      default:
        FW_ASSERT(0, static_cast<FwAssertArgType>(this->m_state));
        break;
    }
  }

  void FpySequencer_SequencerStateMachineStateMachineBase ::
    sendSignal_cmd_BREAK()
  {
    switch (this->m_state) {
      case State::AWAITING_CMD_RUN_VALIDATED:
        break;
      case State::IDLE:
        break;
      case State::RUNNING_AWAITING_STATEMENT_RESPONSE:
        // Do the actions for the transition
        this->action_setBreakBeforeNextLine(Signal::cmd_BREAK);
        break;
      case State::RUNNING_DISPATCH_STATEMENT:
        // Do the actions for the transition
        this->action_setBreakBeforeNextLine(Signal::cmd_BREAK);
        break;
      case State::RUNNING_PAUSED:
        // Do the actions for the transition
        this->action_setBreakBeforeNextLine(Signal::cmd_BREAK);
        break;
      case State::RUNNING_SLEEPING:
        // Do the actions for the transition
        this->action_setBreakBeforeNextLine(Signal::cmd_BREAK);
        break;
      case State::VALIDATING:
        break;
      default:
        FW_ASSERT(0, static_cast<FwAssertArgType>(this->m_state));
        break;
    }
  }

  void FpySequencer_SequencerStateMachineStateMachineBase ::
    sendSignal_cmd_STEP()
  {
    switch (this->m_state) {
      case State::AWAITING_CMD_RUN_VALIDATED:
        break;
      case State::IDLE:
        break;
      case State::RUNNING_AWAITING_STATEMENT_RESPONSE:
        break;
      case State::RUNNING_DISPATCH_STATEMENT:
        break;
      case State::RUNNING_PAUSED:
        // Do the actions for the transition
        this->action_setBreakBeforeNextLine(Signal::cmd_STEP);
        // Enter the target
        this->enter_RUNNING_DISPATCH_STATEMENT(Signal::cmd_STEP);
        break;
      case State::RUNNING_SLEEPING:
        break;
      case State::VALIDATING:
        break;
      default:
        FW_ASSERT(0, static_cast<FwAssertArgType>(this->m_state));
        break;
    }
  }

  // ----------------------------------------------------------------------
  // State and choice entry
  // ----------------------------------------------------------------------

  void FpySequencer_SequencerStateMachineStateMachineBase ::
    enter_RUNNING(Signal signal)
  {
    // Do the entry actions
    this->action_resetRuntime(signal);
    this->action_incrementSequenceCounter(signal);
    // Enter the target of the initial transition
    this->enter_RUNNING_BREAK_CHECK(signal);
  }

  void FpySequencer_SequencerStateMachineStateMachineBase ::
    enter_RUNNING_BREAK_CHECK(Signal signal)
  {
    if (this->guard_shouldBreak(signal)) {
      // Do the actions for the transition
      this->action_report_seqBroken(signal);
      // Enter the target
      this->enter_RUNNING_PAUSED(signal);
    }
    else {
      // Enter the target
      this->enter_RUNNING_DISPATCH_STATEMENT(signal);
    }
  }

  void FpySequencer_SequencerStateMachineStateMachineBase ::
    enter_RUNNING_DISPATCH_STATEMENT(Signal signal)
  {
    // Do the entry actions
    this->action_dispatchStatement(signal);
    // Update the state
    this->m_state = State::RUNNING_DISPATCH_STATEMENT;
  }

  void FpySequencer_SequencerStateMachineStateMachineBase ::
    enter_RUNNING_AWAITING_STATEMENT_RESPONSE(Signal signal)
  {
    // Update the state
    this->m_state = State::RUNNING_AWAITING_STATEMENT_RESPONSE;
  }

  void FpySequencer_SequencerStateMachineStateMachineBase ::
    enter_RUNNING_SLEEPING(Signal signal)
  {
    // Update the state
    this->m_state = State::RUNNING_SLEEPING;
  }

  void FpySequencer_SequencerStateMachineStateMachineBase ::
    enter_RUNNING_PAUSED(Signal signal)
  {
    // Do the entry actions
    this->action_signalEntered(signal);
    this->action_clearBreakBeforeNextLine(signal);
    // Update the state
    this->m_state = State::RUNNING_PAUSED;
  }

  void FpySequencer_SequencerStateMachineStateMachineBase ::
    enter_AWAITING_CMD_RUN_VALIDATED(Signal signal)
  {
    // Do the entry actions
    this->action_sendCmdResponse_OK(signal);
    // Update the state
    this->m_state = State::AWAITING_CMD_RUN_VALIDATED;
  }

  void FpySequencer_SequencerStateMachineStateMachineBase ::
    enter_VALID(Signal signal)
  {
    if (this->guard_goalStateIs_RUNNING(signal)) {
      // Enter the target
      this->enter_RUNNING(signal);
    }
    else {
      // Enter the target
      this->enter_AWAITING_CMD_RUN_VALIDATED(signal);
    }
  }

  void FpySequencer_SequencerStateMachineStateMachineBase ::
    enter_VALIDATING(Signal signal)
  {
    // Do the entry actions
    this->action_report_seqStarted(signal);
    this->action_signalEntered(signal);
    // Update the state
    this->m_state = State::VALIDATING;
  }

  void FpySequencer_SequencerStateMachineStateMachineBase ::
    enter_IDLE(Signal signal)
  {
    // Do the entry actions
    this->action_clearBreakpoint(signal);
    this->action_setGoalState_IDLE(signal);
    this->action_clearSequenceFile(signal);
    // Update the state
    this->m_state = State::IDLE;
  }

}
