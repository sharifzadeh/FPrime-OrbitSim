// ======================================================================
// \title  FpySequencer_BreakpointArgsSerializableAc.cpp
// \author Generated by fpp-to-cpp
// \brief  cpp file for FpySequencer_BreakpointArgs struct
// ======================================================================

#include "Fw/Types/Assert.hpp"
#include "Svc/FpySequencer/FpySequencer_BreakpointArgsSerializableAc.hpp"

namespace Svc {

  // ----------------------------------------------------------------------
  // Constructors
  // ----------------------------------------------------------------------

  FpySequencer_BreakpointArgs ::
    FpySequencer_BreakpointArgs() :
      Serializable(),
      m_breakOnBreakpoint(),
      m_breakOnlyOnceOnBreakpoint(),
      m_breakpointIndex()
  {

  }

  FpySequencer_BreakpointArgs ::
    FpySequencer_BreakpointArgs(
        bool breakOnBreakpoint,
        bool breakOnlyOnceOnBreakpoint,
        U32 breakpointIndex
    ) :
      Serializable(),
      m_breakOnBreakpoint(breakOnBreakpoint),
      m_breakOnlyOnceOnBreakpoint(breakOnlyOnceOnBreakpoint),
      m_breakpointIndex(breakpointIndex)
  {

  }

  FpySequencer_BreakpointArgs ::
    FpySequencer_BreakpointArgs(const FpySequencer_BreakpointArgs& obj) :
      Serializable(),
      m_breakOnBreakpoint(obj.m_breakOnBreakpoint),
      m_breakOnlyOnceOnBreakpoint(obj.m_breakOnlyOnceOnBreakpoint),
      m_breakpointIndex(obj.m_breakpointIndex)
  {

  }

  // ----------------------------------------------------------------------
  // Operators
  // ----------------------------------------------------------------------

  FpySequencer_BreakpointArgs& FpySequencer_BreakpointArgs ::
    operator=(const FpySequencer_BreakpointArgs& obj)
  {
    if (this == &obj) {
      return *this;
    }

    set(obj.m_breakOnBreakpoint, obj.m_breakOnlyOnceOnBreakpoint, obj.m_breakpointIndex);
    return *this;
  }

  bool FpySequencer_BreakpointArgs ::
    operator==(const FpySequencer_BreakpointArgs& obj) const
  {
    if (this == &obj) { return true; }
    return (
      (this->m_breakOnBreakpoint == obj.m_breakOnBreakpoint) &&
      (this->m_breakOnlyOnceOnBreakpoint == obj.m_breakOnlyOnceOnBreakpoint) &&
      (this->m_breakpointIndex == obj.m_breakpointIndex)
    );
  }

  bool FpySequencer_BreakpointArgs ::
    operator!=(const FpySequencer_BreakpointArgs& obj) const
  {
    return !(*this == obj);
  }

#ifdef BUILD_UT

  std::ostream& operator<<(std::ostream& os, const FpySequencer_BreakpointArgs& obj) {
    Fw::String s;
    obj.toString(s);
    os << s.toChar();
    return os;
  }

#endif

  // ----------------------------------------------------------------------
  // Member functions
  // ----------------------------------------------------------------------

  Fw::SerializeStatus FpySequencer_BreakpointArgs ::
    serializeTo(
        Fw::SerialBufferBase& buffer,
        Fw::Endianness mode
    ) const
  {
    Fw::SerializeStatus status;

    status = buffer.serializeFrom(this->m_breakOnBreakpoint, mode);
    if (status != Fw::FW_SERIALIZE_OK) {
      return status;
    }
    status = buffer.serializeFrom(this->m_breakOnlyOnceOnBreakpoint, mode);
    if (status != Fw::FW_SERIALIZE_OK) {
      return status;
    }
    status = buffer.serializeFrom(this->m_breakpointIndex, mode);
    if (status != Fw::FW_SERIALIZE_OK) {
      return status;
    }

    return status;
  }

  Fw::SerializeStatus FpySequencer_BreakpointArgs ::
    deserializeFrom(
        Fw::SerialBufferBase& buffer,
        Fw::Endianness mode
    )
  {
    Fw::SerializeStatus status;

    status = buffer.deserializeTo(this->m_breakOnBreakpoint, mode);
    if (status != Fw::FW_SERIALIZE_OK) {
      return status;
    }
    status = buffer.deserializeTo(this->m_breakOnlyOnceOnBreakpoint, mode);
    if (status != Fw::FW_SERIALIZE_OK) {
      return status;
    }
    status = buffer.deserializeTo(this->m_breakpointIndex, mode);
    if (status != Fw::FW_SERIALIZE_OK) {
      return status;
    }

    return status;
  }

  FwSizeType FpySequencer_BreakpointArgs ::
    serializedSize() const
  {
    FwSizeType size = 0;
    size += sizeof(U8);
    size += sizeof(U8);
    size += sizeof(U32);
    return size;
  }

#if FW_SERIALIZABLE_TO_STRING

  void FpySequencer_BreakpointArgs ::
    toString(Fw::StringBase& sb) const
  {
    Fw::String tmp;
    sb = "( ";

    // Format breakOnBreakpoint
    sb += "breakOnBreakpoint = ";
    tmp.format("%d", this->m_breakOnBreakpoint);
    sb += tmp;
    sb += ", ";

    // Format breakOnlyOnceOnBreakpoint
    sb += "breakOnlyOnceOnBreakpoint = ";
    tmp.format("%d", this->m_breakOnlyOnceOnBreakpoint);
    sb += tmp;
    sb += ", ";

    // Format breakpointIndex
    sb += "breakpointIndex = ";
    tmp.format("%" PRIu32 "", this->m_breakpointIndex);
    sb += tmp;
    sb += " )";
  }

#endif

  // ----------------------------------------------------------------------
  // Setter functions
  // ----------------------------------------------------------------------

  void FpySequencer_BreakpointArgs ::
    set(
        bool breakOnBreakpoint,
        bool breakOnlyOnceOnBreakpoint,
        U32 breakpointIndex
    )
  {
    this->m_breakOnBreakpoint = breakOnBreakpoint;
    this->m_breakOnlyOnceOnBreakpoint = breakOnlyOnceOnBreakpoint;
    this->m_breakpointIndex = breakpointIndex;
  }

  void FpySequencer_BreakpointArgs ::
    set_breakOnBreakpoint(bool breakOnBreakpoint)
  {
    this->m_breakOnBreakpoint = breakOnBreakpoint;
  }

  void FpySequencer_BreakpointArgs ::
    set_breakOnlyOnceOnBreakpoint(bool breakOnlyOnceOnBreakpoint)
  {
    this->m_breakOnlyOnceOnBreakpoint = breakOnlyOnceOnBreakpoint;
  }

  void FpySequencer_BreakpointArgs ::
    set_breakpointIndex(U32 breakpointIndex)
  {
    this->m_breakpointIndex = breakpointIndex;
  }

}
