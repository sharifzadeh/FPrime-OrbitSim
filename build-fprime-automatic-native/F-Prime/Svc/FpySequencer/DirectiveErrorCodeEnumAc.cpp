// ======================================================================
// \title  DirectiveErrorCodeEnumAc.cpp
// \author Generated by fpp-to-cpp
// \brief  cpp file for DirectiveErrorCode enum
// ======================================================================

#include <cstring>
#include <limits>

#include "Fw/Types/Assert.hpp"
#include "Svc/FpySequencer/DirectiveErrorCodeEnumAc.hpp"

namespace Svc {

  namespace Fpy {

    // ----------------------------------------------------------------------
    // Operators
    // ----------------------------------------------------------------------

    DirectiveErrorCode& DirectiveErrorCode ::
      operator=(const DirectiveErrorCode& obj)
    {
      this->e = obj.e;
      return *this;
    }

    DirectiveErrorCode& DirectiveErrorCode ::
      operator=(T e1)
    {
      this->e = e1;
      return *this;
    }

#ifdef BUILD_UT

    std::ostream& operator<<(std::ostream& os, const DirectiveErrorCode& obj) {
      Fw::String s;
      obj.toString(s);
      os << s;
      return os;
    }

#endif

    // ----------------------------------------------------------------------
    // Member functions
    // ----------------------------------------------------------------------

    bool DirectiveErrorCode ::
      isValid() const
    {
      return ((e >= NO_ERROR) && (e <= ARITHMETIC_UNDERFLOW));
    }

    Fw::SerializeStatus DirectiveErrorCode ::
      serializeTo(
          Fw::SerialBufferBase& buffer,
          Fw::Endianness mode
      ) const
    {
      const Fw::SerializeStatus status = buffer.serializeFrom(
          static_cast<SerialType>(this->e),
          mode
      );
      return status;
    }

    Fw::SerializeStatus DirectiveErrorCode ::
      deserializeFrom(
          Fw::SerialBufferBase& buffer,
          Fw::Endianness mode
      )
    {
      SerialType es;
      Fw::SerializeStatus status = buffer.deserializeTo(es, mode);
      if (status == Fw::FW_SERIALIZE_OK) {
        this->e = static_cast<T>(es);
        if (!this->isValid()) {
          status = Fw::FW_DESERIALIZE_FORMAT_ERROR;
        }
      }
      return status;
    }

#if FW_SERIALIZABLE_TO_STRING

    void DirectiveErrorCode ::
      toString(Fw::StringBase& sb) const
    {
      Fw::String s;
      switch (e) {
        case NO_ERROR:
          s = "NO_ERROR";
          break;
        case STMT_OUT_OF_BOUNDS:
          s = "STMT_OUT_OF_BOUNDS";
          break;
        case TLM_GET_NOT_CONNECTED:
          s = "TLM_GET_NOT_CONNECTED";
          break;
        case TLM_CHAN_NOT_FOUND:
          s = "TLM_CHAN_NOT_FOUND";
          break;
        case PRM_GET_NOT_CONNECTED:
          s = "PRM_GET_NOT_CONNECTED";
          break;
        case PRM_NOT_FOUND:
          s = "PRM_NOT_FOUND";
          break;
        case CMD_SERIALIZE_FAILURE:
          s = "CMD_SERIALIZE_FAILURE";
          break;
        case EXIT_WITH_ERROR:
          s = "EXIT_WITH_ERROR";
          break;
        case STACK_ACCESS_OUT_OF_BOUNDS:
          s = "STACK_ACCESS_OUT_OF_BOUNDS";
          break;
        case STACK_OVERFLOW:
          s = "STACK_OVERFLOW";
          break;
        case DOMAIN_ERROR:
          s = "DOMAIN_ERROR";
          break;
        case FLAG_IDX_OUT_OF_BOUNDS:
          s = "FLAG_IDX_OUT_OF_BOUNDS";
          break;
        case ARRAY_OUT_OF_BOUNDS:
          s = "ARRAY_OUT_OF_BOUNDS";
          break;
        case ARITHMETIC_OVERFLOW:
          s = "ARITHMETIC_OVERFLOW";
          break;
        case ARITHMETIC_UNDERFLOW:
          s = "ARITHMETIC_UNDERFLOW";
          break;
        default:
          s = "[invalid]";
          break;
      }
      sb.format("%s (%" PRIu8 ")", s.toChar(), e);
    }

#elif FW_ENABLE_TEXT_LOGGING

    void DirectiveErrorCode ::
      toString(Fw::StringBase& sb) const
    {
      sb.format("%" PRIu8 "", e);
    }

#endif

  }

}
