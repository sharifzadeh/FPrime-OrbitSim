// ======================================================================
// \title  FpySequencerComponentAc.cpp
// \author Generated by fpp-to-cpp
// \brief  cpp file for FpySequencer component base class
// ======================================================================

#include "Fw/Types/Assert.hpp"
#include "Fw/Types/ExternalString.hpp"
#if FW_ENABLE_TEXT_LOGGING
#include "Fw/Types/String.hpp"
#endif
#include "Svc/FpySequencer/FpySequencerComponentAc.hpp"

namespace Svc {

  namespace {

    // Constant definitions for the state machine signal buffer
    namespace SmSignalBuffer {

      // Union for computing the max size of a signal type
      union SignalTypeUnion {
        BYTE size_of_Svc_FpySequencer_BreakpointArgs[Svc::FpySequencer_BreakpointArgs::SERIALIZED_SIZE];
        BYTE size_of_Svc_FpySequencer_SequenceExecutionArgs[Svc::FpySequencer_SequenceExecutionArgs::SERIALIZED_SIZE];
      };

      // The serialized size
      static constexpr FwSizeType SERIALIZED_SIZE =
        2 * sizeof(FwEnumStoreType) +
        sizeof(SignalTypeUnion);

    }

    enum MsgTypeEnum {
      FPYSEQUENCER_COMPONENT_EXIT = Fw::ActiveComponentBase::ACTIVE_COMPONENT_EXIT,
      CHECKTIMERS_SCHED,
      CMDRESPONSEIN_CMDRESPONSE,
      PINGIN_PING,
      SEQRUNIN_CMDSEQIN,
      TLMWRITE_SCHED,
      CMD_RUN,
      CMD_VALIDATE,
      CMD_RUN_VALIDATED,
      CMD_CANCEL,
      CMD_SET_BREAKPOINT,
      CMD_BREAK,
      CMD_CONTINUE,
      CMD_CLEAR_BREAKPOINT,
      CMD_STEP,
      CMD_SET_FLAG,
      CMD_DUMP_STACK_TO_FILE,
      INT_IF_DIRECTIVE_ALLOCATE,
      INT_IF_DIRECTIVE_CONSTCMD,
      INT_IF_DIRECTIVE_DISCARD,
      INT_IF_DIRECTIVE_EXIT,
      INT_IF_DIRECTIVE_GETFIELD,
      INT_IF_DIRECTIVE_GETFLAG,
      INT_IF_DIRECTIVE_GOTO,
      INT_IF_DIRECTIVE_IF,
      INT_IF_DIRECTIVE_LOAD,
      INT_IF_DIRECTIVE_MEMCMP,
      INT_IF_DIRECTIVE_NOOP,
      INT_IF_DIRECTIVE_PEEK,
      INT_IF_DIRECTIVE_PUSHPRM,
      INT_IF_DIRECTIVE_PUSHTIME,
      INT_IF_DIRECTIVE_PUSHTLMVAL,
      INT_IF_DIRECTIVE_PUSHTLMVALANDTIME,
      INT_IF_DIRECTIVE_PUSHVAL,
      INT_IF_DIRECTIVE_SETFLAG,
      INT_IF_DIRECTIVE_STACKCMD,
      INT_IF_DIRECTIVE_STACKOP,
      INT_IF_DIRECTIVE_STORE,
      INT_IF_DIRECTIVE_STORECONSTOFFSET,
      INT_IF_DIRECTIVE_WAITABS,
      INT_IF_DIRECTIVE_WAITREL,
      INTERNAL_STATE_MACHINE_SIGNAL,
    };

    // Get the max size by constructing a union of the async input, command, and
    // internal port serialization sizes
    union BuffUnion {
      BYTE checkTimersPortSize[Svc::InputSchedPort::SERIALIZED_SIZE];
      BYTE cmdResponseInPortSize[Fw::InputCmdResponsePort::SERIALIZED_SIZE];
      BYTE pingInPortSize[Svc::InputPingPort::SERIALIZED_SIZE];
      BYTE seqRunInPortSize[Svc::InputCmdSeqInPort::SERIALIZED_SIZE];
      BYTE tlmWritePortSize[Svc::InputSchedPort::SERIALIZED_SIZE];
      BYTE cmdPortSize[Fw::InputCmdPort::SERIALIZED_SIZE];
      // Size of directive_allocate argument list
      BYTE directive_allocateIntIfSize[
        Svc::FpySequencer_AllocateDirective::SERIALIZED_SIZE
      ];
      // Size of directive_constCmd argument list
      BYTE directive_constCmdIntIfSize[
        Svc::FpySequencer_ConstCmdDirective::SERIALIZED_SIZE
      ];
      // Size of directive_discard argument list
      BYTE directive_discardIntIfSize[
        Svc::FpySequencer_DiscardDirective::SERIALIZED_SIZE
      ];
      // Size of directive_exit argument list
      BYTE directive_exitIntIfSize[
        Svc::FpySequencer_ExitDirective::SERIALIZED_SIZE
      ];
      // Size of directive_getField argument list
      BYTE directive_getFieldIntIfSize[
        Svc::FpySequencer_GetFieldDirective::SERIALIZED_SIZE
      ];
      // Size of directive_getFlag argument list
      BYTE directive_getFlagIntIfSize[
        Svc::FpySequencer_GetFlagDirective::SERIALIZED_SIZE
      ];
      // Size of directive_goto argument list
      BYTE directive_gotoIntIfSize[
        Svc::FpySequencer_GotoDirective::SERIALIZED_SIZE
      ];
      // Size of directive_if argument list
      BYTE directive_ifIntIfSize[
        Svc::FpySequencer_IfDirective::SERIALIZED_SIZE
      ];
      // Size of directive_load argument list
      BYTE directive_loadIntIfSize[
        Svc::FpySequencer_LoadDirective::SERIALIZED_SIZE
      ];
      // Size of directive_memCmp argument list
      BYTE directive_memCmpIntIfSize[
        Svc::FpySequencer_MemCmpDirective::SERIALIZED_SIZE
      ];
      // Size of directive_noOp argument list
      BYTE directive_noOpIntIfSize[
        Svc::FpySequencer_NoOpDirective::SERIALIZED_SIZE
      ];
      // Size of directive_peek argument list
      BYTE directive_peekIntIfSize[
        Svc::FpySequencer_PeekDirective::SERIALIZED_SIZE
      ];
      // Size of directive_pushPrm argument list
      BYTE directive_pushPrmIntIfSize[
        Svc::FpySequencer_PushPrmDirective::SERIALIZED_SIZE
      ];
      // Size of directive_pushTime argument list
      BYTE directive_pushTimeIntIfSize[
        Svc::FpySequencer_PushTimeDirective::SERIALIZED_SIZE
      ];
      // Size of directive_pushTlmVal argument list
      BYTE directive_pushTlmValIntIfSize[
        Svc::FpySequencer_PushTlmValDirective::SERIALIZED_SIZE
      ];
      // Size of directive_pushTlmValAndTime argument list
      BYTE directive_pushTlmValAndTimeIntIfSize[
        Svc::FpySequencer_PushTlmValAndTimeDirective::SERIALIZED_SIZE
      ];
      // Size of directive_pushVal argument list
      BYTE directive_pushValIntIfSize[
        Svc::FpySequencer_PushValDirective::SERIALIZED_SIZE
      ];
      // Size of directive_setFlag argument list
      BYTE directive_setFlagIntIfSize[
        Svc::FpySequencer_SetFlagDirective::SERIALIZED_SIZE
      ];
      // Size of directive_stackCmd argument list
      BYTE directive_stackCmdIntIfSize[
        Svc::FpySequencer_StackCmdDirective::SERIALIZED_SIZE
      ];
      // Size of directive_stackOp argument list
      BYTE directive_stackOpIntIfSize[
        Svc::FpySequencer_StackOpDirective::SERIALIZED_SIZE
      ];
      // Size of directive_store argument list
      BYTE directive_storeIntIfSize[
        Svc::FpySequencer_StoreDirective::SERIALIZED_SIZE
      ];
      // Size of directive_storeConstOffset argument list
      BYTE directive_storeConstOffsetIntIfSize[
        Svc::FpySequencer_StoreConstOffsetDirective::SERIALIZED_SIZE
      ];
      // Size of directive_waitAbs argument list
      BYTE directive_waitAbsIntIfSize[
        Svc::FpySequencer_WaitAbsDirective::SERIALIZED_SIZE
      ];
      // Size of directive_waitRel argument list
      BYTE directive_waitRelIntIfSize[
        Svc::FpySequencer_WaitRelDirective::SERIALIZED_SIZE
      ];
      // Size of buffer for internal state machine signals
      // The internal SmSignalBuffer stores the state machine id, the
      // signal id, and the signal data
      BYTE internalSmBufferSize[SmSignalBuffer::SERIALIZED_SIZE];
    };

    // Define a message buffer class large enough to handle all the
    // asynchronous inputs to the component
    class ComponentIpcSerializableBuffer :
      public Fw::LinearBufferBase
    {

      public:

        enum {
          // Offset into data in buffer: Size of message ID and port number
          DATA_OFFSET = sizeof(FwEnumStoreType) + sizeof(FwIndexType),
          // Max data size
          MAX_DATA_SIZE = sizeof(BuffUnion),
          // Max message size: Size of message id + size of port + max data size
          SERIALIZATION_SIZE = DATA_OFFSET + MAX_DATA_SIZE
        };

        Fw::Serializable::SizeType getCapacity() const {
          return sizeof(m_buff);
        }

        U8* getBuffAddr() {
          return m_buff;
        }

        const U8* getBuffAddr() const {
          return m_buff;
        }

      private:
        // Should be the max of all the input ports serialized sizes...
        U8 m_buff[SERIALIZATION_SIZE];

    };
  }

  // ----------------------------------------------------------------------
  // Types for internal state machines
  // ----------------------------------------------------------------------

  FpySequencerComponentBase::Svc_FpySequencer_SequencerStateMachine ::
    Svc_FpySequencer_SequencerStateMachine(FpySequencerComponentBase& component) :
      m_component(component)
  {

  }

  void FpySequencerComponentBase::Svc_FpySequencer_SequencerStateMachine ::
    init(FpySequencerComponentBase::SmId smId)
  {
    this->initBase(static_cast<FwEnumStoreType>(smId));
  }

  FpySequencerComponentBase::SmId FpySequencerComponentBase::Svc_FpySequencer_SequencerStateMachine ::
    getId() const
  {
    return static_cast<FpySequencerComponentBase::SmId>(this->m_id);
  }

  void FpySequencerComponentBase::Svc_FpySequencer_SequencerStateMachine ::
    action_signalEntered(Signal signal)
  {
    this->m_component.Svc_FpySequencer_SequencerStateMachine_action_signalEntered(this->getId(), signal);
  }

  void FpySequencerComponentBase::Svc_FpySequencer_SequencerStateMachine ::
    action_setSequenceFilePath(
        Signal signal,
        const Svc::FpySequencer_SequenceExecutionArgs& value
    )
  {
    this->m_component.Svc_FpySequencer_SequencerStateMachine_action_setSequenceFilePath(this->getId(), signal, value);
  }

  void FpySequencerComponentBase::Svc_FpySequencer_SequencerStateMachine ::
    action_setSequenceBlockState(
        Signal signal,
        const Svc::FpySequencer_SequenceExecutionArgs& value
    )
  {
    this->m_component.Svc_FpySequencer_SequencerStateMachine_action_setSequenceBlockState(this->getId(), signal, value);
  }

  void FpySequencerComponentBase::Svc_FpySequencer_SequencerStateMachine ::
    action_validate(Signal signal)
  {
    this->m_component.Svc_FpySequencer_SequencerStateMachine_action_validate(this->getId(), signal);
  }

  void FpySequencerComponentBase::Svc_FpySequencer_SequencerStateMachine ::
    action_report_seqSucceeded(Signal signal)
  {
    this->m_component.Svc_FpySequencer_SequencerStateMachine_action_report_seqSucceeded(this->getId(), signal);
  }

  void FpySequencerComponentBase::Svc_FpySequencer_SequencerStateMachine ::
    action_report_seqCancelled(Signal signal)
  {
    this->m_component.Svc_FpySequencer_SequencerStateMachine_action_report_seqCancelled(this->getId(), signal);
  }

  void FpySequencerComponentBase::Svc_FpySequencer_SequencerStateMachine ::
    action_report_seqFailed(Signal signal)
  {
    this->m_component.Svc_FpySequencer_SequencerStateMachine_action_report_seqFailed(this->getId(), signal);
  }

  void FpySequencerComponentBase::Svc_FpySequencer_SequencerStateMachine ::
    action_report_seqStarted(Signal signal)
  {
    this->m_component.Svc_FpySequencer_SequencerStateMachine_action_report_seqStarted(this->getId(), signal);
  }

  void FpySequencerComponentBase::Svc_FpySequencer_SequencerStateMachine ::
    action_setGoalState_RUNNING(Signal signal)
  {
    this->m_component.Svc_FpySequencer_SequencerStateMachine_action_setGoalState_RUNNING(this->getId(), signal);
  }

  void FpySequencerComponentBase::Svc_FpySequencer_SequencerStateMachine ::
    action_setGoalState_VALID(Signal signal)
  {
    this->m_component.Svc_FpySequencer_SequencerStateMachine_action_setGoalState_VALID(this->getId(), signal);
  }

  void FpySequencerComponentBase::Svc_FpySequencer_SequencerStateMachine ::
    action_setGoalState_IDLE(Signal signal)
  {
    this->m_component.Svc_FpySequencer_SequencerStateMachine_action_setGoalState_IDLE(this->getId(), signal);
  }

  void FpySequencerComponentBase::Svc_FpySequencer_SequencerStateMachine ::
    action_sendCmdResponse_OK(Signal signal)
  {
    this->m_component.Svc_FpySequencer_SequencerStateMachine_action_sendCmdResponse_OK(this->getId(), signal);
  }

  void FpySequencerComponentBase::Svc_FpySequencer_SequencerStateMachine ::
    action_sendCmdResponse_EXECUTION_ERROR(Signal signal)
  {
    this->m_component.Svc_FpySequencer_SequencerStateMachine_action_sendCmdResponse_EXECUTION_ERROR(this->getId(), signal);
  }

  void FpySequencerComponentBase::Svc_FpySequencer_SequencerStateMachine ::
    action_clearSequenceFile(Signal signal)
  {
    this->m_component.Svc_FpySequencer_SequencerStateMachine_action_clearSequenceFile(this->getId(), signal);
  }

  void FpySequencerComponentBase::Svc_FpySequencer_SequencerStateMachine ::
    action_clearBreakpoint(Signal signal)
  {
    this->m_component.Svc_FpySequencer_SequencerStateMachine_action_clearBreakpoint(this->getId(), signal);
  }

  void FpySequencerComponentBase::Svc_FpySequencer_SequencerStateMachine ::
    action_checkShouldWake(Signal signal)
  {
    this->m_component.Svc_FpySequencer_SequencerStateMachine_action_checkShouldWake(this->getId(), signal);
  }

  void FpySequencerComponentBase::Svc_FpySequencer_SequencerStateMachine ::
    action_dispatchStatement(Signal signal)
  {
    this->m_component.Svc_FpySequencer_SequencerStateMachine_action_dispatchStatement(this->getId(), signal);
  }

  void FpySequencerComponentBase::Svc_FpySequencer_SequencerStateMachine ::
    action_resetRuntime(Signal signal)
  {
    this->m_component.Svc_FpySequencer_SequencerStateMachine_action_resetRuntime(this->getId(), signal);
  }

  void FpySequencerComponentBase::Svc_FpySequencer_SequencerStateMachine ::
    action_checkStatementTimeout(Signal signal)
  {
    this->m_component.Svc_FpySequencer_SequencerStateMachine_action_checkStatementTimeout(this->getId(), signal);
  }

  void FpySequencerComponentBase::Svc_FpySequencer_SequencerStateMachine ::
    action_incrementSequenceCounter(Signal signal)
  {
    this->m_component.Svc_FpySequencer_SequencerStateMachine_action_incrementSequenceCounter(this->getId(), signal);
  }

  void FpySequencerComponentBase::Svc_FpySequencer_SequencerStateMachine ::
    action_report_seqBroken(Signal signal)
  {
    this->m_component.Svc_FpySequencer_SequencerStateMachine_action_report_seqBroken(this->getId(), signal);
  }

  void FpySequencerComponentBase::Svc_FpySequencer_SequencerStateMachine ::
    action_setBreakpoint(
        Signal signal,
        const Svc::FpySequencer_BreakpointArgs& value
    )
  {
    this->m_component.Svc_FpySequencer_SequencerStateMachine_action_setBreakpoint(this->getId(), signal, value);
  }

  void FpySequencerComponentBase::Svc_FpySequencer_SequencerStateMachine ::
    action_setBreakBeforeNextLine(Signal signal)
  {
    this->m_component.Svc_FpySequencer_SequencerStateMachine_action_setBreakBeforeNextLine(this->getId(), signal);
  }

  void FpySequencerComponentBase::Svc_FpySequencer_SequencerStateMachine ::
    action_clearBreakBeforeNextLine(Signal signal)
  {
    this->m_component.Svc_FpySequencer_SequencerStateMachine_action_clearBreakBeforeNextLine(this->getId(), signal);
  }

  bool FpySequencerComponentBase::Svc_FpySequencer_SequencerStateMachine ::
    guard_goalStateIs_RUNNING(Signal signal) const
  {
    return this->m_component.Svc_FpySequencer_SequencerStateMachine_guard_goalStateIs_RUNNING(this->getId(), signal);
  }

  bool FpySequencerComponentBase::Svc_FpySequencer_SequencerStateMachine ::
    guard_shouldBreak(Signal signal) const
  {
    return this->m_component.Svc_FpySequencer_SequencerStateMachine_guard_shouldBreak(this->getId(), signal);
  }

  bool FpySequencerComponentBase::Svc_FpySequencer_SequencerStateMachine ::
    guard_breakOnce(Signal signal) const
  {
    return this->m_component.Svc_FpySequencer_SequencerStateMachine_guard_breakOnce(this->getId(), signal);
  }

  // ----------------------------------------------------------------------
  // Component initialization
  // ----------------------------------------------------------------------

  void FpySequencerComponentBase ::
    init(
        FwSizeType queueDepth,
        FwEnumStoreType instance
    )
  {
    // Initialize base class
    Fw::ActiveComponentBase::init(instance);

    // Initialize state machine instances
    this->m_stateMachine_sequencer.init(SmId::sequencer);

    // Connect input port cmdIn
    for (
      FwIndexType port = 0;
      port < static_cast<FwIndexType>(this->getNum_cmdIn_InputPorts());
      port++
    ) {
      this->m_cmdIn_InputPort[port].init();
      this->m_cmdIn_InputPort[port].addCallComp(
        this,
        m_p_cmdIn_in
      );
      this->m_cmdIn_InputPort[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
      Fw::ObjectName portName;
      portName.format(
        "%s_cmdIn_InputPort[%" PRI_FwIndexType "]",
        this->m_objName.toChar(),
        port
      );
      this->m_cmdIn_InputPort[port].setObjName(portName.toChar());
#endif
    }

    // Connect input port checkTimers
    for (
      FwIndexType port = 0;
      port < static_cast<FwIndexType>(this->getNum_checkTimers_InputPorts());
      port++
    ) {
      this->m_checkTimers_InputPort[port].init();
      this->m_checkTimers_InputPort[port].addCallComp(
        this,
        m_p_checkTimers_in
      );
      this->m_checkTimers_InputPort[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
      Fw::ObjectName portName;
      portName.format(
        "%s_checkTimers_InputPort[%" PRI_FwIndexType "]",
        this->m_objName.toChar(),
        port
      );
      this->m_checkTimers_InputPort[port].setObjName(portName.toChar());
#endif
    }

    // Connect input port cmdResponseIn
    for (
      FwIndexType port = 0;
      port < static_cast<FwIndexType>(this->getNum_cmdResponseIn_InputPorts());
      port++
    ) {
      this->m_cmdResponseIn_InputPort[port].init();
      this->m_cmdResponseIn_InputPort[port].addCallComp(
        this,
        m_p_cmdResponseIn_in
      );
      this->m_cmdResponseIn_InputPort[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
      Fw::ObjectName portName;
      portName.format(
        "%s_cmdResponseIn_InputPort[%" PRI_FwIndexType "]",
        this->m_objName.toChar(),
        port
      );
      this->m_cmdResponseIn_InputPort[port].setObjName(portName.toChar());
#endif
    }

    // Connect input port pingIn
    for (
      FwIndexType port = 0;
      port < static_cast<FwIndexType>(this->getNum_pingIn_InputPorts());
      port++
    ) {
      this->m_pingIn_InputPort[port].init();
      this->m_pingIn_InputPort[port].addCallComp(
        this,
        m_p_pingIn_in
      );
      this->m_pingIn_InputPort[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
      Fw::ObjectName portName;
      portName.format(
        "%s_pingIn_InputPort[%" PRI_FwIndexType "]",
        this->m_objName.toChar(),
        port
      );
      this->m_pingIn_InputPort[port].setObjName(portName.toChar());
#endif
    }

    // Connect input port seqRunIn
    for (
      FwIndexType port = 0;
      port < static_cast<FwIndexType>(this->getNum_seqRunIn_InputPorts());
      port++
    ) {
      this->m_seqRunIn_InputPort[port].init();
      this->m_seqRunIn_InputPort[port].addCallComp(
        this,
        m_p_seqRunIn_in
      );
      this->m_seqRunIn_InputPort[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
      Fw::ObjectName portName;
      portName.format(
        "%s_seqRunIn_InputPort[%" PRI_FwIndexType "]",
        this->m_objName.toChar(),
        port
      );
      this->m_seqRunIn_InputPort[port].setObjName(portName.toChar());
#endif
    }

    // Connect input port tlmWrite
    for (
      FwIndexType port = 0;
      port < static_cast<FwIndexType>(this->getNum_tlmWrite_InputPorts());
      port++
    ) {
      this->m_tlmWrite_InputPort[port].init();
      this->m_tlmWrite_InputPort[port].addCallComp(
        this,
        m_p_tlmWrite_in
      );
      this->m_tlmWrite_InputPort[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
      Fw::ObjectName portName;
      portName.format(
        "%s_tlmWrite_InputPort[%" PRI_FwIndexType "]",
        this->m_objName.toChar(),
        port
      );
      this->m_tlmWrite_InputPort[port].setObjName(portName.toChar());
#endif
    }

    // Connect output port cmdRegOut
    for (
      FwIndexType port = 0;
      port < static_cast<FwIndexType>(this->getNum_cmdRegOut_OutputPorts());
      port++
    ) {
      this->m_cmdRegOut_OutputPort[port].init();

#if FW_OBJECT_NAMES == 1
      Fw::ObjectName portName;
      portName.format(
        "%s_cmdRegOut_OutputPort[%" PRI_FwIndexType "]",
        this->m_objName.toChar(),
        port
      );
      this->m_cmdRegOut_OutputPort[port].setObjName(portName.toChar());
#endif
    }

    // Connect output port cmdResponseOut
    for (
      FwIndexType port = 0;
      port < static_cast<FwIndexType>(this->getNum_cmdResponseOut_OutputPorts());
      port++
    ) {
      this->m_cmdResponseOut_OutputPort[port].init();

#if FW_OBJECT_NAMES == 1
      Fw::ObjectName portName;
      portName.format(
        "%s_cmdResponseOut_OutputPort[%" PRI_FwIndexType "]",
        this->m_objName.toChar(),
        port
      );
      this->m_cmdResponseOut_OutputPort[port].setObjName(portName.toChar());
#endif
    }

    // Connect output port logOut
    for (
      FwIndexType port = 0;
      port < static_cast<FwIndexType>(this->getNum_logOut_OutputPorts());
      port++
    ) {
      this->m_logOut_OutputPort[port].init();

#if FW_OBJECT_NAMES == 1
      Fw::ObjectName portName;
      portName.format(
        "%s_logOut_OutputPort[%" PRI_FwIndexType "]",
        this->m_objName.toChar(),
        port
      );
      this->m_logOut_OutputPort[port].setObjName(portName.toChar());
#endif
    }

#if FW_ENABLE_TEXT_LOGGING == 1
    // Connect output port logTextOut
    for (
      FwIndexType port = 0;
      port < static_cast<FwIndexType>(this->getNum_logTextOut_OutputPorts());
      port++
    ) {
      this->m_logTextOut_OutputPort[port].init();

#if FW_OBJECT_NAMES == 1
      Fw::ObjectName portName;
      portName.format(
        "%s_logTextOut_OutputPort[%" PRI_FwIndexType "]",
        this->m_objName.toChar(),
        port
      );
      this->m_logTextOut_OutputPort[port].setObjName(portName.toChar());
#endif
    }
#endif

    // Connect output port prmGet
    for (
      FwIndexType port = 0;
      port < static_cast<FwIndexType>(this->getNum_prmGet_OutputPorts());
      port++
    ) {
      this->m_prmGet_OutputPort[port].init();

#if FW_OBJECT_NAMES == 1
      Fw::ObjectName portName;
      portName.format(
        "%s_prmGet_OutputPort[%" PRI_FwIndexType "]",
        this->m_objName.toChar(),
        port
      );
      this->m_prmGet_OutputPort[port].setObjName(portName.toChar());
#endif
    }

    // Connect output port prmSet
    for (
      FwIndexType port = 0;
      port < static_cast<FwIndexType>(this->getNum_prmSet_OutputPorts());
      port++
    ) {
      this->m_prmSet_OutputPort[port].init();

#if FW_OBJECT_NAMES == 1
      Fw::ObjectName portName;
      portName.format(
        "%s_prmSet_OutputPort[%" PRI_FwIndexType "]",
        this->m_objName.toChar(),
        port
      );
      this->m_prmSet_OutputPort[port].setObjName(portName.toChar());
#endif
    }

    // Connect output port timeCaller
    for (
      FwIndexType port = 0;
      port < static_cast<FwIndexType>(this->getNum_timeCaller_OutputPorts());
      port++
    ) {
      this->m_timeCaller_OutputPort[port].init();

#if FW_OBJECT_NAMES == 1
      Fw::ObjectName portName;
      portName.format(
        "%s_timeCaller_OutputPort[%" PRI_FwIndexType "]",
        this->m_objName.toChar(),
        port
      );
      this->m_timeCaller_OutputPort[port].setObjName(portName.toChar());
#endif
    }

    // Connect output port tlmOut
    for (
      FwIndexType port = 0;
      port < static_cast<FwIndexType>(this->getNum_tlmOut_OutputPorts());
      port++
    ) {
      this->m_tlmOut_OutputPort[port].init();

#if FW_OBJECT_NAMES == 1
      Fw::ObjectName portName;
      portName.format(
        "%s_tlmOut_OutputPort[%" PRI_FwIndexType "]",
        this->m_objName.toChar(),
        port
      );
      this->m_tlmOut_OutputPort[port].setObjName(portName.toChar());
#endif
    }

    // Connect output port cmdOut
    for (
      FwIndexType port = 0;
      port < static_cast<FwIndexType>(this->getNum_cmdOut_OutputPorts());
      port++
    ) {
      this->m_cmdOut_OutputPort[port].init();

#if FW_OBJECT_NAMES == 1
      Fw::ObjectName portName;
      portName.format(
        "%s_cmdOut_OutputPort[%" PRI_FwIndexType "]",
        this->m_objName.toChar(),
        port
      );
      this->m_cmdOut_OutputPort[port].setObjName(portName.toChar());
#endif
    }

    // Connect output port getParam
    for (
      FwIndexType port = 0;
      port < static_cast<FwIndexType>(this->getNum_getParam_OutputPorts());
      port++
    ) {
      this->m_getParam_OutputPort[port].init();

#if FW_OBJECT_NAMES == 1
      Fw::ObjectName portName;
      portName.format(
        "%s_getParam_OutputPort[%" PRI_FwIndexType "]",
        this->m_objName.toChar(),
        port
      );
      this->m_getParam_OutputPort[port].setObjName(portName.toChar());
#endif
    }

    // Connect output port getTlmChan
    for (
      FwIndexType port = 0;
      port < static_cast<FwIndexType>(this->getNum_getTlmChan_OutputPorts());
      port++
    ) {
      this->m_getTlmChan_OutputPort[port].init();

#if FW_OBJECT_NAMES == 1
      Fw::ObjectName portName;
      portName.format(
        "%s_getTlmChan_OutputPort[%" PRI_FwIndexType "]",
        this->m_objName.toChar(),
        port
      );
      this->m_getTlmChan_OutputPort[port].setObjName(portName.toChar());
#endif
    }

    // Connect output port pingOut
    for (
      FwIndexType port = 0;
      port < static_cast<FwIndexType>(this->getNum_pingOut_OutputPorts());
      port++
    ) {
      this->m_pingOut_OutputPort[port].init();

#if FW_OBJECT_NAMES == 1
      Fw::ObjectName portName;
      portName.format(
        "%s_pingOut_OutputPort[%" PRI_FwIndexType "]",
        this->m_objName.toChar(),
        port
      );
      this->m_pingOut_OutputPort[port].setObjName(portName.toChar());
#endif
    }

    // Connect output port seqDoneOut
    for (
      FwIndexType port = 0;
      port < static_cast<FwIndexType>(this->getNum_seqDoneOut_OutputPorts());
      port++
    ) {
      this->m_seqDoneOut_OutputPort[port].init();

#if FW_OBJECT_NAMES == 1
      Fw::ObjectName portName;
      portName.format(
        "%s_seqDoneOut_OutputPort[%" PRI_FwIndexType "]",
        this->m_objName.toChar(),
        port
      );
      this->m_seqDoneOut_OutputPort[port].setObjName(portName.toChar());
#endif
    }

    // Connect output port seqStartOut
    for (
      FwIndexType port = 0;
      port < static_cast<FwIndexType>(this->getNum_seqStartOut_OutputPorts());
      port++
    ) {
      this->m_seqStartOut_OutputPort[port].init();

#if FW_OBJECT_NAMES == 1
      Fw::ObjectName portName;
      portName.format(
        "%s_seqStartOut_OutputPort[%" PRI_FwIndexType "]",
        this->m_objName.toChar(),
        port
      );
      this->m_seqStartOut_OutputPort[port].setObjName(portName.toChar());
#endif
    }

    // Create the queue
    Os::Queue::Status qStat = this->createQueue(
      queueDepth,
      static_cast<FwSizeType>(ComponentIpcSerializableBuffer::SERIALIZATION_SIZE)
    );
    FW_ASSERT(
      Os::Queue::Status::OP_OK == qStat,
      static_cast<FwAssertArgType>(qStat)
    );
  }

  // ----------------------------------------------------------------------
  // Getters for special input ports
  // ----------------------------------------------------------------------

  Fw::InputCmdPort* FpySequencerComponentBase ::
    get_cmdIn_InputPort(FwIndexType portNum)
  {
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_cmdIn_InputPorts()),
      static_cast<FwAssertArgType>(portNum)
    );

    return &this->m_cmdIn_InputPort[portNum];
  }

  // ----------------------------------------------------------------------
  // Getters for typed input ports
  // ----------------------------------------------------------------------

  Svc::InputSchedPort* FpySequencerComponentBase ::
    get_checkTimers_InputPort(FwIndexType portNum)
  {
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_checkTimers_InputPorts()),
      static_cast<FwAssertArgType>(portNum)
    );

    return &this->m_checkTimers_InputPort[portNum];
  }

  Fw::InputCmdResponsePort* FpySequencerComponentBase ::
    get_cmdResponseIn_InputPort(FwIndexType portNum)
  {
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_cmdResponseIn_InputPorts()),
      static_cast<FwAssertArgType>(portNum)
    );

    return &this->m_cmdResponseIn_InputPort[portNum];
  }

  Svc::InputPingPort* FpySequencerComponentBase ::
    get_pingIn_InputPort(FwIndexType portNum)
  {
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_pingIn_InputPorts()),
      static_cast<FwAssertArgType>(portNum)
    );

    return &this->m_pingIn_InputPort[portNum];
  }

  Svc::InputCmdSeqInPort* FpySequencerComponentBase ::
    get_seqRunIn_InputPort(FwIndexType portNum)
  {
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_seqRunIn_InputPorts()),
      static_cast<FwAssertArgType>(portNum)
    );

    return &this->m_seqRunIn_InputPort[portNum];
  }

  Svc::InputSchedPort* FpySequencerComponentBase ::
    get_tlmWrite_InputPort(FwIndexType portNum)
  {
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_tlmWrite_InputPorts()),
      static_cast<FwAssertArgType>(portNum)
    );

    return &this->m_tlmWrite_InputPort[portNum];
  }

  // ----------------------------------------------------------------------
  // Connect input ports to special output ports
  // ----------------------------------------------------------------------

  void FpySequencerComponentBase ::
    set_cmdRegOut_OutputPort(
        FwIndexType portNum,
        Fw::InputCmdRegPort* port
    )
  {
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_cmdRegOut_OutputPorts()),
      static_cast<FwAssertArgType>(portNum)
    );

    this->m_cmdRegOut_OutputPort[portNum].addCallPort(port);
  }

  void FpySequencerComponentBase ::
    set_cmdResponseOut_OutputPort(
        FwIndexType portNum,
        Fw::InputCmdResponsePort* port
    )
  {
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_cmdResponseOut_OutputPorts()),
      static_cast<FwAssertArgType>(portNum)
    );

    this->m_cmdResponseOut_OutputPort[portNum].addCallPort(port);
  }

  void FpySequencerComponentBase ::
    set_logOut_OutputPort(
        FwIndexType portNum,
        Fw::InputLogPort* port
    )
  {
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_logOut_OutputPorts()),
      static_cast<FwAssertArgType>(portNum)
    );

    this->m_logOut_OutputPort[portNum].addCallPort(port);
  }

#if FW_ENABLE_TEXT_LOGGING == 1

  void FpySequencerComponentBase ::
    set_logTextOut_OutputPort(
        FwIndexType portNum,
        Fw::InputLogTextPort* port
    )
  {
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_logTextOut_OutputPorts()),
      static_cast<FwAssertArgType>(portNum)
    );

    this->m_logTextOut_OutputPort[portNum].addCallPort(port);
  }

#endif

  void FpySequencerComponentBase ::
    set_prmGet_OutputPort(
        FwIndexType portNum,
        Fw::InputPrmGetPort* port
    )
  {
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_prmGet_OutputPorts()),
      static_cast<FwAssertArgType>(portNum)
    );

    this->m_prmGet_OutputPort[portNum].addCallPort(port);
  }

  void FpySequencerComponentBase ::
    set_prmSet_OutputPort(
        FwIndexType portNum,
        Fw::InputPrmSetPort* port
    )
  {
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_prmSet_OutputPorts()),
      static_cast<FwAssertArgType>(portNum)
    );

    this->m_prmSet_OutputPort[portNum].addCallPort(port);
  }

  void FpySequencerComponentBase ::
    set_timeCaller_OutputPort(
        FwIndexType portNum,
        Fw::InputTimePort* port
    )
  {
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_timeCaller_OutputPorts()),
      static_cast<FwAssertArgType>(portNum)
    );

    this->m_timeCaller_OutputPort[portNum].addCallPort(port);
  }

  void FpySequencerComponentBase ::
    set_tlmOut_OutputPort(
        FwIndexType portNum,
        Fw::InputTlmPort* port
    )
  {
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_tlmOut_OutputPorts()),
      static_cast<FwAssertArgType>(portNum)
    );

    this->m_tlmOut_OutputPort[portNum].addCallPort(port);
  }

  // ----------------------------------------------------------------------
  // Connect typed input ports to typed output ports
  // ----------------------------------------------------------------------

  void FpySequencerComponentBase ::
    set_cmdOut_OutputPort(
        FwIndexType portNum,
        Fw::InputComPort* port
    )
  {
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_cmdOut_OutputPorts()),
      static_cast<FwAssertArgType>(portNum)
    );

    this->m_cmdOut_OutputPort[portNum].addCallPort(port);
  }

  void FpySequencerComponentBase ::
    set_getParam_OutputPort(
        FwIndexType portNum,
        Fw::InputPrmGetPort* port
    )
  {
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_getParam_OutputPorts()),
      static_cast<FwAssertArgType>(portNum)
    );

    this->m_getParam_OutputPort[portNum].addCallPort(port);
  }

  void FpySequencerComponentBase ::
    set_getTlmChan_OutputPort(
        FwIndexType portNum,
        Fw::InputTlmGetPort* port
    )
  {
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_getTlmChan_OutputPorts()),
      static_cast<FwAssertArgType>(portNum)
    );

    this->m_getTlmChan_OutputPort[portNum].addCallPort(port);
  }

  void FpySequencerComponentBase ::
    set_pingOut_OutputPort(
        FwIndexType portNum,
        Svc::InputPingPort* port
    )
  {
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_pingOut_OutputPorts()),
      static_cast<FwAssertArgType>(portNum)
    );

    this->m_pingOut_OutputPort[portNum].addCallPort(port);
  }

  void FpySequencerComponentBase ::
    set_seqDoneOut_OutputPort(
        FwIndexType portNum,
        Fw::InputCmdResponsePort* port
    )
  {
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_seqDoneOut_OutputPorts()),
      static_cast<FwAssertArgType>(portNum)
    );

    this->m_seqDoneOut_OutputPort[portNum].addCallPort(port);
  }

  void FpySequencerComponentBase ::
    set_seqStartOut_OutputPort(
        FwIndexType portNum,
        Svc::InputCmdSeqInPort* port
    )
  {
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_seqStartOut_OutputPorts()),
      static_cast<FwAssertArgType>(portNum)
    );

    this->m_seqStartOut_OutputPort[portNum].addCallPort(port);
  }

#if FW_PORT_SERIALIZATION

  // ----------------------------------------------------------------------
  // Connect serial input ports to special output ports
  // ----------------------------------------------------------------------

  void FpySequencerComponentBase ::
    set_cmdRegOut_OutputPort(
        FwIndexType portNum,
        Fw::InputSerializePort* port
    )
  {
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_cmdRegOut_OutputPorts()),
      static_cast<FwAssertArgType>(portNum)
    );

    this->m_cmdRegOut_OutputPort[portNum].registerSerialPort(port);
  }

  void FpySequencerComponentBase ::
    set_cmdResponseOut_OutputPort(
        FwIndexType portNum,
        Fw::InputSerializePort* port
    )
  {
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_cmdResponseOut_OutputPorts()),
      static_cast<FwAssertArgType>(portNum)
    );

    this->m_cmdResponseOut_OutputPort[portNum].registerSerialPort(port);
  }

  void FpySequencerComponentBase ::
    set_logOut_OutputPort(
        FwIndexType portNum,
        Fw::InputSerializePort* port
    )
  {
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_logOut_OutputPorts()),
      static_cast<FwAssertArgType>(portNum)
    );

    this->m_logOut_OutputPort[portNum].registerSerialPort(port);
  }

#if FW_ENABLE_TEXT_LOGGING == 1

  void FpySequencerComponentBase ::
    set_logTextOut_OutputPort(
        FwIndexType portNum,
        Fw::InputSerializePort* port
    )
  {
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_logTextOut_OutputPorts()),
      static_cast<FwAssertArgType>(portNum)
    );

    this->m_logTextOut_OutputPort[portNum].registerSerialPort(port);
  }

#endif

  void FpySequencerComponentBase ::
    set_prmSet_OutputPort(
        FwIndexType portNum,
        Fw::InputSerializePort* port
    )
  {
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_prmSet_OutputPorts()),
      static_cast<FwAssertArgType>(portNum)
    );

    this->m_prmSet_OutputPort[portNum].registerSerialPort(port);
  }

  void FpySequencerComponentBase ::
    set_timeCaller_OutputPort(
        FwIndexType portNum,
        Fw::InputSerializePort* port
    )
  {
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_timeCaller_OutputPorts()),
      static_cast<FwAssertArgType>(portNum)
    );

    this->m_timeCaller_OutputPort[portNum].registerSerialPort(port);
  }

  void FpySequencerComponentBase ::
    set_tlmOut_OutputPort(
        FwIndexType portNum,
        Fw::InputSerializePort* port
    )
  {
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_tlmOut_OutputPorts()),
      static_cast<FwAssertArgType>(portNum)
    );

    this->m_tlmOut_OutputPort[portNum].registerSerialPort(port);
  }

#endif

#if FW_PORT_SERIALIZATION

  // ----------------------------------------------------------------------
  // Connect serial input ports to typed output ports
  // ----------------------------------------------------------------------

  void FpySequencerComponentBase ::
    set_cmdOut_OutputPort(
        FwIndexType portNum,
        Fw::InputSerializePort* port
    )
  {
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_cmdOut_OutputPorts()),
      static_cast<FwAssertArgType>(portNum)
    );

    this->m_cmdOut_OutputPort[portNum].registerSerialPort(port);
  }

  void FpySequencerComponentBase ::
    set_pingOut_OutputPort(
        FwIndexType portNum,
        Fw::InputSerializePort* port
    )
  {
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_pingOut_OutputPorts()),
      static_cast<FwAssertArgType>(portNum)
    );

    this->m_pingOut_OutputPort[portNum].registerSerialPort(port);
  }

  void FpySequencerComponentBase ::
    set_seqDoneOut_OutputPort(
        FwIndexType portNum,
        Fw::InputSerializePort* port
    )
  {
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_seqDoneOut_OutputPorts()),
      static_cast<FwAssertArgType>(portNum)
    );

    this->m_seqDoneOut_OutputPort[portNum].registerSerialPort(port);
  }

  void FpySequencerComponentBase ::
    set_seqStartOut_OutputPort(
        FwIndexType portNum,
        Fw::InputSerializePort* port
    )
  {
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_seqStartOut_OutputPorts()),
      static_cast<FwAssertArgType>(portNum)
    );

    this->m_seqStartOut_OutputPort[portNum].registerSerialPort(port);
  }

#endif

  // ----------------------------------------------------------------------
  // Command registration
  // ----------------------------------------------------------------------

  void FpySequencerComponentBase ::
    regCommands()
  {
    FW_ASSERT(this->m_cmdRegOut_OutputPort[0].isConnected());

    this->m_cmdRegOut_OutputPort[0].invoke(
      this->getIdBase() + OPCODE_RUN
    );

    this->m_cmdRegOut_OutputPort[0].invoke(
      this->getIdBase() + OPCODE_VALIDATE
    );

    this->m_cmdRegOut_OutputPort[0].invoke(
      this->getIdBase() + OPCODE_RUN_VALIDATED
    );

    this->m_cmdRegOut_OutputPort[0].invoke(
      this->getIdBase() + OPCODE_CANCEL
    );

    this->m_cmdRegOut_OutputPort[0].invoke(
      this->getIdBase() + OPCODE_SET_BREAKPOINT
    );

    this->m_cmdRegOut_OutputPort[0].invoke(
      this->getIdBase() + OPCODE_BREAK
    );

    this->m_cmdRegOut_OutputPort[0].invoke(
      this->getIdBase() + OPCODE_CONTINUE
    );

    this->m_cmdRegOut_OutputPort[0].invoke(
      this->getIdBase() + OPCODE_CLEAR_BREAKPOINT
    );

    this->m_cmdRegOut_OutputPort[0].invoke(
      this->getIdBase() + OPCODE_STEP
    );

    this->m_cmdRegOut_OutputPort[0].invoke(
      this->getIdBase() + OPCODE_SET_FLAG
    );

    this->m_cmdRegOut_OutputPort[0].invoke(
      this->getIdBase() + OPCODE_DUMP_STACK_TO_FILE
    );

    this->m_cmdRegOut_OutputPort[0].invoke(
      this->getIdBase() + OPCODE_STATEMENT_TIMEOUT_SECS_SET
    );

    this->m_cmdRegOut_OutputPort[0].invoke(
      this->getIdBase() + OPCODE_STATEMENT_TIMEOUT_SECS_SAVE
    );

    this->m_cmdRegOut_OutputPort[0].invoke(
      this->getIdBase() + OPCODE_FLAG_DEFAULT_EXIT_ON_CMD_FAIL_SET
    );

    this->m_cmdRegOut_OutputPort[0].invoke(
      this->getIdBase() + OPCODE_FLAG_DEFAULT_EXIT_ON_CMD_FAIL_SAVE
    );
  }

  // ----------------------------------------------------------------------
  // Parameter loading
  // ----------------------------------------------------------------------

  void FpySequencerComponentBase ::
    loadParameters()
  {
    Fw::ParamBuffer _buff;
    Fw::SerializeStatus _stat = Fw::FW_SERIALIZE_OK;
    const FwPrmIdType _baseId = static_cast<FwPrmIdType>(this->getIdBase());
    FW_ASSERT(this->m_prmGet_OutputPort[0].isConnected());

    FwPrmIdType _id{};

    _id = _baseId + PARAMID_STATEMENT_TIMEOUT_SECS;

    // Get parameter STATEMENT_TIMEOUT_SECS
    this->m_param_STATEMENT_TIMEOUT_SECS_valid =
      this->m_prmGet_OutputPort[0].invoke(
        _id,
        _buff
      );

    // Deserialize value
    this->m_paramLock.lock();

    // If there was a deserialization issue, mark it invalid
    if (this->m_param_STATEMENT_TIMEOUT_SECS_valid == Fw::ParamValid::VALID) {
      _stat = _buff.deserializeTo(this->m_STATEMENT_TIMEOUT_SECS);
      if (_stat != Fw::FW_SERIALIZE_OK) {
        this->m_param_STATEMENT_TIMEOUT_SECS_valid = Fw::ParamValid::DEFAULT;
        // Set default value
        this->m_STATEMENT_TIMEOUT_SECS = 0.0f;
      }
    }
    else {
      // Set default value
      this->m_param_STATEMENT_TIMEOUT_SECS_valid = Fw::ParamValid::DEFAULT;
      this->m_STATEMENT_TIMEOUT_SECS = 0.0f;
    }

    this->m_paramLock.unLock();

    _id = _baseId + PARAMID_FLAG_DEFAULT_EXIT_ON_CMD_FAIL;

    // Get parameter FLAG_DEFAULT_EXIT_ON_CMD_FAIL
    this->m_param_FLAG_DEFAULT_EXIT_ON_CMD_FAIL_valid =
      this->m_prmGet_OutputPort[0].invoke(
        _id,
        _buff
      );

    // Deserialize value
    this->m_paramLock.lock();

    // If there was a deserialization issue, mark it invalid
    if (this->m_param_FLAG_DEFAULT_EXIT_ON_CMD_FAIL_valid == Fw::ParamValid::VALID) {
      _stat = _buff.deserializeTo(this->m_FLAG_DEFAULT_EXIT_ON_CMD_FAIL);
      if (_stat != Fw::FW_SERIALIZE_OK) {
        this->m_param_FLAG_DEFAULT_EXIT_ON_CMD_FAIL_valid = Fw::ParamValid::DEFAULT;
        // Set default value
        this->m_FLAG_DEFAULT_EXIT_ON_CMD_FAIL = false;
      }
    }
    else {
      // Set default value
      this->m_param_FLAG_DEFAULT_EXIT_ON_CMD_FAIL_valid = Fw::ParamValid::DEFAULT;
      this->m_FLAG_DEFAULT_EXIT_ON_CMD_FAIL = false;
    }

    this->m_paramLock.unLock();

    // Call notifier
    this->parametersLoaded();
  }

  // ----------------------------------------------------------------------
  // Component construction and destruction
  // ----------------------------------------------------------------------

  FpySequencerComponentBase ::
    FpySequencerComponentBase(const char* compName) :
      Fw::ActiveComponentBase(compName),
      m_stateMachine_sequencer(*this)
  {
    this->m_param_STATEMENT_TIMEOUT_SECS_valid = Fw::ParamValid::UNINIT;
    this->m_param_FLAG_DEFAULT_EXIT_ON_CMD_FAIL_valid = Fw::ParamValid::UNINIT;
  }

  FpySequencerComponentBase ::
    ~FpySequencerComponentBase()
  {

  }

  // ----------------------------------------------------------------------
  // Connection status queries for special output ports
  // ----------------------------------------------------------------------

  bool FpySequencerComponentBase ::
    isConnected_cmdRegOut_OutputPort(FwIndexType portNum)
  {
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_cmdRegOut_OutputPorts()),
      static_cast<FwAssertArgType>(portNum)
    );

    return this->m_cmdRegOut_OutputPort[portNum].isConnected();
  }

  bool FpySequencerComponentBase ::
    isConnected_cmdResponseOut_OutputPort(FwIndexType portNum)
  {
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_cmdResponseOut_OutputPorts()),
      static_cast<FwAssertArgType>(portNum)
    );

    return this->m_cmdResponseOut_OutputPort[portNum].isConnected();
  }

  bool FpySequencerComponentBase ::
    isConnected_logOut_OutputPort(FwIndexType portNum)
  {
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_logOut_OutputPorts()),
      static_cast<FwAssertArgType>(portNum)
    );

    return this->m_logOut_OutputPort[portNum].isConnected();
  }

#if FW_ENABLE_TEXT_LOGGING == 1

  bool FpySequencerComponentBase ::
    isConnected_logTextOut_OutputPort(FwIndexType portNum)
  {
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_logTextOut_OutputPorts()),
      static_cast<FwAssertArgType>(portNum)
    );

    return this->m_logTextOut_OutputPort[portNum].isConnected();
  }

#endif

  bool FpySequencerComponentBase ::
    isConnected_prmGet_OutputPort(FwIndexType portNum)
  {
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_prmGet_OutputPorts()),
      static_cast<FwAssertArgType>(portNum)
    );

    return this->m_prmGet_OutputPort[portNum].isConnected();
  }

  bool FpySequencerComponentBase ::
    isConnected_prmSet_OutputPort(FwIndexType portNum)
  {
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_prmSet_OutputPorts()),
      static_cast<FwAssertArgType>(portNum)
    );

    return this->m_prmSet_OutputPort[portNum].isConnected();
  }

  bool FpySequencerComponentBase ::
    isConnected_timeCaller_OutputPort(FwIndexType portNum)
  {
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_timeCaller_OutputPorts()),
      static_cast<FwAssertArgType>(portNum)
    );

    return this->m_timeCaller_OutputPort[portNum].isConnected();
  }

  bool FpySequencerComponentBase ::
    isConnected_tlmOut_OutputPort(FwIndexType portNum)
  {
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_tlmOut_OutputPorts()),
      static_cast<FwAssertArgType>(portNum)
    );

    return this->m_tlmOut_OutputPort[portNum].isConnected();
  }

  // ----------------------------------------------------------------------
  // Connection status queries for typed output ports
  // ----------------------------------------------------------------------

  bool FpySequencerComponentBase ::
    isConnected_cmdOut_OutputPort(FwIndexType portNum)
  {
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_cmdOut_OutputPorts()),
      static_cast<FwAssertArgType>(portNum)
    );

    return this->m_cmdOut_OutputPort[portNum].isConnected();
  }

  bool FpySequencerComponentBase ::
    isConnected_getParam_OutputPort(FwIndexType portNum)
  {
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_getParam_OutputPorts()),
      static_cast<FwAssertArgType>(portNum)
    );

    return this->m_getParam_OutputPort[portNum].isConnected();
  }

  bool FpySequencerComponentBase ::
    isConnected_getTlmChan_OutputPort(FwIndexType portNum)
  {
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_getTlmChan_OutputPorts()),
      static_cast<FwAssertArgType>(portNum)
    );

    return this->m_getTlmChan_OutputPort[portNum].isConnected();
  }

  bool FpySequencerComponentBase ::
    isConnected_pingOut_OutputPort(FwIndexType portNum)
  {
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_pingOut_OutputPorts()),
      static_cast<FwAssertArgType>(portNum)
    );

    return this->m_pingOut_OutputPort[portNum].isConnected();
  }

  bool FpySequencerComponentBase ::
    isConnected_seqDoneOut_OutputPort(FwIndexType portNum)
  {
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_seqDoneOut_OutputPorts()),
      static_cast<FwAssertArgType>(portNum)
    );

    return this->m_seqDoneOut_OutputPort[portNum].isConnected();
  }

  bool FpySequencerComponentBase ::
    isConnected_seqStartOut_OutputPort(FwIndexType portNum)
  {
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_seqStartOut_OutputPorts()),
      static_cast<FwAssertArgType>(portNum)
    );

    return this->m_seqStartOut_OutputPort[portNum].isConnected();
  }

  // ----------------------------------------------------------------------
  // Port handler base-class functions for typed input ports
  //
  // Call these functions directly to bypass the corresponding ports
  // ----------------------------------------------------------------------

  void FpySequencerComponentBase ::
    checkTimers_handlerBase(
        FwIndexType portNum,
        U32 context
    )
  {
    // Make sure port number is valid
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_checkTimers_InputPorts()),
      static_cast<FwAssertArgType>(portNum)
    );

    // Call pre-message hook
    checkTimers_preMsgHook(
      portNum,
      context
    );
    ComponentIpcSerializableBuffer msg;
    Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

    // Serialize message ID
    _status = msg.serializeFrom(
      static_cast<FwEnumStoreType>(CHECKTIMERS_SCHED)
    );
    FW_ASSERT(
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    // Serialize port number
    _status = msg.serializeFrom(portNum);
    FW_ASSERT(
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    // Serialize argument context
    _status = msg.serializeFrom(context);
    FW_ASSERT(
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    // Send message
    Os::Queue::BlockingType _block = Os::Queue::NONBLOCKING;
    Os::Queue::Status qStatus = this->m_queue.send(msg, 4, _block);

    FW_ASSERT(
      qStatus == Os::Queue::OP_OK,
      static_cast<FwAssertArgType>(qStatus)
    );
  }

  void FpySequencerComponentBase ::
    cmdResponseIn_handlerBase(
        FwIndexType portNum,
        FwOpcodeType opCode,
        U32 cmdSeq,
        const Fw::CmdResponse& response
    )
  {
    // Make sure port number is valid
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_cmdResponseIn_InputPorts()),
      static_cast<FwAssertArgType>(portNum)
    );

    // Call pre-message hook
    cmdResponseIn_preMsgHook(
      portNum,
      opCode,
      cmdSeq,
      response
    );
    ComponentIpcSerializableBuffer msg;
    Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

    // Serialize message ID
    _status = msg.serializeFrom(
      static_cast<FwEnumStoreType>(CMDRESPONSEIN_CMDRESPONSE)
    );
    FW_ASSERT(
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    // Serialize port number
    _status = msg.serializeFrom(portNum);
    FW_ASSERT(
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    // Serialize argument opCode
    _status = msg.serializeFrom(opCode);
    FW_ASSERT(
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    // Serialize argument cmdSeq
    _status = msg.serializeFrom(cmdSeq);
    FW_ASSERT(
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    // Serialize argument response
    _status = msg.serializeFrom(response);
    FW_ASSERT(
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    // Send message
    Os::Queue::BlockingType _block = Os::Queue::NONBLOCKING;
    Os::Queue::Status qStatus = this->m_queue.send(msg, 5, _block);

    FW_ASSERT(
      qStatus == Os::Queue::OP_OK,
      static_cast<FwAssertArgType>(qStatus)
    );
  }

  void FpySequencerComponentBase ::
    pingIn_handlerBase(
        FwIndexType portNum,
        U32 key
    )
  {
    // Make sure port number is valid
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_pingIn_InputPorts()),
      static_cast<FwAssertArgType>(portNum)
    );

    // Call pre-message hook
    pingIn_preMsgHook(
      portNum,
      key
    );
    ComponentIpcSerializableBuffer msg;
    Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

    // Serialize message ID
    _status = msg.serializeFrom(
      static_cast<FwEnumStoreType>(PINGIN_PING)
    );
    FW_ASSERT(
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    // Serialize port number
    _status = msg.serializeFrom(portNum);
    FW_ASSERT(
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    // Serialize argument key
    _status = msg.serializeFrom(key);
    FW_ASSERT(
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    // Send message
    Os::Queue::BlockingType _block = Os::Queue::NONBLOCKING;
    Os::Queue::Status qStatus = this->m_queue.send(msg, 10, _block);

    FW_ASSERT(
      qStatus == Os::Queue::OP_OK,
      static_cast<FwAssertArgType>(qStatus)
    );
  }

  void FpySequencerComponentBase ::
    seqRunIn_handlerBase(
        FwIndexType portNum,
        const Fw::StringBase& filename
    )
  {
    // Make sure port number is valid
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_seqRunIn_InputPorts()),
      static_cast<FwAssertArgType>(portNum)
    );

    // Call pre-message hook
    seqRunIn_preMsgHook(
      portNum,
      filename
    );
    ComponentIpcSerializableBuffer msg;
    Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

    // Serialize message ID
    _status = msg.serializeFrom(
      static_cast<FwEnumStoreType>(SEQRUNIN_CMDSEQIN)
    );
    FW_ASSERT(
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    // Serialize port number
    _status = msg.serializeFrom(portNum);
    FW_ASSERT(
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    // Serialize argument filename
    _status = filename.serializeTo(msg, 240);
    FW_ASSERT(
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    // Send message
    Os::Queue::BlockingType _block = Os::Queue::NONBLOCKING;
    Os::Queue::Status qStatus = this->m_queue.send(msg, 7, _block);

    FW_ASSERT(
      qStatus == Os::Queue::OP_OK,
      static_cast<FwAssertArgType>(qStatus)
    );
  }

  void FpySequencerComponentBase ::
    tlmWrite_handlerBase(
        FwIndexType portNum,
        U32 context
    )
  {
    // Make sure port number is valid
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_tlmWrite_InputPorts()),
      static_cast<FwAssertArgType>(portNum)
    );

    // Call pre-message hook
    tlmWrite_preMsgHook(
      portNum,
      context
    );
    ComponentIpcSerializableBuffer msg;
    Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

    // Serialize message ID
    _status = msg.serializeFrom(
      static_cast<FwEnumStoreType>(TLMWRITE_SCHED)
    );
    FW_ASSERT(
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    // Serialize port number
    _status = msg.serializeFrom(portNum);
    FW_ASSERT(
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    // Serialize argument context
    _status = msg.serializeFrom(context);
    FW_ASSERT(
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    // Send message
    Os::Queue::BlockingType _block = Os::Queue::NONBLOCKING;
    Os::Queue::Status qStatus = this->m_queue.send(msg, 1, _block);

    FW_ASSERT(
      qStatus == Os::Queue::OP_OK,
      static_cast<FwAssertArgType>(qStatus)
    );
  }

  // ----------------------------------------------------------------------
  // Pre-message hooks for typed async input ports
  //
  // Each of these functions is invoked just before processing a message
  // on the corresponding port. By default, they do nothing. You can
  // override them to provide specific pre-message behavior.
  // ----------------------------------------------------------------------

  void FpySequencerComponentBase ::
    checkTimers_preMsgHook(
        FwIndexType portNum,
        U32 context
    )
  {
    // Default: no-op
  }

  void FpySequencerComponentBase ::
    cmdResponseIn_preMsgHook(
        FwIndexType portNum,
        FwOpcodeType opCode,
        U32 cmdSeq,
        const Fw::CmdResponse& response
    )
  {
    // Default: no-op
  }

  void FpySequencerComponentBase ::
    pingIn_preMsgHook(
        FwIndexType portNum,
        U32 key
    )
  {
    // Default: no-op
  }

  void FpySequencerComponentBase ::
    seqRunIn_preMsgHook(
        FwIndexType portNum,
        const Fw::StringBase& filename
    )
  {
    // Default: no-op
  }

  void FpySequencerComponentBase ::
    tlmWrite_preMsgHook(
        FwIndexType portNum,
        U32 context
    )
  {
    // Default: no-op
  }

  // ----------------------------------------------------------------------
  // Invocation functions for typed output ports
  // ----------------------------------------------------------------------

  void FpySequencerComponentBase ::
    cmdOut_out(
        FwIndexType portNum,
        Fw::ComBuffer& data,
        U32 context
    )
  {
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_cmdOut_OutputPorts()),
      static_cast<FwAssertArgType>(portNum)
    );

    FW_ASSERT(
      this->m_cmdOut_OutputPort[portNum].isConnected(),
      static_cast<FwAssertArgType>(portNum)
    );
    this->m_cmdOut_OutputPort[portNum].invoke(
      data,
      context
    );
  }

  Fw::ParamValid FpySequencerComponentBase ::
    getParam_out(
        FwIndexType portNum,
        FwPrmIdType id,
        Fw::ParamBuffer& val
    )
  {
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_getParam_OutputPorts()),
      static_cast<FwAssertArgType>(portNum)
    );

    FW_ASSERT(
      this->m_getParam_OutputPort[portNum].isConnected(),
      static_cast<FwAssertArgType>(portNum)
    );
    return this->m_getParam_OutputPort[portNum].invoke(
      id,
      val
    );
  }

  Fw::TlmValid FpySequencerComponentBase ::
    getTlmChan_out(
        FwIndexType portNum,
        FwChanIdType id,
        Fw::Time& timeTag,
        Fw::TlmBuffer& val
    )
  {
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_getTlmChan_OutputPorts()),
      static_cast<FwAssertArgType>(portNum)
    );

    FW_ASSERT(
      this->m_getTlmChan_OutputPort[portNum].isConnected(),
      static_cast<FwAssertArgType>(portNum)
    );
    return this->m_getTlmChan_OutputPort[portNum].invoke(
      id,
      timeTag,
      val
    );
  }

  void FpySequencerComponentBase ::
    pingOut_out(
        FwIndexType portNum,
        U32 key
    )
  {
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_pingOut_OutputPorts()),
      static_cast<FwAssertArgType>(portNum)
    );

    FW_ASSERT(
      this->m_pingOut_OutputPort[portNum].isConnected(),
      static_cast<FwAssertArgType>(portNum)
    );
    this->m_pingOut_OutputPort[portNum].invoke(
      key
    );
  }

  void FpySequencerComponentBase ::
    seqDoneOut_out(
        FwIndexType portNum,
        FwOpcodeType opCode,
        U32 cmdSeq,
        const Fw::CmdResponse& response
    )
  {
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_seqDoneOut_OutputPorts()),
      static_cast<FwAssertArgType>(portNum)
    );

    FW_ASSERT(
      this->m_seqDoneOut_OutputPort[portNum].isConnected(),
      static_cast<FwAssertArgType>(portNum)
    );
    this->m_seqDoneOut_OutputPort[portNum].invoke(
      opCode,
      cmdSeq,
      response
    );
  }

  void FpySequencerComponentBase ::
    seqStartOut_out(
        FwIndexType portNum,
        const Fw::StringBase& filename
    )
  {
    FW_ASSERT(
      (0 <= portNum) && (portNum < this->getNum_seqStartOut_OutputPorts()),
      static_cast<FwAssertArgType>(portNum)
    );

    FW_ASSERT(
      this->m_seqStartOut_OutputPort[portNum].isConnected(),
      static_cast<FwAssertArgType>(portNum)
    );
    this->m_seqStartOut_OutputPort[portNum].invoke(
      filename
    );
  }

  // ----------------------------------------------------------------------
  // Internal interface base-class functions
  // ----------------------------------------------------------------------

  void FpySequencerComponentBase ::
    directive_allocate_internalInterfaceInvoke(const Svc::FpySequencer_AllocateDirective& directive)
  {
    ComponentIpcSerializableBuffer msg;
    Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

    // Serialize the message ID
    _status = msg.serializeFrom(static_cast<FwEnumStoreType>(INT_IF_DIRECTIVE_ALLOCATE));
    FW_ASSERT (
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    // Fake port number to make message dequeue work
    _status = msg.serializeFrom(static_cast<FwIndexType>(0));
    FW_ASSERT (
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    _status = msg.serializeFrom(directive);
    FW_ASSERT(
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    // Send message
    Os::Queue::BlockingType _block = Os::Queue::NONBLOCKING;
    Os::Queue::Status qStatus = this->m_queue.send(msg, 6, _block);

    FW_ASSERT(
      qStatus == Os::Queue::OP_OK,
      static_cast<FwAssertArgType>(qStatus)
    );
  }

  void FpySequencerComponentBase ::
    directive_constCmd_internalInterfaceInvoke(const Svc::FpySequencer_ConstCmdDirective& directive)
  {
    ComponentIpcSerializableBuffer msg;
    Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

    // Serialize the message ID
    _status = msg.serializeFrom(static_cast<FwEnumStoreType>(INT_IF_DIRECTIVE_CONSTCMD));
    FW_ASSERT (
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    // Fake port number to make message dequeue work
    _status = msg.serializeFrom(static_cast<FwIndexType>(0));
    FW_ASSERT (
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    _status = msg.serializeFrom(directive);
    FW_ASSERT(
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    // Send message
    Os::Queue::BlockingType _block = Os::Queue::NONBLOCKING;
    Os::Queue::Status qStatus = this->m_queue.send(msg, 6, _block);

    FW_ASSERT(
      qStatus == Os::Queue::OP_OK,
      static_cast<FwAssertArgType>(qStatus)
    );
  }

  void FpySequencerComponentBase ::
    directive_discard_internalInterfaceInvoke(const Svc::FpySequencer_DiscardDirective& directive)
  {
    ComponentIpcSerializableBuffer msg;
    Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

    // Serialize the message ID
    _status = msg.serializeFrom(static_cast<FwEnumStoreType>(INT_IF_DIRECTIVE_DISCARD));
    FW_ASSERT (
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    // Fake port number to make message dequeue work
    _status = msg.serializeFrom(static_cast<FwIndexType>(0));
    FW_ASSERT (
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    _status = msg.serializeFrom(directive);
    FW_ASSERT(
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    // Send message
    Os::Queue::BlockingType _block = Os::Queue::NONBLOCKING;
    Os::Queue::Status qStatus = this->m_queue.send(msg, 6, _block);

    FW_ASSERT(
      qStatus == Os::Queue::OP_OK,
      static_cast<FwAssertArgType>(qStatus)
    );
  }

  void FpySequencerComponentBase ::
    directive_exit_internalInterfaceInvoke(const Svc::FpySequencer_ExitDirective& directive)
  {
    ComponentIpcSerializableBuffer msg;
    Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

    // Serialize the message ID
    _status = msg.serializeFrom(static_cast<FwEnumStoreType>(INT_IF_DIRECTIVE_EXIT));
    FW_ASSERT (
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    // Fake port number to make message dequeue work
    _status = msg.serializeFrom(static_cast<FwIndexType>(0));
    FW_ASSERT (
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    _status = msg.serializeFrom(directive);
    FW_ASSERT(
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    // Send message
    Os::Queue::BlockingType _block = Os::Queue::NONBLOCKING;
    Os::Queue::Status qStatus = this->m_queue.send(msg, 6, _block);

    FW_ASSERT(
      qStatus == Os::Queue::OP_OK,
      static_cast<FwAssertArgType>(qStatus)
    );
  }

  void FpySequencerComponentBase ::
    directive_getField_internalInterfaceInvoke(const Svc::FpySequencer_GetFieldDirective& directive)
  {
    ComponentIpcSerializableBuffer msg;
    Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

    // Serialize the message ID
    _status = msg.serializeFrom(static_cast<FwEnumStoreType>(INT_IF_DIRECTIVE_GETFIELD));
    FW_ASSERT (
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    // Fake port number to make message dequeue work
    _status = msg.serializeFrom(static_cast<FwIndexType>(0));
    FW_ASSERT (
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    _status = msg.serializeFrom(directive);
    FW_ASSERT(
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    // Send message
    Os::Queue::BlockingType _block = Os::Queue::NONBLOCKING;
    Os::Queue::Status qStatus = this->m_queue.send(msg, 6, _block);

    FW_ASSERT(
      qStatus == Os::Queue::OP_OK,
      static_cast<FwAssertArgType>(qStatus)
    );
  }

  void FpySequencerComponentBase ::
    directive_getFlag_internalInterfaceInvoke(const Svc::FpySequencer_GetFlagDirective& directive)
  {
    ComponentIpcSerializableBuffer msg;
    Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

    // Serialize the message ID
    _status = msg.serializeFrom(static_cast<FwEnumStoreType>(INT_IF_DIRECTIVE_GETFLAG));
    FW_ASSERT (
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    // Fake port number to make message dequeue work
    _status = msg.serializeFrom(static_cast<FwIndexType>(0));
    FW_ASSERT (
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    _status = msg.serializeFrom(directive);
    FW_ASSERT(
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    // Send message
    Os::Queue::BlockingType _block = Os::Queue::NONBLOCKING;
    Os::Queue::Status qStatus = this->m_queue.send(msg, 6, _block);

    FW_ASSERT(
      qStatus == Os::Queue::OP_OK,
      static_cast<FwAssertArgType>(qStatus)
    );
  }

  void FpySequencerComponentBase ::
    directive_goto_internalInterfaceInvoke(const Svc::FpySequencer_GotoDirective& directive)
  {
    ComponentIpcSerializableBuffer msg;
    Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

    // Serialize the message ID
    _status = msg.serializeFrom(static_cast<FwEnumStoreType>(INT_IF_DIRECTIVE_GOTO));
    FW_ASSERT (
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    // Fake port number to make message dequeue work
    _status = msg.serializeFrom(static_cast<FwIndexType>(0));
    FW_ASSERT (
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    _status = msg.serializeFrom(directive);
    FW_ASSERT(
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    // Send message
    Os::Queue::BlockingType _block = Os::Queue::NONBLOCKING;
    Os::Queue::Status qStatus = this->m_queue.send(msg, 6, _block);

    FW_ASSERT(
      qStatus == Os::Queue::OP_OK,
      static_cast<FwAssertArgType>(qStatus)
    );
  }

  void FpySequencerComponentBase ::
    directive_if_internalInterfaceInvoke(const Svc::FpySequencer_IfDirective& directive)
  {
    ComponentIpcSerializableBuffer msg;
    Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

    // Serialize the message ID
    _status = msg.serializeFrom(static_cast<FwEnumStoreType>(INT_IF_DIRECTIVE_IF));
    FW_ASSERT (
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    // Fake port number to make message dequeue work
    _status = msg.serializeFrom(static_cast<FwIndexType>(0));
    FW_ASSERT (
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    _status = msg.serializeFrom(directive);
    FW_ASSERT(
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    // Send message
    Os::Queue::BlockingType _block = Os::Queue::NONBLOCKING;
    Os::Queue::Status qStatus = this->m_queue.send(msg, 6, _block);

    FW_ASSERT(
      qStatus == Os::Queue::OP_OK,
      static_cast<FwAssertArgType>(qStatus)
    );
  }

  void FpySequencerComponentBase ::
    directive_load_internalInterfaceInvoke(const Svc::FpySequencer_LoadDirective& directive)
  {
    ComponentIpcSerializableBuffer msg;
    Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

    // Serialize the message ID
    _status = msg.serializeFrom(static_cast<FwEnumStoreType>(INT_IF_DIRECTIVE_LOAD));
    FW_ASSERT (
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    // Fake port number to make message dequeue work
    _status = msg.serializeFrom(static_cast<FwIndexType>(0));
    FW_ASSERT (
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    _status = msg.serializeFrom(directive);
    FW_ASSERT(
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    // Send message
    Os::Queue::BlockingType _block = Os::Queue::NONBLOCKING;
    Os::Queue::Status qStatus = this->m_queue.send(msg, 6, _block);

    FW_ASSERT(
      qStatus == Os::Queue::OP_OK,
      static_cast<FwAssertArgType>(qStatus)
    );
  }

  void FpySequencerComponentBase ::
    directive_memCmp_internalInterfaceInvoke(const Svc::FpySequencer_MemCmpDirective& directive)
  {
    ComponentIpcSerializableBuffer msg;
    Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

    // Serialize the message ID
    _status = msg.serializeFrom(static_cast<FwEnumStoreType>(INT_IF_DIRECTIVE_MEMCMP));
    FW_ASSERT (
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    // Fake port number to make message dequeue work
    _status = msg.serializeFrom(static_cast<FwIndexType>(0));
    FW_ASSERT (
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    _status = msg.serializeFrom(directive);
    FW_ASSERT(
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    // Send message
    Os::Queue::BlockingType _block = Os::Queue::NONBLOCKING;
    Os::Queue::Status qStatus = this->m_queue.send(msg, 6, _block);

    FW_ASSERT(
      qStatus == Os::Queue::OP_OK,
      static_cast<FwAssertArgType>(qStatus)
    );
  }

  void FpySequencerComponentBase ::
    directive_noOp_internalInterfaceInvoke(const Svc::FpySequencer_NoOpDirective& directive)
  {
    ComponentIpcSerializableBuffer msg;
    Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

    // Serialize the message ID
    _status = msg.serializeFrom(static_cast<FwEnumStoreType>(INT_IF_DIRECTIVE_NOOP));
    FW_ASSERT (
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    // Fake port number to make message dequeue work
    _status = msg.serializeFrom(static_cast<FwIndexType>(0));
    FW_ASSERT (
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    _status = msg.serializeFrom(directive);
    FW_ASSERT(
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    // Send message
    Os::Queue::BlockingType _block = Os::Queue::NONBLOCKING;
    Os::Queue::Status qStatus = this->m_queue.send(msg, 6, _block);

    FW_ASSERT(
      qStatus == Os::Queue::OP_OK,
      static_cast<FwAssertArgType>(qStatus)
    );
  }

  void FpySequencerComponentBase ::
    directive_peek_internalInterfaceInvoke(const Svc::FpySequencer_PeekDirective& directive)
  {
    ComponentIpcSerializableBuffer msg;
    Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

    // Serialize the message ID
    _status = msg.serializeFrom(static_cast<FwEnumStoreType>(INT_IF_DIRECTIVE_PEEK));
    FW_ASSERT (
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    // Fake port number to make message dequeue work
    _status = msg.serializeFrom(static_cast<FwIndexType>(0));
    FW_ASSERT (
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    _status = msg.serializeFrom(directive);
    FW_ASSERT(
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    // Send message
    Os::Queue::BlockingType _block = Os::Queue::NONBLOCKING;
    Os::Queue::Status qStatus = this->m_queue.send(msg, 6, _block);

    FW_ASSERT(
      qStatus == Os::Queue::OP_OK,
      static_cast<FwAssertArgType>(qStatus)
    );
  }

  void FpySequencerComponentBase ::
    directive_pushPrm_internalInterfaceInvoke(const Svc::FpySequencer_PushPrmDirective& directive)
  {
    ComponentIpcSerializableBuffer msg;
    Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

    // Serialize the message ID
    _status = msg.serializeFrom(static_cast<FwEnumStoreType>(INT_IF_DIRECTIVE_PUSHPRM));
    FW_ASSERT (
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    // Fake port number to make message dequeue work
    _status = msg.serializeFrom(static_cast<FwIndexType>(0));
    FW_ASSERT (
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    _status = msg.serializeFrom(directive);
    FW_ASSERT(
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    // Send message
    Os::Queue::BlockingType _block = Os::Queue::NONBLOCKING;
    Os::Queue::Status qStatus = this->m_queue.send(msg, 6, _block);

    FW_ASSERT(
      qStatus == Os::Queue::OP_OK,
      static_cast<FwAssertArgType>(qStatus)
    );
  }

  void FpySequencerComponentBase ::
    directive_pushTime_internalInterfaceInvoke(const Svc::FpySequencer_PushTimeDirective& directive)
  {
    ComponentIpcSerializableBuffer msg;
    Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

    // Serialize the message ID
    _status = msg.serializeFrom(static_cast<FwEnumStoreType>(INT_IF_DIRECTIVE_PUSHTIME));
    FW_ASSERT (
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    // Fake port number to make message dequeue work
    _status = msg.serializeFrom(static_cast<FwIndexType>(0));
    FW_ASSERT (
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    _status = msg.serializeFrom(directive);
    FW_ASSERT(
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    // Send message
    Os::Queue::BlockingType _block = Os::Queue::NONBLOCKING;
    Os::Queue::Status qStatus = this->m_queue.send(msg, 6, _block);

    FW_ASSERT(
      qStatus == Os::Queue::OP_OK,
      static_cast<FwAssertArgType>(qStatus)
    );
  }

  void FpySequencerComponentBase ::
    directive_pushTlmVal_internalInterfaceInvoke(const Svc::FpySequencer_PushTlmValDirective& directive)
  {
    ComponentIpcSerializableBuffer msg;
    Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

    // Serialize the message ID
    _status = msg.serializeFrom(static_cast<FwEnumStoreType>(INT_IF_DIRECTIVE_PUSHTLMVAL));
    FW_ASSERT (
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    // Fake port number to make message dequeue work
    _status = msg.serializeFrom(static_cast<FwIndexType>(0));
    FW_ASSERT (
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    _status = msg.serializeFrom(directive);
    FW_ASSERT(
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    // Send message
    Os::Queue::BlockingType _block = Os::Queue::NONBLOCKING;
    Os::Queue::Status qStatus = this->m_queue.send(msg, 6, _block);

    FW_ASSERT(
      qStatus == Os::Queue::OP_OK,
      static_cast<FwAssertArgType>(qStatus)
    );
  }

  void FpySequencerComponentBase ::
    directive_pushTlmValAndTime_internalInterfaceInvoke(const Svc::FpySequencer_PushTlmValAndTimeDirective& directive)
  {
    ComponentIpcSerializableBuffer msg;
    Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

    // Serialize the message ID
    _status = msg.serializeFrom(static_cast<FwEnumStoreType>(INT_IF_DIRECTIVE_PUSHTLMVALANDTIME));
    FW_ASSERT (
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    // Fake port number to make message dequeue work
    _status = msg.serializeFrom(static_cast<FwIndexType>(0));
    FW_ASSERT (
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    _status = msg.serializeFrom(directive);
    FW_ASSERT(
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    // Send message
    Os::Queue::BlockingType _block = Os::Queue::NONBLOCKING;
    Os::Queue::Status qStatus = this->m_queue.send(msg, 6, _block);

    FW_ASSERT(
      qStatus == Os::Queue::OP_OK,
      static_cast<FwAssertArgType>(qStatus)
    );
  }

  void FpySequencerComponentBase ::
    directive_pushVal_internalInterfaceInvoke(const Svc::FpySequencer_PushValDirective& directive)
  {
    ComponentIpcSerializableBuffer msg;
    Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

    // Serialize the message ID
    _status = msg.serializeFrom(static_cast<FwEnumStoreType>(INT_IF_DIRECTIVE_PUSHVAL));
    FW_ASSERT (
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    // Fake port number to make message dequeue work
    _status = msg.serializeFrom(static_cast<FwIndexType>(0));
    FW_ASSERT (
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    _status = msg.serializeFrom(directive);
    FW_ASSERT(
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    // Send message
    Os::Queue::BlockingType _block = Os::Queue::NONBLOCKING;
    Os::Queue::Status qStatus = this->m_queue.send(msg, 6, _block);

    FW_ASSERT(
      qStatus == Os::Queue::OP_OK,
      static_cast<FwAssertArgType>(qStatus)
    );
  }

  void FpySequencerComponentBase ::
    directive_setFlag_internalInterfaceInvoke(const Svc::FpySequencer_SetFlagDirective& directive)
  {
    ComponentIpcSerializableBuffer msg;
    Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

    // Serialize the message ID
    _status = msg.serializeFrom(static_cast<FwEnumStoreType>(INT_IF_DIRECTIVE_SETFLAG));
    FW_ASSERT (
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    // Fake port number to make message dequeue work
    _status = msg.serializeFrom(static_cast<FwIndexType>(0));
    FW_ASSERT (
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    _status = msg.serializeFrom(directive);
    FW_ASSERT(
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    // Send message
    Os::Queue::BlockingType _block = Os::Queue::NONBLOCKING;
    Os::Queue::Status qStatus = this->m_queue.send(msg, 6, _block);

    FW_ASSERT(
      qStatus == Os::Queue::OP_OK,
      static_cast<FwAssertArgType>(qStatus)
    );
  }

  void FpySequencerComponentBase ::
    directive_stackCmd_internalInterfaceInvoke(const Svc::FpySequencer_StackCmdDirective& directive)
  {
    ComponentIpcSerializableBuffer msg;
    Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

    // Serialize the message ID
    _status = msg.serializeFrom(static_cast<FwEnumStoreType>(INT_IF_DIRECTIVE_STACKCMD));
    FW_ASSERT (
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    // Fake port number to make message dequeue work
    _status = msg.serializeFrom(static_cast<FwIndexType>(0));
    FW_ASSERT (
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    _status = msg.serializeFrom(directive);
    FW_ASSERT(
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    // Send message
    Os::Queue::BlockingType _block = Os::Queue::NONBLOCKING;
    Os::Queue::Status qStatus = this->m_queue.send(msg, 6, _block);

    FW_ASSERT(
      qStatus == Os::Queue::OP_OK,
      static_cast<FwAssertArgType>(qStatus)
    );
  }

  void FpySequencerComponentBase ::
    directive_stackOp_internalInterfaceInvoke(const Svc::FpySequencer_StackOpDirective& directive)
  {
    ComponentIpcSerializableBuffer msg;
    Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

    // Serialize the message ID
    _status = msg.serializeFrom(static_cast<FwEnumStoreType>(INT_IF_DIRECTIVE_STACKOP));
    FW_ASSERT (
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    // Fake port number to make message dequeue work
    _status = msg.serializeFrom(static_cast<FwIndexType>(0));
    FW_ASSERT (
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    _status = msg.serializeFrom(directive);
    FW_ASSERT(
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    // Send message
    Os::Queue::BlockingType _block = Os::Queue::NONBLOCKING;
    Os::Queue::Status qStatus = this->m_queue.send(msg, 6, _block);

    FW_ASSERT(
      qStatus == Os::Queue::OP_OK,
      static_cast<FwAssertArgType>(qStatus)
    );
  }

  void FpySequencerComponentBase ::
    directive_store_internalInterfaceInvoke(const Svc::FpySequencer_StoreDirective& directive)
  {
    ComponentIpcSerializableBuffer msg;
    Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

    // Serialize the message ID
    _status = msg.serializeFrom(static_cast<FwEnumStoreType>(INT_IF_DIRECTIVE_STORE));
    FW_ASSERT (
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    // Fake port number to make message dequeue work
    _status = msg.serializeFrom(static_cast<FwIndexType>(0));
    FW_ASSERT (
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    _status = msg.serializeFrom(directive);
    FW_ASSERT(
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    // Send message
    Os::Queue::BlockingType _block = Os::Queue::NONBLOCKING;
    Os::Queue::Status qStatus = this->m_queue.send(msg, 6, _block);

    FW_ASSERT(
      qStatus == Os::Queue::OP_OK,
      static_cast<FwAssertArgType>(qStatus)
    );
  }

  void FpySequencerComponentBase ::
    directive_storeConstOffset_internalInterfaceInvoke(const Svc::FpySequencer_StoreConstOffsetDirective& directive)
  {
    ComponentIpcSerializableBuffer msg;
    Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

    // Serialize the message ID
    _status = msg.serializeFrom(static_cast<FwEnumStoreType>(INT_IF_DIRECTIVE_STORECONSTOFFSET));
    FW_ASSERT (
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    // Fake port number to make message dequeue work
    _status = msg.serializeFrom(static_cast<FwIndexType>(0));
    FW_ASSERT (
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    _status = msg.serializeFrom(directive);
    FW_ASSERT(
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    // Send message
    Os::Queue::BlockingType _block = Os::Queue::NONBLOCKING;
    Os::Queue::Status qStatus = this->m_queue.send(msg, 6, _block);

    FW_ASSERT(
      qStatus == Os::Queue::OP_OK,
      static_cast<FwAssertArgType>(qStatus)
    );
  }

  void FpySequencerComponentBase ::
    directive_waitAbs_internalInterfaceInvoke(const Svc::FpySequencer_WaitAbsDirective& directive)
  {
    ComponentIpcSerializableBuffer msg;
    Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

    // Serialize the message ID
    _status = msg.serializeFrom(static_cast<FwEnumStoreType>(INT_IF_DIRECTIVE_WAITABS));
    FW_ASSERT (
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    // Fake port number to make message dequeue work
    _status = msg.serializeFrom(static_cast<FwIndexType>(0));
    FW_ASSERT (
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    _status = msg.serializeFrom(directive);
    FW_ASSERT(
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    // Send message
    Os::Queue::BlockingType _block = Os::Queue::NONBLOCKING;
    Os::Queue::Status qStatus = this->m_queue.send(msg, 6, _block);

    FW_ASSERT(
      qStatus == Os::Queue::OP_OK,
      static_cast<FwAssertArgType>(qStatus)
    );
  }

  void FpySequencerComponentBase ::
    directive_waitRel_internalInterfaceInvoke(const Svc::FpySequencer_WaitRelDirective& directive)
  {
    ComponentIpcSerializableBuffer msg;
    Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

    // Serialize the message ID
    _status = msg.serializeFrom(static_cast<FwEnumStoreType>(INT_IF_DIRECTIVE_WAITREL));
    FW_ASSERT (
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    // Fake port number to make message dequeue work
    _status = msg.serializeFrom(static_cast<FwIndexType>(0));
    FW_ASSERT (
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    _status = msg.serializeFrom(directive);
    FW_ASSERT(
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    // Send message
    Os::Queue::BlockingType _block = Os::Queue::NONBLOCKING;
    Os::Queue::Status qStatus = this->m_queue.send(msg, 6, _block);

    FW_ASSERT(
      qStatus == Os::Queue::OP_OK,
      static_cast<FwAssertArgType>(qStatus)
    );
  }

  // ----------------------------------------------------------------------
  // State getter functions
  // ----------------------------------------------------------------------

  FpySequencerComponentBase::Svc_FpySequencer_SequencerStateMachine::State FpySequencerComponentBase ::
    sequencer_getState() const
  {
    return this->m_stateMachine_sequencer.getState();
  }

  // ----------------------------------------------------------------------
  // Signal send functions
  // ----------------------------------------------------------------------

  void FpySequencerComponentBase ::
    sequencer_sendSignal_cmd_VALIDATE(const Svc::FpySequencer_SequenceExecutionArgs& value)
  {
    ComponentIpcSerializableBuffer buffer;
    // Serialize the message type, port number, state ID, and signal
    this->sendSignalStart(SmId::sequencer, static_cast<FwEnumStoreType>(Svc_FpySequencer_SequencerStateMachine::Signal::cmd_VALIDATE), buffer);
    // Serialize the signal data
    const Fw::SerializeStatus status = buffer.serializeFrom(value);
    FW_ASSERT(status == Fw::FW_SERIALIZE_OK, static_cast<FwAssertArgType>(status));
    // Send the message and handle overflow
    this->sequencer_sendSignalFinish(buffer);
  }

  void FpySequencerComponentBase ::
    sequencer_sendSignal_cmd_RUN(const Svc::FpySequencer_SequenceExecutionArgs& value)
  {
    ComponentIpcSerializableBuffer buffer;
    // Serialize the message type, port number, state ID, and signal
    this->sendSignalStart(SmId::sequencer, static_cast<FwEnumStoreType>(Svc_FpySequencer_SequencerStateMachine::Signal::cmd_RUN), buffer);
    // Serialize the signal data
    const Fw::SerializeStatus status = buffer.serializeFrom(value);
    FW_ASSERT(status == Fw::FW_SERIALIZE_OK, static_cast<FwAssertArgType>(status));
    // Send the message and handle overflow
    this->sequencer_sendSignalFinish(buffer);
  }

  void FpySequencerComponentBase ::
    sequencer_sendSignal_cmd_RUN_VALIDATED(const Svc::FpySequencer_SequenceExecutionArgs& value)
  {
    ComponentIpcSerializableBuffer buffer;
    // Serialize the message type, port number, state ID, and signal
    this->sendSignalStart(SmId::sequencer, static_cast<FwEnumStoreType>(Svc_FpySequencer_SequencerStateMachine::Signal::cmd_RUN_VALIDATED), buffer);
    // Serialize the signal data
    const Fw::SerializeStatus status = buffer.serializeFrom(value);
    FW_ASSERT(status == Fw::FW_SERIALIZE_OK, static_cast<FwAssertArgType>(status));
    // Send the message and handle overflow
    this->sequencer_sendSignalFinish(buffer);
  }

  void FpySequencerComponentBase ::
    sequencer_sendSignal_cmd_CANCEL()
  {
    ComponentIpcSerializableBuffer buffer;
    // Serialize the message type, port number, state ID, and signal
    this->sendSignalStart(SmId::sequencer, static_cast<FwEnumStoreType>(Svc_FpySequencer_SequencerStateMachine::Signal::cmd_CANCEL), buffer);
    // Send the message and handle overflow
    this->sequencer_sendSignalFinish(buffer);
  }

  void FpySequencerComponentBase ::
    sequencer_sendSignal_cmd_SET_BREAKPOINT(const Svc::FpySequencer_BreakpointArgs& value)
  {
    ComponentIpcSerializableBuffer buffer;
    // Serialize the message type, port number, state ID, and signal
    this->sendSignalStart(SmId::sequencer, static_cast<FwEnumStoreType>(Svc_FpySequencer_SequencerStateMachine::Signal::cmd_SET_BREAKPOINT), buffer);
    // Serialize the signal data
    const Fw::SerializeStatus status = buffer.serializeFrom(value);
    FW_ASSERT(status == Fw::FW_SERIALIZE_OK, static_cast<FwAssertArgType>(status));
    // Send the message and handle overflow
    this->sequencer_sendSignalFinish(buffer);
  }

  void FpySequencerComponentBase ::
    sequencer_sendSignal_cmd_CLEAR_BREAKPOINT()
  {
    ComponentIpcSerializableBuffer buffer;
    // Serialize the message type, port number, state ID, and signal
    this->sendSignalStart(SmId::sequencer, static_cast<FwEnumStoreType>(Svc_FpySequencer_SequencerStateMachine::Signal::cmd_CLEAR_BREAKPOINT), buffer);
    // Send the message and handle overflow
    this->sequencer_sendSignalFinish(buffer);
  }

  void FpySequencerComponentBase ::
    sequencer_sendSignal_result_failure()
  {
    ComponentIpcSerializableBuffer buffer;
    // Serialize the message type, port number, state ID, and signal
    this->sendSignalStart(SmId::sequencer, static_cast<FwEnumStoreType>(Svc_FpySequencer_SequencerStateMachine::Signal::result_failure), buffer);
    // Send the message and handle overflow
    this->sequencer_sendSignalFinish(buffer);
  }

  void FpySequencerComponentBase ::
    sequencer_sendSignal_result_success()
  {
    ComponentIpcSerializableBuffer buffer;
    // Serialize the message type, port number, state ID, and signal
    this->sendSignalStart(SmId::sequencer, static_cast<FwEnumStoreType>(Svc_FpySequencer_SequencerStateMachine::Signal::result_success), buffer);
    // Send the message and handle overflow
    this->sequencer_sendSignalFinish(buffer);
  }

  void FpySequencerComponentBase ::
    sequencer_sendSignal_entered()
  {
    ComponentIpcSerializableBuffer buffer;
    // Serialize the message type, port number, state ID, and signal
    this->sendSignalStart(SmId::sequencer, static_cast<FwEnumStoreType>(Svc_FpySequencer_SequencerStateMachine::Signal::entered), buffer);
    // Send the message and handle overflow
    this->sequencer_sendSignalFinish(buffer);
  }

  void FpySequencerComponentBase ::
    sequencer_sendSignal_result_dispatchStatement_success()
  {
    ComponentIpcSerializableBuffer buffer;
    // Serialize the message type, port number, state ID, and signal
    this->sendSignalStart(SmId::sequencer, static_cast<FwEnumStoreType>(Svc_FpySequencer_SequencerStateMachine::Signal::result_dispatchStatement_success), buffer);
    // Send the message and handle overflow
    this->sequencer_sendSignalFinish(buffer);
  }

  void FpySequencerComponentBase ::
    sequencer_sendSignal_result_dispatchStatement_failure()
  {
    ComponentIpcSerializableBuffer buffer;
    // Serialize the message type, port number, state ID, and signal
    this->sendSignalStart(SmId::sequencer, static_cast<FwEnumStoreType>(Svc_FpySequencer_SequencerStateMachine::Signal::result_dispatchStatement_failure), buffer);
    // Send the message and handle overflow
    this->sequencer_sendSignalFinish(buffer);
  }

  void FpySequencerComponentBase ::
    sequencer_sendSignal_result_dispatchStatement_noMoreStatements()
  {
    ComponentIpcSerializableBuffer buffer;
    // Serialize the message type, port number, state ID, and signal
    this->sendSignalStart(SmId::sequencer, static_cast<FwEnumStoreType>(Svc_FpySequencer_SequencerStateMachine::Signal::result_dispatchStatement_noMoreStatements), buffer);
    // Send the message and handle overflow
    this->sequencer_sendSignalFinish(buffer);
  }

  void FpySequencerComponentBase ::
    sequencer_sendSignal_checkTimersIn()
  {
    ComponentIpcSerializableBuffer buffer;
    // Serialize the message type, port number, state ID, and signal
    this->sendSignalStart(SmId::sequencer, static_cast<FwEnumStoreType>(Svc_FpySequencer_SequencerStateMachine::Signal::checkTimersIn), buffer);
    // Send the message and handle overflow
    this->sequencer_sendSignalFinish(buffer);
  }

  void FpySequencerComponentBase ::
    sequencer_sendSignal_result_checkShouldWake_wakeup()
  {
    ComponentIpcSerializableBuffer buffer;
    // Serialize the message type, port number, state ID, and signal
    this->sendSignalStart(SmId::sequencer, static_cast<FwEnumStoreType>(Svc_FpySequencer_SequencerStateMachine::Signal::result_checkShouldWake_wakeup), buffer);
    // Send the message and handle overflow
    this->sequencer_sendSignalFinish(buffer);
  }

  void FpySequencerComponentBase ::
    sequencer_sendSignal_result_checkShouldWake_keepSleeping()
  {
    ComponentIpcSerializableBuffer buffer;
    // Serialize the message type, port number, state ID, and signal
    this->sendSignalStart(SmId::sequencer, static_cast<FwEnumStoreType>(Svc_FpySequencer_SequencerStateMachine::Signal::result_checkShouldWake_keepSleeping), buffer);
    // Send the message and handle overflow
    this->sequencer_sendSignalFinish(buffer);
  }

  void FpySequencerComponentBase ::
    sequencer_sendSignal_result_timeOpFailed()
  {
    ComponentIpcSerializableBuffer buffer;
    // Serialize the message type, port number, state ID, and signal
    this->sendSignalStart(SmId::sequencer, static_cast<FwEnumStoreType>(Svc_FpySequencer_SequencerStateMachine::Signal::result_timeOpFailed), buffer);
    // Send the message and handle overflow
    this->sequencer_sendSignalFinish(buffer);
  }

  void FpySequencerComponentBase ::
    sequencer_sendSignal_stmtResponse_beginSleep()
  {
    ComponentIpcSerializableBuffer buffer;
    // Serialize the message type, port number, state ID, and signal
    this->sendSignalStart(SmId::sequencer, static_cast<FwEnumStoreType>(Svc_FpySequencer_SequencerStateMachine::Signal::stmtResponse_beginSleep), buffer);
    // Send the message and handle overflow
    this->sequencer_sendSignalFinish(buffer);
  }

  void FpySequencerComponentBase ::
    sequencer_sendSignal_stmtResponse_success()
  {
    ComponentIpcSerializableBuffer buffer;
    // Serialize the message type, port number, state ID, and signal
    this->sendSignalStart(SmId::sequencer, static_cast<FwEnumStoreType>(Svc_FpySequencer_SequencerStateMachine::Signal::stmtResponse_success), buffer);
    // Send the message and handle overflow
    this->sequencer_sendSignalFinish(buffer);
  }

  void FpySequencerComponentBase ::
    sequencer_sendSignal_stmtResponse_failure()
  {
    ComponentIpcSerializableBuffer buffer;
    // Serialize the message type, port number, state ID, and signal
    this->sendSignalStart(SmId::sequencer, static_cast<FwEnumStoreType>(Svc_FpySequencer_SequencerStateMachine::Signal::stmtResponse_failure), buffer);
    // Send the message and handle overflow
    this->sequencer_sendSignalFinish(buffer);
  }

  void FpySequencerComponentBase ::
    sequencer_sendSignal_stmtResponse_unexpected()
  {
    ComponentIpcSerializableBuffer buffer;
    // Serialize the message type, port number, state ID, and signal
    this->sendSignalStart(SmId::sequencer, static_cast<FwEnumStoreType>(Svc_FpySequencer_SequencerStateMachine::Signal::stmtResponse_unexpected), buffer);
    // Send the message and handle overflow
    this->sequencer_sendSignalFinish(buffer);
  }

  void FpySequencerComponentBase ::
    sequencer_sendSignal_stmtResponse_keepWaiting()
  {
    ComponentIpcSerializableBuffer buffer;
    // Serialize the message type, port number, state ID, and signal
    this->sendSignalStart(SmId::sequencer, static_cast<FwEnumStoreType>(Svc_FpySequencer_SequencerStateMachine::Signal::stmtResponse_keepWaiting), buffer);
    // Send the message and handle overflow
    this->sequencer_sendSignalFinish(buffer);
  }

  void FpySequencerComponentBase ::
    sequencer_sendSignal_result_checkStatementTimeout_statementTimeout()
  {
    ComponentIpcSerializableBuffer buffer;
    // Serialize the message type, port number, state ID, and signal
    this->sendSignalStart(SmId::sequencer, static_cast<FwEnumStoreType>(Svc_FpySequencer_SequencerStateMachine::Signal::result_checkStatementTimeout_statementTimeout), buffer);
    // Send the message and handle overflow
    this->sequencer_sendSignalFinish(buffer);
  }

  void FpySequencerComponentBase ::
    sequencer_sendSignal_result_checkStatementTimeout_noTimeout()
  {
    ComponentIpcSerializableBuffer buffer;
    // Serialize the message type, port number, state ID, and signal
    this->sendSignalStart(SmId::sequencer, static_cast<FwEnumStoreType>(Svc_FpySequencer_SequencerStateMachine::Signal::result_checkStatementTimeout_noTimeout), buffer);
    // Send the message and handle overflow
    this->sequencer_sendSignalFinish(buffer);
  }

  void FpySequencerComponentBase ::
    sequencer_sendSignal_cmd_CONTINUE()
  {
    ComponentIpcSerializableBuffer buffer;
    // Serialize the message type, port number, state ID, and signal
    this->sendSignalStart(SmId::sequencer, static_cast<FwEnumStoreType>(Svc_FpySequencer_SequencerStateMachine::Signal::cmd_CONTINUE), buffer);
    // Send the message and handle overflow
    this->sequencer_sendSignalFinish(buffer);
  }

  void FpySequencerComponentBase ::
    sequencer_sendSignal_cmd_BREAK()
  {
    ComponentIpcSerializableBuffer buffer;
    // Serialize the message type, port number, state ID, and signal
    this->sendSignalStart(SmId::sequencer, static_cast<FwEnumStoreType>(Svc_FpySequencer_SequencerStateMachine::Signal::cmd_BREAK), buffer);
    // Send the message and handle overflow
    this->sequencer_sendSignalFinish(buffer);
  }

  void FpySequencerComponentBase ::
    sequencer_sendSignal_cmd_STEP()
  {
    ComponentIpcSerializableBuffer buffer;
    // Serialize the message type, port number, state ID, and signal
    this->sendSignalStart(SmId::sequencer, static_cast<FwEnumStoreType>(Svc_FpySequencer_SequencerStateMachine::Signal::cmd_STEP), buffer);
    // Send the message and handle overflow
    this->sequencer_sendSignalFinish(buffer);
  }

  // ----------------------------------------------------------------------
  // Command response
  // ----------------------------------------------------------------------

  void FpySequencerComponentBase ::
    cmdResponse_out(
        FwOpcodeType opCode,
        U32 cmdSeq,
        Fw::CmdResponse response
    )
  {
    FW_ASSERT(this->m_cmdResponseOut_OutputPort[0].isConnected());
    this->m_cmdResponseOut_OutputPort[0].invoke(opCode, cmdSeq, response);
  }

  // ----------------------------------------------------------------------
  // Command handler base-class functions
  //
  // Call these functions directly to bypass the command input port
  // ----------------------------------------------------------------------

  void FpySequencerComponentBase ::
    RUN_cmdHandlerBase(
        FwOpcodeType opCode,
        U32 cmdSeq,
        Fw::CmdArgBuffer& args
    )
  {
    // Call pre-message hook
    this->RUN_preMsgHook(opCode,cmdSeq);

    // Defer deserializing arguments to the message dispatcher
    // to avoid deserializing and reserializing just for IPC
    ComponentIpcSerializableBuffer msg;
    Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

    // Serialize for IPC
    _status = msg.serializeFrom(static_cast<FwEnumStoreType>(CMD_RUN));
    FW_ASSERT (
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    // Fake port number to make message dequeue work
    FwIndexType port = 0;

    _status = msg.serializeFrom(port);
    FW_ASSERT (
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    _status = msg.serializeFrom(opCode);
    FW_ASSERT (
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    _status = msg.serializeFrom(cmdSeq);
    FW_ASSERT (
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    _status = msg.serializeFrom(args);
    FW_ASSERT (
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    // Send message
    Os::Queue::BlockingType _block = Os::Queue::NONBLOCKING;
    Os::Queue::Status qStatus = this->m_queue.send(msg, 7, _block);

    FW_ASSERT(
      qStatus == Os::Queue::OP_OK,
      static_cast<FwAssertArgType>(qStatus)
    );
  }

  void FpySequencerComponentBase ::
    VALIDATE_cmdHandlerBase(
        FwOpcodeType opCode,
        U32 cmdSeq,
        Fw::CmdArgBuffer& args
    )
  {
    // Call pre-message hook
    this->VALIDATE_preMsgHook(opCode,cmdSeq);

    // Defer deserializing arguments to the message dispatcher
    // to avoid deserializing and reserializing just for IPC
    ComponentIpcSerializableBuffer msg;
    Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

    // Serialize for IPC
    _status = msg.serializeFrom(static_cast<FwEnumStoreType>(CMD_VALIDATE));
    FW_ASSERT (
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    // Fake port number to make message dequeue work
    FwIndexType port = 0;

    _status = msg.serializeFrom(port);
    FW_ASSERT (
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    _status = msg.serializeFrom(opCode);
    FW_ASSERT (
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    _status = msg.serializeFrom(cmdSeq);
    FW_ASSERT (
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    _status = msg.serializeFrom(args);
    FW_ASSERT (
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    // Send message
    Os::Queue::BlockingType _block = Os::Queue::NONBLOCKING;
    Os::Queue::Status qStatus = this->m_queue.send(msg, 7, _block);

    FW_ASSERT(
      qStatus == Os::Queue::OP_OK,
      static_cast<FwAssertArgType>(qStatus)
    );
  }

  void FpySequencerComponentBase ::
    RUN_VALIDATED_cmdHandlerBase(
        FwOpcodeType opCode,
        U32 cmdSeq,
        Fw::CmdArgBuffer& args
    )
  {
    // Call pre-message hook
    this->RUN_VALIDATED_preMsgHook(opCode,cmdSeq);

    // Defer deserializing arguments to the message dispatcher
    // to avoid deserializing and reserializing just for IPC
    ComponentIpcSerializableBuffer msg;
    Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

    // Serialize for IPC
    _status = msg.serializeFrom(static_cast<FwEnumStoreType>(CMD_RUN_VALIDATED));
    FW_ASSERT (
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    // Fake port number to make message dequeue work
    FwIndexType port = 0;

    _status = msg.serializeFrom(port);
    FW_ASSERT (
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    _status = msg.serializeFrom(opCode);
    FW_ASSERT (
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    _status = msg.serializeFrom(cmdSeq);
    FW_ASSERT (
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    _status = msg.serializeFrom(args);
    FW_ASSERT (
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    // Send message
    Os::Queue::BlockingType _block = Os::Queue::NONBLOCKING;
    Os::Queue::Status qStatus = this->m_queue.send(msg, 7, _block);

    FW_ASSERT(
      qStatus == Os::Queue::OP_OK,
      static_cast<FwAssertArgType>(qStatus)
    );
  }

  void FpySequencerComponentBase ::
    CANCEL_cmdHandlerBase(
        FwOpcodeType opCode,
        U32 cmdSeq,
        Fw::CmdArgBuffer& args
    )
  {
    // Call pre-message hook
    this->CANCEL_preMsgHook(opCode,cmdSeq);

    // Defer deserializing arguments to the message dispatcher
    // to avoid deserializing and reserializing just for IPC
    ComponentIpcSerializableBuffer msg;
    Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

    // Serialize for IPC
    _status = msg.serializeFrom(static_cast<FwEnumStoreType>(CMD_CANCEL));
    FW_ASSERT (
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    // Fake port number to make message dequeue work
    FwIndexType port = 0;

    _status = msg.serializeFrom(port);
    FW_ASSERT (
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    _status = msg.serializeFrom(opCode);
    FW_ASSERT (
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    _status = msg.serializeFrom(cmdSeq);
    FW_ASSERT (
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    _status = msg.serializeFrom(args);
    FW_ASSERT (
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    // Send message
    Os::Queue::BlockingType _block = Os::Queue::NONBLOCKING;
    Os::Queue::Status qStatus = this->m_queue.send(msg, 8, _block);

    FW_ASSERT(
      qStatus == Os::Queue::OP_OK,
      static_cast<FwAssertArgType>(qStatus)
    );
  }

  void FpySequencerComponentBase ::
    SET_BREAKPOINT_cmdHandlerBase(
        FwOpcodeType opCode,
        U32 cmdSeq,
        Fw::CmdArgBuffer& args
    )
  {
    // Call pre-message hook
    this->SET_BREAKPOINT_preMsgHook(opCode,cmdSeq);

    // Defer deserializing arguments to the message dispatcher
    // to avoid deserializing and reserializing just for IPC
    ComponentIpcSerializableBuffer msg;
    Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

    // Serialize for IPC
    _status = msg.serializeFrom(static_cast<FwEnumStoreType>(CMD_SET_BREAKPOINT));
    FW_ASSERT (
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    // Fake port number to make message dequeue work
    FwIndexType port = 0;

    _status = msg.serializeFrom(port);
    FW_ASSERT (
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    _status = msg.serializeFrom(opCode);
    FW_ASSERT (
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    _status = msg.serializeFrom(cmdSeq);
    FW_ASSERT (
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    _status = msg.serializeFrom(args);
    FW_ASSERT (
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    // Send message
    Os::Queue::BlockingType _block = Os::Queue::NONBLOCKING;
    Os::Queue::Status qStatus = this->m_queue.send(msg, 7, _block);

    FW_ASSERT(
      qStatus == Os::Queue::OP_OK,
      static_cast<FwAssertArgType>(qStatus)
    );
  }

  void FpySequencerComponentBase ::
    BREAK_cmdHandlerBase(
        FwOpcodeType opCode,
        U32 cmdSeq,
        Fw::CmdArgBuffer& args
    )
  {
    // Call pre-message hook
    this->BREAK_preMsgHook(opCode,cmdSeq);

    // Defer deserializing arguments to the message dispatcher
    // to avoid deserializing and reserializing just for IPC
    ComponentIpcSerializableBuffer msg;
    Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

    // Serialize for IPC
    _status = msg.serializeFrom(static_cast<FwEnumStoreType>(CMD_BREAK));
    FW_ASSERT (
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    // Fake port number to make message dequeue work
    FwIndexType port = 0;

    _status = msg.serializeFrom(port);
    FW_ASSERT (
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    _status = msg.serializeFrom(opCode);
    FW_ASSERT (
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    _status = msg.serializeFrom(cmdSeq);
    FW_ASSERT (
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    _status = msg.serializeFrom(args);
    FW_ASSERT (
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    // Send message
    Os::Queue::BlockingType _block = Os::Queue::NONBLOCKING;
    Os::Queue::Status qStatus = this->m_queue.send(msg, 7, _block);

    FW_ASSERT(
      qStatus == Os::Queue::OP_OK,
      static_cast<FwAssertArgType>(qStatus)
    );
  }

  void FpySequencerComponentBase ::
    CONTINUE_cmdHandlerBase(
        FwOpcodeType opCode,
        U32 cmdSeq,
        Fw::CmdArgBuffer& args
    )
  {
    // Call pre-message hook
    this->CONTINUE_preMsgHook(opCode,cmdSeq);

    // Defer deserializing arguments to the message dispatcher
    // to avoid deserializing and reserializing just for IPC
    ComponentIpcSerializableBuffer msg;
    Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

    // Serialize for IPC
    _status = msg.serializeFrom(static_cast<FwEnumStoreType>(CMD_CONTINUE));
    FW_ASSERT (
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    // Fake port number to make message dequeue work
    FwIndexType port = 0;

    _status = msg.serializeFrom(port);
    FW_ASSERT (
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    _status = msg.serializeFrom(opCode);
    FW_ASSERT (
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    _status = msg.serializeFrom(cmdSeq);
    FW_ASSERT (
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    _status = msg.serializeFrom(args);
    FW_ASSERT (
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    // Send message
    Os::Queue::BlockingType _block = Os::Queue::NONBLOCKING;
    Os::Queue::Status qStatus = this->m_queue.send(msg, 7, _block);

    FW_ASSERT(
      qStatus == Os::Queue::OP_OK,
      static_cast<FwAssertArgType>(qStatus)
    );
  }

  void FpySequencerComponentBase ::
    CLEAR_BREAKPOINT_cmdHandlerBase(
        FwOpcodeType opCode,
        U32 cmdSeq,
        Fw::CmdArgBuffer& args
    )
  {
    // Call pre-message hook
    this->CLEAR_BREAKPOINT_preMsgHook(opCode,cmdSeq);

    // Defer deserializing arguments to the message dispatcher
    // to avoid deserializing and reserializing just for IPC
    ComponentIpcSerializableBuffer msg;
    Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

    // Serialize for IPC
    _status = msg.serializeFrom(static_cast<FwEnumStoreType>(CMD_CLEAR_BREAKPOINT));
    FW_ASSERT (
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    // Fake port number to make message dequeue work
    FwIndexType port = 0;

    _status = msg.serializeFrom(port);
    FW_ASSERT (
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    _status = msg.serializeFrom(opCode);
    FW_ASSERT (
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    _status = msg.serializeFrom(cmdSeq);
    FW_ASSERT (
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    _status = msg.serializeFrom(args);
    FW_ASSERT (
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    // Send message
    Os::Queue::BlockingType _block = Os::Queue::NONBLOCKING;
    Os::Queue::Status qStatus = this->m_queue.send(msg, 7, _block);

    FW_ASSERT(
      qStatus == Os::Queue::OP_OK,
      static_cast<FwAssertArgType>(qStatus)
    );
  }

  void FpySequencerComponentBase ::
    STEP_cmdHandlerBase(
        FwOpcodeType opCode,
        U32 cmdSeq,
        Fw::CmdArgBuffer& args
    )
  {
    // Call pre-message hook
    this->STEP_preMsgHook(opCode,cmdSeq);

    // Defer deserializing arguments to the message dispatcher
    // to avoid deserializing and reserializing just for IPC
    ComponentIpcSerializableBuffer msg;
    Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

    // Serialize for IPC
    _status = msg.serializeFrom(static_cast<FwEnumStoreType>(CMD_STEP));
    FW_ASSERT (
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    // Fake port number to make message dequeue work
    FwIndexType port = 0;

    _status = msg.serializeFrom(port);
    FW_ASSERT (
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    _status = msg.serializeFrom(opCode);
    FW_ASSERT (
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    _status = msg.serializeFrom(cmdSeq);
    FW_ASSERT (
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    _status = msg.serializeFrom(args);
    FW_ASSERT (
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    // Send message
    Os::Queue::BlockingType _block = Os::Queue::NONBLOCKING;
    Os::Queue::Status qStatus = this->m_queue.send(msg, 7, _block);

    FW_ASSERT(
      qStatus == Os::Queue::OP_OK,
      static_cast<FwAssertArgType>(qStatus)
    );
  }

  void FpySequencerComponentBase ::
    SET_FLAG_cmdHandlerBase(
        FwOpcodeType opCode,
        U32 cmdSeq,
        Fw::CmdArgBuffer& args
    )
  {
    // Call pre-message hook
    this->SET_FLAG_preMsgHook(opCode,cmdSeq);

    // Defer deserializing arguments to the message dispatcher
    // to avoid deserializing and reserializing just for IPC
    ComponentIpcSerializableBuffer msg;
    Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

    // Serialize for IPC
    _status = msg.serializeFrom(static_cast<FwEnumStoreType>(CMD_SET_FLAG));
    FW_ASSERT (
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    // Fake port number to make message dequeue work
    FwIndexType port = 0;

    _status = msg.serializeFrom(port);
    FW_ASSERT (
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    _status = msg.serializeFrom(opCode);
    FW_ASSERT (
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    _status = msg.serializeFrom(cmdSeq);
    FW_ASSERT (
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    _status = msg.serializeFrom(args);
    FW_ASSERT (
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    // Send message
    Os::Queue::BlockingType _block = Os::Queue::NONBLOCKING;
    Os::Queue::Status qStatus = this->m_queue.send(msg, 7, _block);

    FW_ASSERT(
      qStatus == Os::Queue::OP_OK,
      static_cast<FwAssertArgType>(qStatus)
    );
  }

  void FpySequencerComponentBase ::
    DUMP_STACK_TO_FILE_cmdHandlerBase(
        FwOpcodeType opCode,
        U32 cmdSeq,
        Fw::CmdArgBuffer& args
    )
  {
    // Call pre-message hook
    this->DUMP_STACK_TO_FILE_preMsgHook(opCode,cmdSeq);

    // Defer deserializing arguments to the message dispatcher
    // to avoid deserializing and reserializing just for IPC
    ComponentIpcSerializableBuffer msg;
    Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

    // Serialize for IPC
    _status = msg.serializeFrom(static_cast<FwEnumStoreType>(CMD_DUMP_STACK_TO_FILE));
    FW_ASSERT (
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    // Fake port number to make message dequeue work
    FwIndexType port = 0;

    _status = msg.serializeFrom(port);
    FW_ASSERT (
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    _status = msg.serializeFrom(opCode);
    FW_ASSERT (
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    _status = msg.serializeFrom(cmdSeq);
    FW_ASSERT (
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    _status = msg.serializeFrom(args);
    FW_ASSERT (
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    // Send message
    Os::Queue::BlockingType _block = Os::Queue::NONBLOCKING;
    Os::Queue::Status qStatus = this->m_queue.send(msg, 7, _block);

    FW_ASSERT(
      qStatus == Os::Queue::OP_OK,
      static_cast<FwAssertArgType>(qStatus)
    );
  }

  // ----------------------------------------------------------------------
  // Pre-message hooks for async commands
  //
  // Each of these functions is invoked just before processing the
  // corresponding command. By default they do nothing. You can
  // override them to provide specific pre-command behavior.
  // ----------------------------------------------------------------------

  void FpySequencerComponentBase ::
    RUN_preMsgHook(
        FwOpcodeType opCode,
        U32 cmdSeq
    )
  {
    // Defaults to no-op; can be overridden
    (void) opCode;
    (void) cmdSeq;
  }

  void FpySequencerComponentBase ::
    VALIDATE_preMsgHook(
        FwOpcodeType opCode,
        U32 cmdSeq
    )
  {
    // Defaults to no-op; can be overridden
    (void) opCode;
    (void) cmdSeq;
  }

  void FpySequencerComponentBase ::
    RUN_VALIDATED_preMsgHook(
        FwOpcodeType opCode,
        U32 cmdSeq
    )
  {
    // Defaults to no-op; can be overridden
    (void) opCode;
    (void) cmdSeq;
  }

  void FpySequencerComponentBase ::
    CANCEL_preMsgHook(
        FwOpcodeType opCode,
        U32 cmdSeq
    )
  {
    // Defaults to no-op; can be overridden
    (void) opCode;
    (void) cmdSeq;
  }

  void FpySequencerComponentBase ::
    SET_BREAKPOINT_preMsgHook(
        FwOpcodeType opCode,
        U32 cmdSeq
    )
  {
    // Defaults to no-op; can be overridden
    (void) opCode;
    (void) cmdSeq;
  }

  void FpySequencerComponentBase ::
    BREAK_preMsgHook(
        FwOpcodeType opCode,
        U32 cmdSeq
    )
  {
    // Defaults to no-op; can be overridden
    (void) opCode;
    (void) cmdSeq;
  }

  void FpySequencerComponentBase ::
    CONTINUE_preMsgHook(
        FwOpcodeType opCode,
        U32 cmdSeq
    )
  {
    // Defaults to no-op; can be overridden
    (void) opCode;
    (void) cmdSeq;
  }

  void FpySequencerComponentBase ::
    CLEAR_BREAKPOINT_preMsgHook(
        FwOpcodeType opCode,
        U32 cmdSeq
    )
  {
    // Defaults to no-op; can be overridden
    (void) opCode;
    (void) cmdSeq;
  }

  void FpySequencerComponentBase ::
    STEP_preMsgHook(
        FwOpcodeType opCode,
        U32 cmdSeq
    )
  {
    // Defaults to no-op; can be overridden
    (void) opCode;
    (void) cmdSeq;
  }

  void FpySequencerComponentBase ::
    SET_FLAG_preMsgHook(
        FwOpcodeType opCode,
        U32 cmdSeq
    )
  {
    // Defaults to no-op; can be overridden
    (void) opCode;
    (void) cmdSeq;
  }

  void FpySequencerComponentBase ::
    DUMP_STACK_TO_FILE_preMsgHook(
        FwOpcodeType opCode,
        U32 cmdSeq
    )
  {
    // Defaults to no-op; can be overridden
    (void) opCode;
    (void) cmdSeq;
  }

  // ----------------------------------------------------------------------
  // Event logging functions
  // ----------------------------------------------------------------------

  void FpySequencerComponentBase ::
    log_WARNING_HI_InvalidCommand(I32 state) const
  {
    // Get the time
    Fw::Time _logTime;
    if (this->m_timeCaller_OutputPort[0].isConnected()) {
      this->m_timeCaller_OutputPort[0].invoke(_logTime);
    }

    FwEventIdType _id = static_cast<FwEventIdType>(0);

    _id = this->getIdBase() + EVENTID_INVALIDCOMMAND;

    // Emit the event on the log port
    if (this->m_logOut_OutputPort[0].isConnected()) {
      Fw::LogBuffer _logBuff;
      Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

#if FW_AMPCS_COMPATIBLE
      // Serialize the number of arguments
      _status = _logBuff.serializeFrom(static_cast<U8>(1));
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
#endif

#if FW_AMPCS_COMPATIBLE
      // Serialize the argument size
      _status = _logBuff.serializeFrom(
        static_cast<U8>(sizeof(I32))
      );
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
#endif
      _status = _logBuff.serializeFrom(state);
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );

      this->m_logOut_OutputPort[0].invoke(
        _id,
        _logTime,
        Fw::LogSeverity::WARNING_HI,
        _logBuff
      );
    }

    // Emit the event on the text log port
#if FW_ENABLE_TEXT_LOGGING
    if (this->m_logTextOut_OutputPort[0].isConnected()) {
#if FW_OBJECT_NAMES == 1
      const char* _formatString =
        "(%s) %s: Cannot execute command in state %" PRIi32 "";
#else
      const char* _formatString =
        "%s: Cannot execute command in state %" PRIi32 "";
#endif

      Fw::TextLogString _logString;
      _logString.format(
        _formatString,
#if FW_OBJECT_NAMES == 1
        this->m_objName.toChar(),
#endif
        "InvalidCommand ",
        state
      );

      this->m_logTextOut_OutputPort[0].invoke(
        _id,
        _logTime,
        Fw::LogSeverity::WARNING_HI,
        _logString
      );
    }
#endif
  }

  void FpySequencerComponentBase ::
    log_WARNING_HI_InvalidSeqRunCall(I32 state) const
  {
    // Get the time
    Fw::Time _logTime;
    if (this->m_timeCaller_OutputPort[0].isConnected()) {
      this->m_timeCaller_OutputPort[0].invoke(_logTime);
    }

    FwEventIdType _id = static_cast<FwEventIdType>(0);

    _id = this->getIdBase() + EVENTID_INVALIDSEQRUNCALL;

    // Emit the event on the log port
    if (this->m_logOut_OutputPort[0].isConnected()) {
      Fw::LogBuffer _logBuff;
      Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

#if FW_AMPCS_COMPATIBLE
      // Serialize the number of arguments
      _status = _logBuff.serializeFrom(static_cast<U8>(1));
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
#endif

#if FW_AMPCS_COMPATIBLE
      // Serialize the argument size
      _status = _logBuff.serializeFrom(
        static_cast<U8>(sizeof(I32))
      );
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
#endif
      _status = _logBuff.serializeFrom(state);
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );

      this->m_logOut_OutputPort[0].invoke(
        _id,
        _logTime,
        Fw::LogSeverity::WARNING_HI,
        _logBuff
      );
    }

    // Emit the event on the text log port
#if FW_ENABLE_TEXT_LOGGING
    if (this->m_logTextOut_OutputPort[0].isConnected()) {
#if FW_OBJECT_NAMES == 1
      const char* _formatString =
        "(%s) %s: Cannot run sequence from a port in state %" PRIi32 "";
#else
      const char* _formatString =
        "%s: Cannot run sequence from a port in state %" PRIi32 "";
#endif

      Fw::TextLogString _logString;
      _logString.format(
        _formatString,
#if FW_OBJECT_NAMES == 1
        this->m_objName.toChar(),
#endif
        "InvalidSeqRunCall ",
        state
      );

      this->m_logTextOut_OutputPort[0].invoke(
        _id,
        _logTime,
        Fw::LogSeverity::WARNING_HI,
        _logString
      );
    }
#endif
  }

  void FpySequencerComponentBase ::
    log_WARNING_HI_FileOpenError(
        const Fw::StringBase& filePath,
        I32 errorCode
    ) const
  {
    // Get the time
    Fw::Time _logTime;
    if (this->m_timeCaller_OutputPort[0].isConnected()) {
      this->m_timeCaller_OutputPort[0].invoke(_logTime);
    }

    FwEventIdType _id = static_cast<FwEventIdType>(0);

    _id = this->getIdBase() + EVENTID_FILEOPENERROR;

    // Emit the event on the log port
    if (this->m_logOut_OutputPort[0].isConnected()) {
      Fw::LogBuffer _logBuff;
      Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

#if FW_AMPCS_COMPATIBLE
      // Serialize the number of arguments
      _status = _logBuff.serializeFrom(static_cast<U8>(2));
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
#endif

      _status = filePath.serializeTo(_logBuff, FW_MIN(FW_LOG_STRING_MAX_SIZE, 80));
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );

#if FW_AMPCS_COMPATIBLE
      // Serialize the argument size
      _status = _logBuff.serializeFrom(
        static_cast<U8>(sizeof(I32))
      );
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
#endif
      _status = _logBuff.serializeFrom(errorCode);
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );

      this->m_logOut_OutputPort[0].invoke(
        _id,
        _logTime,
        Fw::LogSeverity::WARNING_HI,
        _logBuff
      );
    }

    // Emit the event on the text log port
#if FW_ENABLE_TEXT_LOGGING
    if (this->m_logTextOut_OutputPort[0].isConnected()) {
#if FW_OBJECT_NAMES == 1
      const char* _formatString =
        "(%s) %s: File open error encountered while opening %s: %" PRIi32 "";
#else
      const char* _formatString =
        "%s: File open error encountered while opening %s: %" PRIi32 "";
#endif

      Fw::TextLogString _logString;
      _logString.format(
        _formatString,
#if FW_OBJECT_NAMES == 1
        this->m_objName.toChar(),
#endif
        "FileOpenError ",
        filePath.toChar(),
        errorCode
      );

      this->m_logTextOut_OutputPort[0].invoke(
        _id,
        _logTime,
        Fw::LogSeverity::WARNING_HI,
        _logString
      );
    }
#endif
  }

  void FpySequencerComponentBase ::
    log_WARNING_HI_FileWriteError(
        FwSizeType writeSize,
        const Fw::StringBase& filePath,
        I32 errorCode
    ) const
  {
    // Get the time
    Fw::Time _logTime;
    if (this->m_timeCaller_OutputPort[0].isConnected()) {
      this->m_timeCaller_OutputPort[0].invoke(_logTime);
    }

    FwEventIdType _id = static_cast<FwEventIdType>(0);

    _id = this->getIdBase() + EVENTID_FILEWRITEERROR;

    // Emit the event on the log port
    if (this->m_logOut_OutputPort[0].isConnected()) {
      Fw::LogBuffer _logBuff;
      Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

#if FW_AMPCS_COMPATIBLE
      // Serialize the number of arguments
      _status = _logBuff.serializeFrom(static_cast<U8>(3));
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
#endif

#if FW_AMPCS_COMPATIBLE
      // Serialize the argument size
      _status = _logBuff.serializeFrom(
        static_cast<U8>(sizeof(FwSizeType))
      );
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
#endif
      _status = _logBuff.serializeFrom(writeSize);
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );

      _status = filePath.serializeTo(_logBuff, FW_MIN(FW_LOG_STRING_MAX_SIZE, 80));
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );

#if FW_AMPCS_COMPATIBLE
      // Serialize the argument size
      _status = _logBuff.serializeFrom(
        static_cast<U8>(sizeof(I32))
      );
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
#endif
      _status = _logBuff.serializeFrom(errorCode);
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );

      this->m_logOut_OutputPort[0].invoke(
        _id,
        _logTime,
        Fw::LogSeverity::WARNING_HI,
        _logBuff
      );
    }

    // Emit the event on the text log port
#if FW_ENABLE_TEXT_LOGGING
    if (this->m_logTextOut_OutputPort[0].isConnected()) {
#if FW_OBJECT_NAMES == 1
      const char* _formatString =
        "(%s) %s: File write error encountered while writing %" PRIu64 " bytes to %s: %" PRIi32 "";
#else
      const char* _formatString =
        "%s: File write error encountered while writing %" PRIu64 " bytes to %s: %" PRIi32 "";
#endif

      Fw::TextLogString _logString;
      _logString.format(
        _formatString,
#if FW_OBJECT_NAMES == 1
        this->m_objName.toChar(),
#endif
        "FileWriteError ",
        writeSize,
        filePath.toChar(),
        errorCode
      );

      this->m_logTextOut_OutputPort[0].invoke(
        _id,
        _logTime,
        Fw::LogSeverity::WARNING_HI,
        _logString
      );
    }
#endif
  }

  void FpySequencerComponentBase ::
    log_WARNING_HI_FileReadError(
        Svc::FpySequencer_FileReadStage readStage,
        const Fw::StringBase& filePath,
        I32 errorCode
    ) const
  {
    // Get the time
    Fw::Time _logTime;
    if (this->m_timeCaller_OutputPort[0].isConnected()) {
      this->m_timeCaller_OutputPort[0].invoke(_logTime);
    }

    FwEventIdType _id = static_cast<FwEventIdType>(0);

    _id = this->getIdBase() + EVENTID_FILEREADERROR;

    // Emit the event on the log port
    if (this->m_logOut_OutputPort[0].isConnected()) {
      Fw::LogBuffer _logBuff;
      Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

#if FW_AMPCS_COMPATIBLE
      // Serialize the number of arguments
      _status = _logBuff.serializeFrom(static_cast<U8>(3));
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
#endif

#if FW_AMPCS_COMPATIBLE
      // Serialize the argument size
      _status = _logBuff.serializeFrom(
        static_cast<U8>(Svc::FpySequencer_FileReadStage::SERIALIZED_SIZE)
      );
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
#endif
      _status = _logBuff.serializeFrom(readStage);
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );

      _status = filePath.serializeTo(_logBuff, FW_MIN(FW_LOG_STRING_MAX_SIZE, 80));
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );

#if FW_AMPCS_COMPATIBLE
      // Serialize the argument size
      _status = _logBuff.serializeFrom(
        static_cast<U8>(sizeof(I32))
      );
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
#endif
      _status = _logBuff.serializeFrom(errorCode);
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );

      this->m_logOut_OutputPort[0].invoke(
        _id,
        _logTime,
        Fw::LogSeverity::WARNING_HI,
        _logBuff
      );
    }

    // Emit the event on the text log port
#if FW_ENABLE_TEXT_LOGGING
    if (this->m_logTextOut_OutputPort[0].isConnected()) {
#if FW_OBJECT_NAMES == 1
      const char* _formatString =
        "(%s) %s: File read error encountered while reading %s of file %s: %" PRIi32 "";
#else
      const char* _formatString =
        "%s: File read error encountered while reading %s of file %s: %" PRIi32 "";
#endif

      Fw::String readStageStr;
      readStage.toString(readStageStr);

      Fw::TextLogString _logString;
      _logString.format(
        _formatString,
#if FW_OBJECT_NAMES == 1
        this->m_objName.toChar(),
#endif
        "FileReadError ",
        readStageStr.toChar(),
        filePath.toChar(),
        errorCode
      );

      this->m_logTextOut_OutputPort[0].invoke(
        _id,
        _logTime,
        Fw::LogSeverity::WARNING_HI,
        _logString
      );
    }
#endif
  }

  void FpySequencerComponentBase ::
    log_WARNING_HI_EndOfFileError(
        Svc::FpySequencer_FileReadStage readStage,
        const Fw::StringBase& filePath
    ) const
  {
    // Get the time
    Fw::Time _logTime;
    if (this->m_timeCaller_OutputPort[0].isConnected()) {
      this->m_timeCaller_OutputPort[0].invoke(_logTime);
    }

    FwEventIdType _id = static_cast<FwEventIdType>(0);

    _id = this->getIdBase() + EVENTID_ENDOFFILEERROR;

    // Emit the event on the log port
    if (this->m_logOut_OutputPort[0].isConnected()) {
      Fw::LogBuffer _logBuff;
      Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

#if FW_AMPCS_COMPATIBLE
      // Serialize the number of arguments
      _status = _logBuff.serializeFrom(static_cast<U8>(2));
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
#endif

#if FW_AMPCS_COMPATIBLE
      // Serialize the argument size
      _status = _logBuff.serializeFrom(
        static_cast<U8>(Svc::FpySequencer_FileReadStage::SERIALIZED_SIZE)
      );
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
#endif
      _status = _logBuff.serializeFrom(readStage);
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );

      _status = filePath.serializeTo(_logBuff, FW_MIN(FW_LOG_STRING_MAX_SIZE, 80));
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );

      this->m_logOut_OutputPort[0].invoke(
        _id,
        _logTime,
        Fw::LogSeverity::WARNING_HI,
        _logBuff
      );
    }

    // Emit the event on the text log port
#if FW_ENABLE_TEXT_LOGGING
    if (this->m_logTextOut_OutputPort[0].isConnected()) {
#if FW_OBJECT_NAMES == 1
      const char* _formatString =
        "(%s) %s: End of file encountered unexpectedly while reading %s of file %s";
#else
      const char* _formatString =
        "%s: End of file encountered unexpectedly while reading %s of file %s";
#endif

      Fw::String readStageStr;
      readStage.toString(readStageStr);

      Fw::TextLogString _logString;
      _logString.format(
        _formatString,
#if FW_OBJECT_NAMES == 1
        this->m_objName.toChar(),
#endif
        "EndOfFileError ",
        readStageStr.toChar(),
        filePath.toChar()
      );

      this->m_logTextOut_OutputPort[0].invoke(
        _id,
        _logTime,
        Fw::LogSeverity::WARNING_HI,
        _logString
      );
    }
#endif
  }

  void FpySequencerComponentBase ::
    log_WARNING_HI_FileReadDeserializeError(
        Svc::FpySequencer_FileReadStage readStage,
        const Fw::StringBase& filePath,
        I32 errorCode,
        U64 buffLeft,
        U64 buffLength
    ) const
  {
    // Get the time
    Fw::Time _logTime;
    if (this->m_timeCaller_OutputPort[0].isConnected()) {
      this->m_timeCaller_OutputPort[0].invoke(_logTime);
    }

    FwEventIdType _id = static_cast<FwEventIdType>(0);

    _id = this->getIdBase() + EVENTID_FILEREADDESERIALIZEERROR;

    // Emit the event on the log port
    if (this->m_logOut_OutputPort[0].isConnected()) {
      Fw::LogBuffer _logBuff;
      Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

#if FW_AMPCS_COMPATIBLE
      // Serialize the number of arguments
      _status = _logBuff.serializeFrom(static_cast<U8>(5));
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
#endif

#if FW_AMPCS_COMPATIBLE
      // Serialize the argument size
      _status = _logBuff.serializeFrom(
        static_cast<U8>(Svc::FpySequencer_FileReadStage::SERIALIZED_SIZE)
      );
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
#endif
      _status = _logBuff.serializeFrom(readStage);
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );

      _status = filePath.serializeTo(_logBuff, FW_MIN(FW_LOG_STRING_MAX_SIZE, 80));
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );

#if FW_AMPCS_COMPATIBLE
      // Serialize the argument size
      _status = _logBuff.serializeFrom(
        static_cast<U8>(sizeof(I32))
      );
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
#endif
      _status = _logBuff.serializeFrom(errorCode);
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );

#if FW_AMPCS_COMPATIBLE
      // Serialize the argument size
      _status = _logBuff.serializeFrom(
        static_cast<U8>(sizeof(U64))
      );
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
#endif
      _status = _logBuff.serializeFrom(buffLeft);
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );

#if FW_AMPCS_COMPATIBLE
      // Serialize the argument size
      _status = _logBuff.serializeFrom(
        static_cast<U8>(sizeof(U64))
      );
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
#endif
      _status = _logBuff.serializeFrom(buffLength);
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );

      this->m_logOut_OutputPort[0].invoke(
        _id,
        _logTime,
        Fw::LogSeverity::WARNING_HI,
        _logBuff
      );
    }

    // Emit the event on the text log port
#if FW_ENABLE_TEXT_LOGGING
    if (this->m_logTextOut_OutputPort[0].isConnected()) {
#if FW_OBJECT_NAMES == 1
      const char* _formatString =
        "(%s) %s: Deserialize error encountered while reading %s of file %s: %" PRIi32 " (%" PRIu64 " bytes left out of %" PRIu64 ")";
#else
      const char* _formatString =
        "%s: Deserialize error encountered while reading %s of file %s: %" PRIi32 " (%" PRIu64 " bytes left out of %" PRIu64 ")";
#endif

      Fw::String readStageStr;
      readStage.toString(readStageStr);

      Fw::TextLogString _logString;
      _logString.format(
        _formatString,
#if FW_OBJECT_NAMES == 1
        this->m_objName.toChar(),
#endif
        "FileReadDeserializeError ",
        readStageStr.toChar(),
        filePath.toChar(),
        errorCode,
        buffLeft,
        buffLength
      );

      this->m_logTextOut_OutputPort[0].invoke(
        _id,
        _logTime,
        Fw::LogSeverity::WARNING_HI,
        _logString
      );
    }
#endif
  }

  void FpySequencerComponentBase ::
    log_WARNING_HI_WrongSchemaVersion(
        U8 expected,
        U8 actual
    ) const
  {
    // Get the time
    Fw::Time _logTime;
    if (this->m_timeCaller_OutputPort[0].isConnected()) {
      this->m_timeCaller_OutputPort[0].invoke(_logTime);
    }

    FwEventIdType _id = static_cast<FwEventIdType>(0);

    _id = this->getIdBase() + EVENTID_WRONGSCHEMAVERSION;

    // Emit the event on the log port
    if (this->m_logOut_OutputPort[0].isConnected()) {
      Fw::LogBuffer _logBuff;
      Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

#if FW_AMPCS_COMPATIBLE
      // Serialize the number of arguments
      _status = _logBuff.serializeFrom(static_cast<U8>(2));
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
#endif

#if FW_AMPCS_COMPATIBLE
      // Serialize the argument size
      _status = _logBuff.serializeFrom(
        static_cast<U8>(sizeof(U8))
      );
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
#endif
      _status = _logBuff.serializeFrom(expected);
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );

#if FW_AMPCS_COMPATIBLE
      // Serialize the argument size
      _status = _logBuff.serializeFrom(
        static_cast<U8>(sizeof(U8))
      );
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
#endif
      _status = _logBuff.serializeFrom(actual);
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );

      this->m_logOut_OutputPort[0].invoke(
        _id,
        _logTime,
        Fw::LogSeverity::WARNING_HI,
        _logBuff
      );
    }

    // Emit the event on the text log port
#if FW_ENABLE_TEXT_LOGGING
    if (this->m_logTextOut_OutputPort[0].isConnected()) {
#if FW_OBJECT_NAMES == 1
      const char* _formatString =
        "(%s) %s: Expected schema version %" PRIu8 ", found %" PRIu8 "";
#else
      const char* _formatString =
        "%s: Expected schema version %" PRIu8 ", found %" PRIu8 "";
#endif

      Fw::TextLogString _logString;
      _logString.format(
        _formatString,
#if FW_OBJECT_NAMES == 1
        this->m_objName.toChar(),
#endif
        "WrongSchemaVersion ",
        expected,
        actual
      );

      this->m_logTextOut_OutputPort[0].invoke(
        _id,
        _logTime,
        Fw::LogSeverity::WARNING_HI,
        _logString
      );
    }
#endif
  }

  void FpySequencerComponentBase ::
    log_WARNING_HI_WrongCRC(
        U32 expected,
        U32 actual
    ) const
  {
    // Get the time
    Fw::Time _logTime;
    if (this->m_timeCaller_OutputPort[0].isConnected()) {
      this->m_timeCaller_OutputPort[0].invoke(_logTime);
    }

    FwEventIdType _id = static_cast<FwEventIdType>(0);

    _id = this->getIdBase() + EVENTID_WRONGCRC;

    // Emit the event on the log port
    if (this->m_logOut_OutputPort[0].isConnected()) {
      Fw::LogBuffer _logBuff;
      Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

#if FW_AMPCS_COMPATIBLE
      // Serialize the number of arguments
      _status = _logBuff.serializeFrom(static_cast<U8>(2));
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
#endif

#if FW_AMPCS_COMPATIBLE
      // Serialize the argument size
      _status = _logBuff.serializeFrom(
        static_cast<U8>(sizeof(U32))
      );
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
#endif
      _status = _logBuff.serializeFrom(expected);
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );

#if FW_AMPCS_COMPATIBLE
      // Serialize the argument size
      _status = _logBuff.serializeFrom(
        static_cast<U8>(sizeof(U32))
      );
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
#endif
      _status = _logBuff.serializeFrom(actual);
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );

      this->m_logOut_OutputPort[0].invoke(
        _id,
        _logTime,
        Fw::LogSeverity::WARNING_HI,
        _logBuff
      );
    }

    // Emit the event on the text log port
#if FW_ENABLE_TEXT_LOGGING
    if (this->m_logTextOut_OutputPort[0].isConnected()) {
#if FW_OBJECT_NAMES == 1
      const char* _formatString =
        "(%s) %s: Expected CRC %" PRIu32 ", actual was %" PRIu32 "";
#else
      const char* _formatString =
        "%s: Expected CRC %" PRIu32 ", actual was %" PRIu32 "";
#endif

      Fw::TextLogString _logString;
      _logString.format(
        _formatString,
#if FW_OBJECT_NAMES == 1
        this->m_objName.toChar(),
#endif
        "WrongCRC ",
        expected,
        actual
      );

      this->m_logTextOut_OutputPort[0].invoke(
        _id,
        _logTime,
        Fw::LogSeverity::WARNING_HI,
        _logString
      );
    }
#endif
  }

  void FpySequencerComponentBase ::
    log_WARNING_HI_ExtraBytesInSequence(FwSizeType remaining) const
  {
    // Get the time
    Fw::Time _logTime;
    if (this->m_timeCaller_OutputPort[0].isConnected()) {
      this->m_timeCaller_OutputPort[0].invoke(_logTime);
    }

    FwEventIdType _id = static_cast<FwEventIdType>(0);

    _id = this->getIdBase() + EVENTID_EXTRABYTESINSEQUENCE;

    // Emit the event on the log port
    if (this->m_logOut_OutputPort[0].isConnected()) {
      Fw::LogBuffer _logBuff;
      Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

#if FW_AMPCS_COMPATIBLE
      // Serialize the number of arguments
      _status = _logBuff.serializeFrom(static_cast<U8>(1));
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
#endif

#if FW_AMPCS_COMPATIBLE
      // Serialize the argument size
      _status = _logBuff.serializeFrom(
        static_cast<U8>(sizeof(FwSizeType))
      );
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
#endif
      _status = _logBuff.serializeFrom(remaining);
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );

      this->m_logOut_OutputPort[0].invoke(
        _id,
        _logTime,
        Fw::LogSeverity::WARNING_HI,
        _logBuff
      );
    }

    // Emit the event on the text log port
#if FW_ENABLE_TEXT_LOGGING
    if (this->m_logTextOut_OutputPort[0].isConnected()) {
#if FW_OBJECT_NAMES == 1
      const char* _formatString =
        "(%s) %s: File had %" PRIu64 " extra bytes at the end";
#else
      const char* _formatString =
        "%s: File had %" PRIu64 " extra bytes at the end";
#endif

      Fw::TextLogString _logString;
      _logString.format(
        _formatString,
#if FW_OBJECT_NAMES == 1
        this->m_objName.toChar(),
#endif
        "ExtraBytesInSequence ",
        remaining
      );

      this->m_logTextOut_OutputPort[0].invoke(
        _id,
        _logTime,
        Fw::LogSeverity::WARNING_HI,
        _logString
      );
    }
#endif
  }

  void FpySequencerComponentBase ::
    log_WARNING_HI_InsufficientBufferSpace(
        U64 bufferSize,
        const Fw::StringBase& filePath
    ) const
  {
    // Get the time
    Fw::Time _logTime;
    if (this->m_timeCaller_OutputPort[0].isConnected()) {
      this->m_timeCaller_OutputPort[0].invoke(_logTime);
    }

    FwEventIdType _id = static_cast<FwEventIdType>(0);

    _id = this->getIdBase() + EVENTID_INSUFFICIENTBUFFERSPACE;

    // Emit the event on the log port
    if (this->m_logOut_OutputPort[0].isConnected()) {
      Fw::LogBuffer _logBuff;
      Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

#if FW_AMPCS_COMPATIBLE
      // Serialize the number of arguments
      _status = _logBuff.serializeFrom(static_cast<U8>(2));
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
#endif

#if FW_AMPCS_COMPATIBLE
      // Serialize the argument size
      _status = _logBuff.serializeFrom(
        static_cast<U8>(sizeof(U64))
      );
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
#endif
      _status = _logBuff.serializeFrom(bufferSize);
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );

      _status = filePath.serializeTo(_logBuff, FW_MIN(FW_LOG_STRING_MAX_SIZE, 80));
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );

      this->m_logOut_OutputPort[0].invoke(
        _id,
        _logTime,
        Fw::LogSeverity::WARNING_HI,
        _logBuff
      );
    }

    // Emit the event on the text log port
#if FW_ENABLE_TEXT_LOGGING
    if (this->m_logTextOut_OutputPort[0].isConnected()) {
#if FW_OBJECT_NAMES == 1
      const char* _formatString =
        "(%s) %s: Buffer capacity of %" PRIu64 " was not big enough for sequence %s";
#else
      const char* _formatString =
        "%s: Buffer capacity of %" PRIu64 " was not big enough for sequence %s";
#endif

      Fw::TextLogString _logString;
      _logString.format(
        _formatString,
#if FW_OBJECT_NAMES == 1
        this->m_objName.toChar(),
#endif
        "InsufficientBufferSpace ",
        bufferSize,
        filePath.toChar()
      );

      this->m_logTextOut_OutputPort[0].invoke(
        _id,
        _logTime,
        Fw::LogSeverity::WARNING_HI,
        _logString
      );
    }
#endif
  }

  void FpySequencerComponentBase ::
    log_WARNING_HI_CommandFailed(
        FwOpcodeType opCode,
        U32 stmtIdx,
        const Fw::StringBase& filePath,
        Fw::CmdResponse response
    ) const
  {
    // Get the time
    Fw::Time _logTime;
    if (this->m_timeCaller_OutputPort[0].isConnected()) {
      this->m_timeCaller_OutputPort[0].invoke(_logTime);
    }

    FwEventIdType _id = static_cast<FwEventIdType>(0);

    _id = this->getIdBase() + EVENTID_COMMANDFAILED;

    // Emit the event on the log port
    if (this->m_logOut_OutputPort[0].isConnected()) {
      Fw::LogBuffer _logBuff;
      Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

#if FW_AMPCS_COMPATIBLE
      // Serialize the number of arguments
      _status = _logBuff.serializeFrom(static_cast<U8>(4));
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
#endif

#if FW_AMPCS_COMPATIBLE
      // Serialize the argument size
      _status = _logBuff.serializeFrom(
        static_cast<U8>(sizeof(FwOpcodeType))
      );
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
#endif
      _status = _logBuff.serializeFrom(opCode);
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );

#if FW_AMPCS_COMPATIBLE
      // Serialize the argument size
      _status = _logBuff.serializeFrom(
        static_cast<U8>(sizeof(U32))
      );
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
#endif
      _status = _logBuff.serializeFrom(stmtIdx);
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );

      _status = filePath.serializeTo(_logBuff, FW_MIN(FW_LOG_STRING_MAX_SIZE, 80));
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );

#if FW_AMPCS_COMPATIBLE
      // Serialize the argument size
      _status = _logBuff.serializeFrom(
        static_cast<U8>(Fw::CmdResponse::SERIALIZED_SIZE)
      );
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
#endif
      _status = _logBuff.serializeFrom(response);
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );

      this->m_logOut_OutputPort[0].invoke(
        _id,
        _logTime,
        Fw::LogSeverity::WARNING_HI,
        _logBuff
      );
    }

    // Emit the event on the text log port
#if FW_ENABLE_TEXT_LOGGING
    if (this->m_logTextOut_OutputPort[0].isConnected()) {
#if FW_OBJECT_NAMES == 1
      const char* _formatString =
        "(%s) %s: Failed to execute command opcode %" PRIu32 " index %" PRIu32 " in sequence file %s: response was %s";
#else
      const char* _formatString =
        "%s: Failed to execute command opcode %" PRIu32 " index %" PRIu32 " in sequence file %s: response was %s";
#endif

      Fw::String responseStr;
      response.toString(responseStr);

      Fw::TextLogString _logString;
      _logString.format(
        _formatString,
#if FW_OBJECT_NAMES == 1
        this->m_objName.toChar(),
#endif
        "CommandFailed ",
        opCode,
        stmtIdx,
        filePath.toChar(),
        responseStr.toChar()
      );

      this->m_logTextOut_OutputPort[0].invoke(
        _id,
        _logTime,
        Fw::LogSeverity::WARNING_HI,
        _logString
      );
    }
#endif
  }

  void FpySequencerComponentBase ::
    log_ACTIVITY_HI_SequenceDone(const Fw::StringBase& filePath) const
  {
    // Get the time
    Fw::Time _logTime;
    if (this->m_timeCaller_OutputPort[0].isConnected()) {
      this->m_timeCaller_OutputPort[0].invoke(_logTime);
    }

    FwEventIdType _id = static_cast<FwEventIdType>(0);

    _id = this->getIdBase() + EVENTID_SEQUENCEDONE;

    // Emit the event on the log port
    if (this->m_logOut_OutputPort[0].isConnected()) {
      Fw::LogBuffer _logBuff;
      Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

#if FW_AMPCS_COMPATIBLE
      // Serialize the number of arguments
      _status = _logBuff.serializeFrom(static_cast<U8>(1));
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
#endif

      _status = filePath.serializeTo(_logBuff, FW_MIN(FW_LOG_STRING_MAX_SIZE, 80));
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );

      this->m_logOut_OutputPort[0].invoke(
        _id,
        _logTime,
        Fw::LogSeverity::ACTIVITY_HI,
        _logBuff
      );
    }

    // Emit the event on the text log port
#if FW_ENABLE_TEXT_LOGGING
    if (this->m_logTextOut_OutputPort[0].isConnected()) {
#if FW_OBJECT_NAMES == 1
      const char* _formatString =
        "(%s) %s: Completed sequence file %s";
#else
      const char* _formatString =
        "%s: Completed sequence file %s";
#endif

      Fw::TextLogString _logString;
      _logString.format(
        _formatString,
#if FW_OBJECT_NAMES == 1
        this->m_objName.toChar(),
#endif
        "SequenceDone ",
        filePath.toChar()
      );

      this->m_logTextOut_OutputPort[0].invoke(
        _id,
        _logTime,
        Fw::LogSeverity::ACTIVITY_HI,
        _logString
      );
    }
#endif
  }

  void FpySequencerComponentBase ::
    log_ACTIVITY_HI_SequenceCancelled(const Fw::StringBase& filePath) const
  {
    // Get the time
    Fw::Time _logTime;
    if (this->m_timeCaller_OutputPort[0].isConnected()) {
      this->m_timeCaller_OutputPort[0].invoke(_logTime);
    }

    FwEventIdType _id = static_cast<FwEventIdType>(0);

    _id = this->getIdBase() + EVENTID_SEQUENCECANCELLED;

    // Emit the event on the log port
    if (this->m_logOut_OutputPort[0].isConnected()) {
      Fw::LogBuffer _logBuff;
      Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

#if FW_AMPCS_COMPATIBLE
      // Serialize the number of arguments
      _status = _logBuff.serializeFrom(static_cast<U8>(1));
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
#endif

      _status = filePath.serializeTo(_logBuff, FW_MIN(FW_LOG_STRING_MAX_SIZE, 80));
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );

      this->m_logOut_OutputPort[0].invoke(
        _id,
        _logTime,
        Fw::LogSeverity::ACTIVITY_HI,
        _logBuff
      );
    }

    // Emit the event on the text log port
#if FW_ENABLE_TEXT_LOGGING
    if (this->m_logTextOut_OutputPort[0].isConnected()) {
#if FW_OBJECT_NAMES == 1
      const char* _formatString =
        "(%s) %s: Cancelled sequence file %s";
#else
      const char* _formatString =
        "%s: Cancelled sequence file %s";
#endif

      Fw::TextLogString _logString;
      _logString.format(
        _formatString,
#if FW_OBJECT_NAMES == 1
        this->m_objName.toChar(),
#endif
        "SequenceCancelled ",
        filePath.toChar()
      );

      this->m_logTextOut_OutputPort[0].invoke(
        _id,
        _logTime,
        Fw::LogSeverity::ACTIVITY_HI,
        _logString
      );
    }
#endif
  }

  void FpySequencerComponentBase ::
    log_WARNING_HI_SequenceExitedWithError(
        const Fw::StringBase& filePath,
        U8 errorCode
    ) const
  {
    // Get the time
    Fw::Time _logTime;
    if (this->m_timeCaller_OutputPort[0].isConnected()) {
      this->m_timeCaller_OutputPort[0].invoke(_logTime);
    }

    FwEventIdType _id = static_cast<FwEventIdType>(0);

    _id = this->getIdBase() + EVENTID_SEQUENCEEXITEDWITHERROR;

    // Emit the event on the log port
    if (this->m_logOut_OutputPort[0].isConnected()) {
      Fw::LogBuffer _logBuff;
      Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

#if FW_AMPCS_COMPATIBLE
      // Serialize the number of arguments
      _status = _logBuff.serializeFrom(static_cast<U8>(2));
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
#endif

      _status = filePath.serializeTo(_logBuff, FW_MIN(FW_LOG_STRING_MAX_SIZE, 80));
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );

#if FW_AMPCS_COMPATIBLE
      // Serialize the argument size
      _status = _logBuff.serializeFrom(
        static_cast<U8>(sizeof(U8))
      );
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
#endif
      _status = _logBuff.serializeFrom(errorCode);
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );

      this->m_logOut_OutputPort[0].invoke(
        _id,
        _logTime,
        Fw::LogSeverity::WARNING_HI,
        _logBuff
      );
    }

    // Emit the event on the text log port
#if FW_ENABLE_TEXT_LOGGING
    if (this->m_logTextOut_OutputPort[0].isConnected()) {
#if FW_OBJECT_NAMES == 1
      const char* _formatString =
        "(%s) %s: Sequence %s exited with error code %" PRIu8 "";
#else
      const char* _formatString =
        "%s: Sequence %s exited with error code %" PRIu8 "";
#endif

      Fw::TextLogString _logString;
      _logString.format(
        _formatString,
#if FW_OBJECT_NAMES == 1
        this->m_objName.toChar(),
#endif
        "SequenceExitedWithError ",
        filePath.toChar(),
        errorCode
      );

      this->m_logTextOut_OutputPort[0].invoke(
        _id,
        _logTime,
        Fw::LogSeverity::WARNING_HI,
        _logString
      );
    }
#endif
  }

  void FpySequencerComponentBase ::
    log_WARNING_HI_UnknownSequencerDirective(
        U8 opcode,
        U32 stmtIdx,
        const Fw::StringBase& filePath
    ) const
  {
    // Get the time
    Fw::Time _logTime;
    if (this->m_timeCaller_OutputPort[0].isConnected()) {
      this->m_timeCaller_OutputPort[0].invoke(_logTime);
    }

    FwEventIdType _id = static_cast<FwEventIdType>(0);

    _id = this->getIdBase() + EVENTID_UNKNOWNSEQUENCERDIRECTIVE;

    // Emit the event on the log port
    if (this->m_logOut_OutputPort[0].isConnected()) {
      Fw::LogBuffer _logBuff;
      Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

#if FW_AMPCS_COMPATIBLE
      // Serialize the number of arguments
      _status = _logBuff.serializeFrom(static_cast<U8>(3));
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
#endif

#if FW_AMPCS_COMPATIBLE
      // Serialize the argument size
      _status = _logBuff.serializeFrom(
        static_cast<U8>(sizeof(U8))
      );
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
#endif
      _status = _logBuff.serializeFrom(opcode);
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );

#if FW_AMPCS_COMPATIBLE
      // Serialize the argument size
      _status = _logBuff.serializeFrom(
        static_cast<U8>(sizeof(U32))
      );
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
#endif
      _status = _logBuff.serializeFrom(stmtIdx);
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );

      _status = filePath.serializeTo(_logBuff, FW_MIN(FW_LOG_STRING_MAX_SIZE, 80));
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );

      this->m_logOut_OutputPort[0].invoke(
        _id,
        _logTime,
        Fw::LogSeverity::WARNING_HI,
        _logBuff
      );
    }

    // Emit the event on the text log port
#if FW_ENABLE_TEXT_LOGGING
    if (this->m_logTextOut_OutputPort[0].isConnected()) {
#if FW_OBJECT_NAMES == 1
      const char* _formatString =
        "(%s) %s: Unknown sequencer directive id %" PRIu8 " at index %" PRIu32 " in file %s";
#else
      const char* _formatString =
        "%s: Unknown sequencer directive id %" PRIu8 " at index %" PRIu32 " in file %s";
#endif

      Fw::TextLogString _logString;
      _logString.format(
        _formatString,
#if FW_OBJECT_NAMES == 1
        this->m_objName.toChar(),
#endif
        "UnknownSequencerDirective ",
        opcode,
        stmtIdx,
        filePath.toChar()
      );

      this->m_logTextOut_OutputPort[0].invoke(
        _id,
        _logTime,
        Fw::LogSeverity::WARNING_HI,
        _logString
      );
    }
#endif
  }

  void FpySequencerComponentBase ::
    log_WARNING_LO_CmdResponseWhileNotRunningSequence(
        I32 state,
        FwOpcodeType opcode,
        Fw::CmdResponse response
    ) const
  {
    // Get the time
    Fw::Time _logTime;
    if (this->m_timeCaller_OutputPort[0].isConnected()) {
      this->m_timeCaller_OutputPort[0].invoke(_logTime);
    }

    FwEventIdType _id = static_cast<FwEventIdType>(0);

    _id = this->getIdBase() + EVENTID_CMDRESPONSEWHILENOTRUNNINGSEQUENCE;

    // Emit the event on the log port
    if (this->m_logOut_OutputPort[0].isConnected()) {
      Fw::LogBuffer _logBuff;
      Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

#if FW_AMPCS_COMPATIBLE
      // Serialize the number of arguments
      _status = _logBuff.serializeFrom(static_cast<U8>(3));
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
#endif

#if FW_AMPCS_COMPATIBLE
      // Serialize the argument size
      _status = _logBuff.serializeFrom(
        static_cast<U8>(sizeof(I32))
      );
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
#endif
      _status = _logBuff.serializeFrom(state);
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );

#if FW_AMPCS_COMPATIBLE
      // Serialize the argument size
      _status = _logBuff.serializeFrom(
        static_cast<U8>(sizeof(FwOpcodeType))
      );
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
#endif
      _status = _logBuff.serializeFrom(opcode);
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );

#if FW_AMPCS_COMPATIBLE
      // Serialize the argument size
      _status = _logBuff.serializeFrom(
        static_cast<U8>(Fw::CmdResponse::SERIALIZED_SIZE)
      );
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
#endif
      _status = _logBuff.serializeFrom(response);
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );

      this->m_logOut_OutputPort[0].invoke(
        _id,
        _logTime,
        Fw::LogSeverity::WARNING_LO,
        _logBuff
      );
    }

    // Emit the event on the text log port
#if FW_ENABLE_TEXT_LOGGING
    if (this->m_logTextOut_OutputPort[0].isConnected()) {
#if FW_OBJECT_NAMES == 1
      const char* _formatString =
        "(%s) %s: Received a command response while not running a sequence (was in state %" PRIi32 " opcode was %" PRIu32 " response code %s)";
#else
      const char* _formatString =
        "%s: Received a command response while not running a sequence (was in state %" PRIi32 " opcode was %" PRIu32 " response code %s)";
#endif

      Fw::String responseStr;
      response.toString(responseStr);

      Fw::TextLogString _logString;
      _logString.format(
        _formatString,
#if FW_OBJECT_NAMES == 1
        this->m_objName.toChar(),
#endif
        "CmdResponseWhileNotRunningSequence ",
        state,
        opcode,
        responseStr.toChar()
      );

      this->m_logTextOut_OutputPort[0].invoke(
        _id,
        _logTime,
        Fw::LogSeverity::WARNING_LO,
        _logString
      );
    }
#endif
  }

  void FpySequencerComponentBase ::
    log_WARNING_LO_CmdResponseFromOldSequence(
        FwOpcodeType opcode,
        Fw::CmdResponse response,
        U16 oldSequenceIdx,
        U16 currentSequenceIdx
    ) const
  {
    // Get the time
    Fw::Time _logTime;
    if (this->m_timeCaller_OutputPort[0].isConnected()) {
      this->m_timeCaller_OutputPort[0].invoke(_logTime);
    }

    FwEventIdType _id = static_cast<FwEventIdType>(0);

    _id = this->getIdBase() + EVENTID_CMDRESPONSEFROMOLDSEQUENCE;

    // Emit the event on the log port
    if (this->m_logOut_OutputPort[0].isConnected()) {
      Fw::LogBuffer _logBuff;
      Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

#if FW_AMPCS_COMPATIBLE
      // Serialize the number of arguments
      _status = _logBuff.serializeFrom(static_cast<U8>(4));
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
#endif

#if FW_AMPCS_COMPATIBLE
      // Serialize the argument size
      _status = _logBuff.serializeFrom(
        static_cast<U8>(sizeof(FwOpcodeType))
      );
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
#endif
      _status = _logBuff.serializeFrom(opcode);
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );

#if FW_AMPCS_COMPATIBLE
      // Serialize the argument size
      _status = _logBuff.serializeFrom(
        static_cast<U8>(Fw::CmdResponse::SERIALIZED_SIZE)
      );
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
#endif
      _status = _logBuff.serializeFrom(response);
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );

#if FW_AMPCS_COMPATIBLE
      // Serialize the argument size
      _status = _logBuff.serializeFrom(
        static_cast<U8>(sizeof(U16))
      );
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
#endif
      _status = _logBuff.serializeFrom(oldSequenceIdx);
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );

#if FW_AMPCS_COMPATIBLE
      // Serialize the argument size
      _status = _logBuff.serializeFrom(
        static_cast<U8>(sizeof(U16))
      );
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
#endif
      _status = _logBuff.serializeFrom(currentSequenceIdx);
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );

      this->m_logOut_OutputPort[0].invoke(
        _id,
        _logTime,
        Fw::LogSeverity::WARNING_LO,
        _logBuff
      );
    }

    // Emit the event on the text log port
#if FW_ENABLE_TEXT_LOGGING
    if (this->m_logTextOut_OutputPort[0].isConnected()) {
#if FW_OBJECT_NAMES == 1
      const char* _formatString =
        "(%s) %s: Received a response from cmd opcode %" PRIu32 " (response %s), but it was from a previous sequence, not the current one (old idx: %" PRIu16 ", current idx: %" PRIu16 ")";
#else
      const char* _formatString =
        "%s: Received a response from cmd opcode %" PRIu32 " (response %s), but it was from a previous sequence, not the current one (old idx: %" PRIu16 ", current idx: %" PRIu16 ")";
#endif

      Fw::String responseStr;
      response.toString(responseStr);

      Fw::TextLogString _logString;
      _logString.format(
        _formatString,
#if FW_OBJECT_NAMES == 1
        this->m_objName.toChar(),
#endif
        "CmdResponseFromOldSequence ",
        opcode,
        responseStr.toChar(),
        oldSequenceIdx,
        currentSequenceIdx
      );

      this->m_logTextOut_OutputPort[0].invoke(
        _id,
        _logTime,
        Fw::LogSeverity::WARNING_LO,
        _logString
      );
    }
#endif
  }

  void FpySequencerComponentBase ::
    log_WARNING_HI_CmdResponseWhileNotAwaiting(
        FwOpcodeType opcode,
        Fw::CmdResponse response
    ) const
  {
    // Get the time
    Fw::Time _logTime;
    if (this->m_timeCaller_OutputPort[0].isConnected()) {
      this->m_timeCaller_OutputPort[0].invoke(_logTime);
    }

    FwEventIdType _id = static_cast<FwEventIdType>(0);

    _id = this->getIdBase() + EVENTID_CMDRESPONSEWHILENOTAWAITING;

    // Emit the event on the log port
    if (this->m_logOut_OutputPort[0].isConnected()) {
      Fw::LogBuffer _logBuff;
      Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

#if FW_AMPCS_COMPATIBLE
      // Serialize the number of arguments
      _status = _logBuff.serializeFrom(static_cast<U8>(2));
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
#endif

#if FW_AMPCS_COMPATIBLE
      // Serialize the argument size
      _status = _logBuff.serializeFrom(
        static_cast<U8>(sizeof(FwOpcodeType))
      );
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
#endif
      _status = _logBuff.serializeFrom(opcode);
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );

#if FW_AMPCS_COMPATIBLE
      // Serialize the argument size
      _status = _logBuff.serializeFrom(
        static_cast<U8>(Fw::CmdResponse::SERIALIZED_SIZE)
      );
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
#endif
      _status = _logBuff.serializeFrom(response);
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );

      this->m_logOut_OutputPort[0].invoke(
        _id,
        _logTime,
        Fw::LogSeverity::WARNING_HI,
        _logBuff
      );
    }

    // Emit the event on the text log port
#if FW_ENABLE_TEXT_LOGGING
    if (this->m_logTextOut_OutputPort[0].isConnected()) {
#if FW_OBJECT_NAMES == 1
      const char* _formatString =
        "(%s) %s: Received a response from cmd opcode %" PRIu32 " (response %s) from this sequence, but was not awaiting a response";
#else
      const char* _formatString =
        "%s: Received a response from cmd opcode %" PRIu32 " (response %s) from this sequence, but was not awaiting a response";
#endif

      Fw::String responseStr;
      response.toString(responseStr);

      Fw::TextLogString _logString;
      _logString.format(
        _formatString,
#if FW_OBJECT_NAMES == 1
        this->m_objName.toChar(),
#endif
        "CmdResponseWhileNotAwaiting ",
        opcode,
        responseStr.toChar()
      );

      this->m_logTextOut_OutputPort[0].invoke(
        _id,
        _logTime,
        Fw::LogSeverity::WARNING_HI,
        _logString
      );
    }
#endif
  }

  void FpySequencerComponentBase ::
    log_WARNING_HI_CmdResponseWhileAwaitingDirective(
        FwOpcodeType opcode,
        Fw::CmdResponse response,
        U8 expectedDirectiveOpcode
    ) const
  {
    // Get the time
    Fw::Time _logTime;
    if (this->m_timeCaller_OutputPort[0].isConnected()) {
      this->m_timeCaller_OutputPort[0].invoke(_logTime);
    }

    FwEventIdType _id = static_cast<FwEventIdType>(0);

    _id = this->getIdBase() + EVENTID_CMDRESPONSEWHILEAWAITINGDIRECTIVE;

    // Emit the event on the log port
    if (this->m_logOut_OutputPort[0].isConnected()) {
      Fw::LogBuffer _logBuff;
      Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

#if FW_AMPCS_COMPATIBLE
      // Serialize the number of arguments
      _status = _logBuff.serializeFrom(static_cast<U8>(3));
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
#endif

#if FW_AMPCS_COMPATIBLE
      // Serialize the argument size
      _status = _logBuff.serializeFrom(
        static_cast<U8>(sizeof(FwOpcodeType))
      );
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
#endif
      _status = _logBuff.serializeFrom(opcode);
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );

#if FW_AMPCS_COMPATIBLE
      // Serialize the argument size
      _status = _logBuff.serializeFrom(
        static_cast<U8>(Fw::CmdResponse::SERIALIZED_SIZE)
      );
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
#endif
      _status = _logBuff.serializeFrom(response);
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );

#if FW_AMPCS_COMPATIBLE
      // Serialize the argument size
      _status = _logBuff.serializeFrom(
        static_cast<U8>(sizeof(U8))
      );
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
#endif
      _status = _logBuff.serializeFrom(expectedDirectiveOpcode);
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );

      this->m_logOut_OutputPort[0].invoke(
        _id,
        _logTime,
        Fw::LogSeverity::WARNING_HI,
        _logBuff
      );
    }

    // Emit the event on the text log port
#if FW_ENABLE_TEXT_LOGGING
    if (this->m_logTextOut_OutputPort[0].isConnected()) {
#if FW_OBJECT_NAMES == 1
      const char* _formatString =
        "(%s) %s: Received a response from cmd opcode %" PRIu32 " (response %s) from this sequence, but was awaiting directive opcode %" PRIu8 "";
#else
      const char* _formatString =
        "%s: Received a response from cmd opcode %" PRIu32 " (response %s) from this sequence, but was awaiting directive opcode %" PRIu8 "";
#endif

      Fw::String responseStr;
      response.toString(responseStr);

      Fw::TextLogString _logString;
      _logString.format(
        _formatString,
#if FW_OBJECT_NAMES == 1
        this->m_objName.toChar(),
#endif
        "CmdResponseWhileAwaitingDirective ",
        opcode,
        responseStr.toChar(),
        expectedDirectiveOpcode
      );

      this->m_logTextOut_OutputPort[0].invoke(
        _id,
        _logTime,
        Fw::LogSeverity::WARNING_HI,
        _logString
      );
    }
#endif
  }

  void FpySequencerComponentBase ::
    log_WARNING_HI_WrongCmdResponseOpcode(
        FwOpcodeType opcode,
        Fw::CmdResponse response,
        FwOpcodeType expectedOpcode
    ) const
  {
    // Get the time
    Fw::Time _logTime;
    if (this->m_timeCaller_OutputPort[0].isConnected()) {
      this->m_timeCaller_OutputPort[0].invoke(_logTime);
    }

    FwEventIdType _id = static_cast<FwEventIdType>(0);

    _id = this->getIdBase() + EVENTID_WRONGCMDRESPONSEOPCODE;

    // Emit the event on the log port
    if (this->m_logOut_OutputPort[0].isConnected()) {
      Fw::LogBuffer _logBuff;
      Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

#if FW_AMPCS_COMPATIBLE
      // Serialize the number of arguments
      _status = _logBuff.serializeFrom(static_cast<U8>(3));
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
#endif

#if FW_AMPCS_COMPATIBLE
      // Serialize the argument size
      _status = _logBuff.serializeFrom(
        static_cast<U8>(sizeof(FwOpcodeType))
      );
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
#endif
      _status = _logBuff.serializeFrom(opcode);
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );

#if FW_AMPCS_COMPATIBLE
      // Serialize the argument size
      _status = _logBuff.serializeFrom(
        static_cast<U8>(Fw::CmdResponse::SERIALIZED_SIZE)
      );
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
#endif
      _status = _logBuff.serializeFrom(response);
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );

#if FW_AMPCS_COMPATIBLE
      // Serialize the argument size
      _status = _logBuff.serializeFrom(
        static_cast<U8>(sizeof(FwOpcodeType))
      );
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
#endif
      _status = _logBuff.serializeFrom(expectedOpcode);
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );

      this->m_logOut_OutputPort[0].invoke(
        _id,
        _logTime,
        Fw::LogSeverity::WARNING_HI,
        _logBuff
      );
    }

    // Emit the event on the text log port
#if FW_ENABLE_TEXT_LOGGING
    if (this->m_logTextOut_OutputPort[0].isConnected()) {
#if FW_OBJECT_NAMES == 1
      const char* _formatString =
        "(%s) %s: Received a response from cmd opcode %" PRIu32 " (response %s) from this sequence, but was expecting a response from command opcode %" PRIu32 "";
#else
      const char* _formatString =
        "%s: Received a response from cmd opcode %" PRIu32 " (response %s) from this sequence, but was expecting a response from command opcode %" PRIu32 "";
#endif

      Fw::String responseStr;
      response.toString(responseStr);

      Fw::TextLogString _logString;
      _logString.format(
        _formatString,
#if FW_OBJECT_NAMES == 1
        this->m_objName.toChar(),
#endif
        "WrongCmdResponseOpcode ",
        opcode,
        responseStr.toChar(),
        expectedOpcode
      );

      this->m_logTextOut_OutputPort[0].invoke(
        _id,
        _logTime,
        Fw::LogSeverity::WARNING_HI,
        _logString
      );
    }
#endif
  }

  void FpySequencerComponentBase ::
    log_WARNING_HI_WrongCmdResponseIndex(
        FwOpcodeType opcode,
        Fw::CmdResponse response,
        U16 actualCmdIdx,
        U16 expectedCmdIdx
    ) const
  {
    // Get the time
    Fw::Time _logTime;
    if (this->m_timeCaller_OutputPort[0].isConnected()) {
      this->m_timeCaller_OutputPort[0].invoke(_logTime);
    }

    FwEventIdType _id = static_cast<FwEventIdType>(0);

    _id = this->getIdBase() + EVENTID_WRONGCMDRESPONSEINDEX;

    // Emit the event on the log port
    if (this->m_logOut_OutputPort[0].isConnected()) {
      Fw::LogBuffer _logBuff;
      Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

#if FW_AMPCS_COMPATIBLE
      // Serialize the number of arguments
      _status = _logBuff.serializeFrom(static_cast<U8>(4));
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
#endif

#if FW_AMPCS_COMPATIBLE
      // Serialize the argument size
      _status = _logBuff.serializeFrom(
        static_cast<U8>(sizeof(FwOpcodeType))
      );
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
#endif
      _status = _logBuff.serializeFrom(opcode);
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );

#if FW_AMPCS_COMPATIBLE
      // Serialize the argument size
      _status = _logBuff.serializeFrom(
        static_cast<U8>(Fw::CmdResponse::SERIALIZED_SIZE)
      );
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
#endif
      _status = _logBuff.serializeFrom(response);
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );

#if FW_AMPCS_COMPATIBLE
      // Serialize the argument size
      _status = _logBuff.serializeFrom(
        static_cast<U8>(sizeof(U16))
      );
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
#endif
      _status = _logBuff.serializeFrom(actualCmdIdx);
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );

#if FW_AMPCS_COMPATIBLE
      // Serialize the argument size
      _status = _logBuff.serializeFrom(
        static_cast<U8>(sizeof(U16))
      );
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
#endif
      _status = _logBuff.serializeFrom(expectedCmdIdx);
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );

      this->m_logOut_OutputPort[0].invoke(
        _id,
        _logTime,
        Fw::LogSeverity::WARNING_HI,
        _logBuff
      );
    }

    // Emit the event on the text log port
#if FW_ENABLE_TEXT_LOGGING
    if (this->m_logTextOut_OutputPort[0].isConnected()) {
#if FW_OBJECT_NAMES == 1
      const char* _formatString =
        "(%s) %s: Received a response from the correct cmd (opcode %" PRIu32 " response %s), but it was for a different instance of that opcode in the same sequence (actual idx %" PRIu16 " expected %" PRIu16 ")";
#else
      const char* _formatString =
        "%s: Received a response from the correct cmd (opcode %" PRIu32 " response %s), but it was for a different instance of that opcode in the same sequence (actual idx %" PRIu16 " expected %" PRIu16 ")";
#endif

      Fw::String responseStr;
      response.toString(responseStr);

      Fw::TextLogString _logString;
      _logString.format(
        _formatString,
#if FW_OBJECT_NAMES == 1
        this->m_objName.toChar(),
#endif
        "WrongCmdResponseIndex ",
        opcode,
        responseStr.toChar(),
        actualCmdIdx,
        expectedCmdIdx
      );

      this->m_logTextOut_OutputPort[0].invoke(
        _id,
        _logTime,
        Fw::LogSeverity::WARNING_HI,
        _logString
      );
    }
#endif
  }

  void FpySequencerComponentBase ::
    log_WARNING_HI_DirectiveDeserializeError(
        U8 opcode,
        U32 stmtIdx,
        I32 errorCode,
        U64 buffLeft,
        U64 buffLength
    ) const
  {
    // Get the time
    Fw::Time _logTime;
    if (this->m_timeCaller_OutputPort[0].isConnected()) {
      this->m_timeCaller_OutputPort[0].invoke(_logTime);
    }

    FwEventIdType _id = static_cast<FwEventIdType>(0);

    _id = this->getIdBase() + EVENTID_DIRECTIVEDESERIALIZEERROR;

    // Emit the event on the log port
    if (this->m_logOut_OutputPort[0].isConnected()) {
      Fw::LogBuffer _logBuff;
      Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

#if FW_AMPCS_COMPATIBLE
      // Serialize the number of arguments
      _status = _logBuff.serializeFrom(static_cast<U8>(5));
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
#endif

#if FW_AMPCS_COMPATIBLE
      // Serialize the argument size
      _status = _logBuff.serializeFrom(
        static_cast<U8>(sizeof(U8))
      );
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
#endif
      _status = _logBuff.serializeFrom(opcode);
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );

#if FW_AMPCS_COMPATIBLE
      // Serialize the argument size
      _status = _logBuff.serializeFrom(
        static_cast<U8>(sizeof(U32))
      );
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
#endif
      _status = _logBuff.serializeFrom(stmtIdx);
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );

#if FW_AMPCS_COMPATIBLE
      // Serialize the argument size
      _status = _logBuff.serializeFrom(
        static_cast<U8>(sizeof(I32))
      );
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
#endif
      _status = _logBuff.serializeFrom(errorCode);
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );

#if FW_AMPCS_COMPATIBLE
      // Serialize the argument size
      _status = _logBuff.serializeFrom(
        static_cast<U8>(sizeof(U64))
      );
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
#endif
      _status = _logBuff.serializeFrom(buffLeft);
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );

#if FW_AMPCS_COMPATIBLE
      // Serialize the argument size
      _status = _logBuff.serializeFrom(
        static_cast<U8>(sizeof(U64))
      );
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
#endif
      _status = _logBuff.serializeFrom(buffLength);
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );

      this->m_logOut_OutputPort[0].invoke(
        _id,
        _logTime,
        Fw::LogSeverity::WARNING_HI,
        _logBuff
      );
    }

    // Emit the event on the text log port
#if FW_ENABLE_TEXT_LOGGING
    if (this->m_logTextOut_OutputPort[0].isConnected()) {
#if FW_OBJECT_NAMES == 1
      const char* _formatString =
        "(%s) %s: Deserialize error encountered while reading directive opcode %" PRIu8 " at index %" PRIu32 ": %" PRIi32 " (%" PRIu64 " bytes left out of %" PRIu64 ")";
#else
      const char* _formatString =
        "%s: Deserialize error encountered while reading directive opcode %" PRIu8 " at index %" PRIu32 ": %" PRIi32 " (%" PRIu64 " bytes left out of %" PRIu64 ")";
#endif

      Fw::TextLogString _logString;
      _logString.format(
        _formatString,
#if FW_OBJECT_NAMES == 1
        this->m_objName.toChar(),
#endif
        "DirectiveDeserializeError ",
        opcode,
        stmtIdx,
        errorCode,
        buffLeft,
        buffLength
      );

      this->m_logTextOut_OutputPort[0].invoke(
        _id,
        _logTime,
        Fw::LogSeverity::WARNING_HI,
        _logString
      );
    }
#endif
  }

  void FpySequencerComponentBase ::
    log_WARNING_HI_MismatchedTimeBase(
        I32 internalTimeBase,
        I32 otherTimeBase
    ) const
  {
    // Get the time
    Fw::Time _logTime;
    if (this->m_timeCaller_OutputPort[0].isConnected()) {
      this->m_timeCaller_OutputPort[0].invoke(_logTime);
    }

    FwEventIdType _id = static_cast<FwEventIdType>(0);

    _id = this->getIdBase() + EVENTID_MISMATCHEDTIMEBASE;

    // Emit the event on the log port
    if (this->m_logOut_OutputPort[0].isConnected()) {
      Fw::LogBuffer _logBuff;
      Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

#if FW_AMPCS_COMPATIBLE
      // Serialize the number of arguments
      _status = _logBuff.serializeFrom(static_cast<U8>(2));
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
#endif

#if FW_AMPCS_COMPATIBLE
      // Serialize the argument size
      _status = _logBuff.serializeFrom(
        static_cast<U8>(sizeof(I32))
      );
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
#endif
      _status = _logBuff.serializeFrom(internalTimeBase);
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );

#if FW_AMPCS_COMPATIBLE
      // Serialize the argument size
      _status = _logBuff.serializeFrom(
        static_cast<U8>(sizeof(I32))
      );
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
#endif
      _status = _logBuff.serializeFrom(otherTimeBase);
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );

      this->m_logOut_OutputPort[0].invoke(
        _id,
        _logTime,
        Fw::LogSeverity::WARNING_HI,
        _logBuff
      );
    }

    // Emit the event on the text log port
#if FW_ENABLE_TEXT_LOGGING
    if (this->m_logTextOut_OutputPort[0].isConnected()) {
#if FW_OBJECT_NAMES == 1
      const char* _formatString =
        "(%s) %s: getTime() time base was %" PRIi32 ", but tried to operate on it with time base %" PRIi32 "";
#else
      const char* _formatString =
        "%s: getTime() time base was %" PRIi32 ", but tried to operate on it with time base %" PRIi32 "";
#endif

      Fw::TextLogString _logString;
      _logString.format(
        _formatString,
#if FW_OBJECT_NAMES == 1
        this->m_objName.toChar(),
#endif
        "MismatchedTimeBase ",
        internalTimeBase,
        otherTimeBase
      );

      this->m_logTextOut_OutputPort[0].invoke(
        _id,
        _logTime,
        Fw::LogSeverity::WARNING_HI,
        _logString
      );
    }
#endif
  }

  void FpySequencerComponentBase ::
    log_WARNING_HI_MismatchedTimeContext(
        I32 internalTimeContext,
        I32 otherTimeContext
    ) const
  {
    // Get the time
    Fw::Time _logTime;
    if (this->m_timeCaller_OutputPort[0].isConnected()) {
      this->m_timeCaller_OutputPort[0].invoke(_logTime);
    }

    FwEventIdType _id = static_cast<FwEventIdType>(0);

    _id = this->getIdBase() + EVENTID_MISMATCHEDTIMECONTEXT;

    // Emit the event on the log port
    if (this->m_logOut_OutputPort[0].isConnected()) {
      Fw::LogBuffer _logBuff;
      Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

#if FW_AMPCS_COMPATIBLE
      // Serialize the number of arguments
      _status = _logBuff.serializeFrom(static_cast<U8>(2));
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
#endif

#if FW_AMPCS_COMPATIBLE
      // Serialize the argument size
      _status = _logBuff.serializeFrom(
        static_cast<U8>(sizeof(I32))
      );
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
#endif
      _status = _logBuff.serializeFrom(internalTimeContext);
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );

#if FW_AMPCS_COMPATIBLE
      // Serialize the argument size
      _status = _logBuff.serializeFrom(
        static_cast<U8>(sizeof(I32))
      );
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
#endif
      _status = _logBuff.serializeFrom(otherTimeContext);
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );

      this->m_logOut_OutputPort[0].invoke(
        _id,
        _logTime,
        Fw::LogSeverity::WARNING_HI,
        _logBuff
      );
    }

    // Emit the event on the text log port
#if FW_ENABLE_TEXT_LOGGING
    if (this->m_logTextOut_OutputPort[0].isConnected()) {
#if FW_OBJECT_NAMES == 1
      const char* _formatString =
        "(%s) %s: getTime() time context was %" PRIi32 ", but tried to operate on it with time context %" PRIi32 "";
#else
      const char* _formatString =
        "%s: getTime() time context was %" PRIi32 ", but tried to operate on it with time context %" PRIi32 "";
#endif

      Fw::TextLogString _logString;
      _logString.format(
        _formatString,
#if FW_OBJECT_NAMES == 1
        this->m_objName.toChar(),
#endif
        "MismatchedTimeContext ",
        internalTimeContext,
        otherTimeContext
      );

      this->m_logTextOut_OutputPort[0].invoke(
        _id,
        _logTime,
        Fw::LogSeverity::WARNING_HI,
        _logString
      );
    }
#endif
  }

  void FpySequencerComponentBase ::
    log_WARNING_HI_CommandTimedOut(
        FwOpcodeType opCode,
        U32 stmtIdx,
        const Fw::StringBase& filePath
    ) const
  {
    // Get the time
    Fw::Time _logTime;
    if (this->m_timeCaller_OutputPort[0].isConnected()) {
      this->m_timeCaller_OutputPort[0].invoke(_logTime);
    }

    FwEventIdType _id = static_cast<FwEventIdType>(0);

    _id = this->getIdBase() + EVENTID_COMMANDTIMEDOUT;

    // Emit the event on the log port
    if (this->m_logOut_OutputPort[0].isConnected()) {
      Fw::LogBuffer _logBuff;
      Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

#if FW_AMPCS_COMPATIBLE
      // Serialize the number of arguments
      _status = _logBuff.serializeFrom(static_cast<U8>(3));
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
#endif

#if FW_AMPCS_COMPATIBLE
      // Serialize the argument size
      _status = _logBuff.serializeFrom(
        static_cast<U8>(sizeof(FwOpcodeType))
      );
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
#endif
      _status = _logBuff.serializeFrom(opCode);
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );

#if FW_AMPCS_COMPATIBLE
      // Serialize the argument size
      _status = _logBuff.serializeFrom(
        static_cast<U8>(sizeof(U32))
      );
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
#endif
      _status = _logBuff.serializeFrom(stmtIdx);
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );

      _status = filePath.serializeTo(_logBuff, FW_MIN(FW_LOG_STRING_MAX_SIZE, 80));
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );

      this->m_logOut_OutputPort[0].invoke(
        _id,
        _logTime,
        Fw::LogSeverity::WARNING_HI,
        _logBuff
      );
    }

    // Emit the event on the text log port
#if FW_ENABLE_TEXT_LOGGING
    if (this->m_logTextOut_OutputPort[0].isConnected()) {
#if FW_OBJECT_NAMES == 1
      const char* _formatString =
        "(%s) %s: A command opcode %" PRIu32 " at index %" PRIu32 " timed out in sequence %s, causing the sequence to fail";
#else
      const char* _formatString =
        "%s: A command opcode %" PRIu32 " at index %" PRIu32 " timed out in sequence %s, causing the sequence to fail";
#endif

      Fw::TextLogString _logString;
      _logString.format(
        _formatString,
#if FW_OBJECT_NAMES == 1
        this->m_objName.toChar(),
#endif
        "CommandTimedOut ",
        opCode,
        stmtIdx,
        filePath.toChar()
      );

      this->m_logTextOut_OutputPort[0].invoke(
        _id,
        _logTime,
        Fw::LogSeverity::WARNING_HI,
        _logString
      );
    }
#endif
  }

  void FpySequencerComponentBase ::
    log_WARNING_HI_DirectiveTimedOut(
        U8 opCode,
        U32 stmtIdx,
        const Fw::StringBase& filePath
    ) const
  {
    // Get the time
    Fw::Time _logTime;
    if (this->m_timeCaller_OutputPort[0].isConnected()) {
      this->m_timeCaller_OutputPort[0].invoke(_logTime);
    }

    FwEventIdType _id = static_cast<FwEventIdType>(0);

    _id = this->getIdBase() + EVENTID_DIRECTIVETIMEDOUT;

    // Emit the event on the log port
    if (this->m_logOut_OutputPort[0].isConnected()) {
      Fw::LogBuffer _logBuff;
      Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

#if FW_AMPCS_COMPATIBLE
      // Serialize the number of arguments
      _status = _logBuff.serializeFrom(static_cast<U8>(3));
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
#endif

#if FW_AMPCS_COMPATIBLE
      // Serialize the argument size
      _status = _logBuff.serializeFrom(
        static_cast<U8>(sizeof(U8))
      );
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
#endif
      _status = _logBuff.serializeFrom(opCode);
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );

#if FW_AMPCS_COMPATIBLE
      // Serialize the argument size
      _status = _logBuff.serializeFrom(
        static_cast<U8>(sizeof(U32))
      );
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
#endif
      _status = _logBuff.serializeFrom(stmtIdx);
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );

      _status = filePath.serializeTo(_logBuff, FW_MIN(FW_LOG_STRING_MAX_SIZE, 80));
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );

      this->m_logOut_OutputPort[0].invoke(
        _id,
        _logTime,
        Fw::LogSeverity::WARNING_HI,
        _logBuff
      );
    }

    // Emit the event on the text log port
#if FW_ENABLE_TEXT_LOGGING
    if (this->m_logTextOut_OutputPort[0].isConnected()) {
#if FW_OBJECT_NAMES == 1
      const char* _formatString =
        "(%s) %s: A directive opcode %" PRIu8 " at index %" PRIu32 " timed out in sequence %s, causing the sequence to fail";
#else
      const char* _formatString =
        "%s: A directive opcode %" PRIu8 " at index %" PRIu32 " timed out in sequence %s, causing the sequence to fail";
#endif

      Fw::TextLogString _logString;
      _logString.format(
        _formatString,
#if FW_OBJECT_NAMES == 1
        this->m_objName.toChar(),
#endif
        "DirectiveTimedOut ",
        opCode,
        stmtIdx,
        filePath.toChar()
      );

      this->m_logTextOut_OutputPort[0].invoke(
        _id,
        _logTime,
        Fw::LogSeverity::WARNING_HI,
        _logString
      );
    }
#endif
  }

  void FpySequencerComponentBase ::
    log_WARNING_HI_TooManySequenceArgs(
        U8 count,
        U8 max
    ) const
  {
    // Get the time
    Fw::Time _logTime;
    if (this->m_timeCaller_OutputPort[0].isConnected()) {
      this->m_timeCaller_OutputPort[0].invoke(_logTime);
    }

    FwEventIdType _id = static_cast<FwEventIdType>(0);

    _id = this->getIdBase() + EVENTID_TOOMANYSEQUENCEARGS;

    // Emit the event on the log port
    if (this->m_logOut_OutputPort[0].isConnected()) {
      Fw::LogBuffer _logBuff;
      Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

#if FW_AMPCS_COMPATIBLE
      // Serialize the number of arguments
      _status = _logBuff.serializeFrom(static_cast<U8>(2));
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
#endif

#if FW_AMPCS_COMPATIBLE
      // Serialize the argument size
      _status = _logBuff.serializeFrom(
        static_cast<U8>(sizeof(U8))
      );
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
#endif
      _status = _logBuff.serializeFrom(count);
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );

#if FW_AMPCS_COMPATIBLE
      // Serialize the argument size
      _status = _logBuff.serializeFrom(
        static_cast<U8>(sizeof(U8))
      );
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
#endif
      _status = _logBuff.serializeFrom(max);
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );

      this->m_logOut_OutputPort[0].invoke(
        _id,
        _logTime,
        Fw::LogSeverity::WARNING_HI,
        _logBuff
      );
    }

    // Emit the event on the text log port
#if FW_ENABLE_TEXT_LOGGING
    if (this->m_logTextOut_OutputPort[0].isConnected()) {
#if FW_OBJECT_NAMES == 1
      const char* _formatString =
        "(%s) %s: A sequence specified it had %" PRIu8 " args but the max was %" PRIu8 "";
#else
      const char* _formatString =
        "%s: A sequence specified it had %" PRIu8 " args but the max was %" PRIu8 "";
#endif

      Fw::TextLogString _logString;
      _logString.format(
        _formatString,
#if FW_OBJECT_NAMES == 1
        this->m_objName.toChar(),
#endif
        "TooManySequenceArgs ",
        count,
        max
      );

      this->m_logTextOut_OutputPort[0].invoke(
        _id,
        _logTime,
        Fw::LogSeverity::WARNING_HI,
        _logString
      );
    }
#endif
  }

  void FpySequencerComponentBase ::
    log_WARNING_HI_TooManySequenceDirectives(
        U16 count,
        U16 max
    ) const
  {
    // Get the time
    Fw::Time _logTime;
    if (this->m_timeCaller_OutputPort[0].isConnected()) {
      this->m_timeCaller_OutputPort[0].invoke(_logTime);
    }

    FwEventIdType _id = static_cast<FwEventIdType>(0);

    _id = this->getIdBase() + EVENTID_TOOMANYSEQUENCEDIRECTIVES;

    // Emit the event on the log port
    if (this->m_logOut_OutputPort[0].isConnected()) {
      Fw::LogBuffer _logBuff;
      Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

#if FW_AMPCS_COMPATIBLE
      // Serialize the number of arguments
      _status = _logBuff.serializeFrom(static_cast<U8>(2));
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
#endif

#if FW_AMPCS_COMPATIBLE
      // Serialize the argument size
      _status = _logBuff.serializeFrom(
        static_cast<U8>(sizeof(U16))
      );
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
#endif
      _status = _logBuff.serializeFrom(count);
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );

#if FW_AMPCS_COMPATIBLE
      // Serialize the argument size
      _status = _logBuff.serializeFrom(
        static_cast<U8>(sizeof(U16))
      );
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
#endif
      _status = _logBuff.serializeFrom(max);
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );

      this->m_logOut_OutputPort[0].invoke(
        _id,
        _logTime,
        Fw::LogSeverity::WARNING_HI,
        _logBuff
      );
    }

    // Emit the event on the text log port
#if FW_ENABLE_TEXT_LOGGING
    if (this->m_logTextOut_OutputPort[0].isConnected()) {
#if FW_OBJECT_NAMES == 1
      const char* _formatString =
        "(%s) %s: A sequence specified it had %" PRIu16 " directives but the max was %" PRIu16 "";
#else
      const char* _formatString =
        "%s: A sequence specified it had %" PRIu16 " directives but the max was %" PRIu16 "";
#endif

      Fw::TextLogString _logString;
      _logString.format(
        _formatString,
#if FW_OBJECT_NAMES == 1
        this->m_objName.toChar(),
#endif
        "TooManySequenceDirectives ",
        count,
        max
      );

      this->m_logTextOut_OutputPort[0].invoke(
        _id,
        _logTime,
        Fw::LogSeverity::WARNING_HI,
        _logString
      );
    }
#endif
  }

  void FpySequencerComponentBase ::
    log_ACTIVITY_HI_SequencePaused(U32 stmtIdx) const
  {
    // Get the time
    Fw::Time _logTime;
    if (this->m_timeCaller_OutputPort[0].isConnected()) {
      this->m_timeCaller_OutputPort[0].invoke(_logTime);
    }

    FwEventIdType _id = static_cast<FwEventIdType>(0);

    _id = this->getIdBase() + EVENTID_SEQUENCEPAUSED;

    // Emit the event on the log port
    if (this->m_logOut_OutputPort[0].isConnected()) {
      Fw::LogBuffer _logBuff;
      Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

#if FW_AMPCS_COMPATIBLE
      // Serialize the number of arguments
      _status = _logBuff.serializeFrom(static_cast<U8>(1));
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
#endif

#if FW_AMPCS_COMPATIBLE
      // Serialize the argument size
      _status = _logBuff.serializeFrom(
        static_cast<U8>(sizeof(U32))
      );
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
#endif
      _status = _logBuff.serializeFrom(stmtIdx);
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );

      this->m_logOut_OutputPort[0].invoke(
        _id,
        _logTime,
        Fw::LogSeverity::ACTIVITY_HI,
        _logBuff
      );
    }

    // Emit the event on the text log port
#if FW_ENABLE_TEXT_LOGGING
    if (this->m_logTextOut_OutputPort[0].isConnected()) {
#if FW_OBJECT_NAMES == 1
      const char* _formatString =
        "(%s) %s: Sequence paused before dispatching directive index %" PRIu32 "";
#else
      const char* _formatString =
        "%s: Sequence paused before dispatching directive index %" PRIu32 "";
#endif

      Fw::TextLogString _logString;
      _logString.format(
        _formatString,
#if FW_OBJECT_NAMES == 1
        this->m_objName.toChar(),
#endif
        "SequencePaused ",
        stmtIdx
      );

      this->m_logTextOut_OutputPort[0].invoke(
        _id,
        _logTime,
        Fw::LogSeverity::ACTIVITY_HI,
        _logString
      );
    }
#endif
  }

  void FpySequencerComponentBase ::
    log_ACTIVITY_HI_BreakpointSet(
        U32 breakpointIdx,
        bool breakOnce
    ) const
  {
    // Get the time
    Fw::Time _logTime;
    if (this->m_timeCaller_OutputPort[0].isConnected()) {
      this->m_timeCaller_OutputPort[0].invoke(_logTime);
    }

    FwEventIdType _id = static_cast<FwEventIdType>(0);

    _id = this->getIdBase() + EVENTID_BREAKPOINTSET;

    // Emit the event on the log port
    if (this->m_logOut_OutputPort[0].isConnected()) {
      Fw::LogBuffer _logBuff;
      Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

#if FW_AMPCS_COMPATIBLE
      // Serialize the number of arguments
      _status = _logBuff.serializeFrom(static_cast<U8>(2));
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
#endif

#if FW_AMPCS_COMPATIBLE
      // Serialize the argument size
      _status = _logBuff.serializeFrom(
        static_cast<U8>(sizeof(U32))
      );
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
#endif
      _status = _logBuff.serializeFrom(breakpointIdx);
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );

#if FW_AMPCS_COMPATIBLE
      // Serialize the argument size
      _status = _logBuff.serializeFrom(
        static_cast<U8>(sizeof(U8))
      );
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
#endif
      _status = _logBuff.serializeFrom(breakOnce);
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );

      this->m_logOut_OutputPort[0].invoke(
        _id,
        _logTime,
        Fw::LogSeverity::ACTIVITY_HI,
        _logBuff
      );
    }

    // Emit the event on the text log port
#if FW_ENABLE_TEXT_LOGGING
    if (this->m_logTextOut_OutputPort[0].isConnected()) {
#if FW_OBJECT_NAMES == 1
      const char* _formatString =
        "(%s) %s: Breakpoint set before directive index %" PRIu32 ". Will break once: %d";
#else
      const char* _formatString =
        "%s: Breakpoint set before directive index %" PRIu32 ". Will break once: %d";
#endif

      Fw::TextLogString _logString;
      _logString.format(
        _formatString,
#if FW_OBJECT_NAMES == 1
        this->m_objName.toChar(),
#endif
        "BreakpointSet ",
        breakpointIdx,
        breakOnce
      );

      this->m_logTextOut_OutputPort[0].invoke(
        _id,
        _logTime,
        Fw::LogSeverity::ACTIVITY_HI,
        _logString
      );
    }
#endif
  }

  void FpySequencerComponentBase ::
    log_ACTIVITY_HI_BreakpointCleared() const
  {
    // Get the time
    Fw::Time _logTime;
    if (this->m_timeCaller_OutputPort[0].isConnected()) {
      this->m_timeCaller_OutputPort[0].invoke(_logTime);
    }

    FwEventIdType _id = static_cast<FwEventIdType>(0);

    _id = this->getIdBase() + EVENTID_BREAKPOINTCLEARED;

    // Emit the event on the log port
    if (this->m_logOut_OutputPort[0].isConnected()) {
      Fw::LogBuffer _logBuff;

#if FW_AMPCS_COMPATIBLE
      Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;
      // Serialize the number of arguments
      _status = _logBuff.serializeFrom(static_cast<U8>(0));
      FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
      );
#endif

      this->m_logOut_OutputPort[0].invoke(
        _id,
        _logTime,
        Fw::LogSeverity::ACTIVITY_HI,
        _logBuff
      );
    }

    // Emit the event on the text log port
#if FW_ENABLE_TEXT_LOGGING
    if (this->m_logTextOut_OutputPort[0].isConnected()) {
#if FW_OBJECT_NAMES == 1
      const char* _formatString =
        "(%s) %s: Breakpoint cleared";
#else
      const char* _formatString =
        "%s: Breakpoint cleared";
#endif

      Fw::TextLogString _logString;
      _logString.format(
        _formatString,
#if FW_OBJECT_NAMES == 1
        this->m_objName.toChar(),
#endif
        "BreakpointCleared "
      );

      this->m_logTextOut_OutputPort[0].invoke(
        _id,
        _logTime,
        Fw::LogSeverity::ACTIVITY_HI,
        _logString
      );
    }
#endif
  }

  // ----------------------------------------------------------------------
  // Telemetry write functions
  // ----------------------------------------------------------------------

  void FpySequencerComponentBase ::
    tlmWrite_State(
        FwEnumStoreType arg,
        Fw::Time _tlmTime
    )
  {
    // Check to see if it is the first time
    if (not this->m_first_update_State) {
      // Check to see if value has changed. If not, don't write it.
      if (arg == this->m_last_State) {
        return;
      }
      else {
        this->m_last_State = arg;
      }
    }
    else {
      this->m_first_update_State = false;
      this->m_last_State = arg;
    }

    if (this->m_tlmOut_OutputPort[0].isConnected()) {
      if (
        this->m_timeCaller_OutputPort[0].isConnected() &&
        (_tlmTime ==  Fw::ZERO_TIME)
      ) {
        this->m_timeCaller_OutputPort[0].invoke(_tlmTime);
      }

      Fw::TlmBuffer _tlmBuff;
      Fw::SerializeStatus _stat = _tlmBuff.serializeFrom(arg);
      FW_ASSERT(
        _stat == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_stat)
      );

      FwChanIdType _id;

      _id = this->getIdBase() + CHANNELID_STATE;

      this->m_tlmOut_OutputPort[0].invoke(
        _id,
        _tlmTime,
        _tlmBuff
      );
    }
  }

  void FpySequencerComponentBase ::
    tlmWrite_SequencesSucceeded(
        U64 arg,
        Fw::Time _tlmTime
    )
  {
    // Check to see if it is the first time
    if (not this->m_first_update_SequencesSucceeded) {
      // Check to see if value has changed. If not, don't write it.
      if (arg == this->m_last_SequencesSucceeded) {
        return;
      }
      else {
        this->m_last_SequencesSucceeded = arg;
      }
    }
    else {
      this->m_first_update_SequencesSucceeded = false;
      this->m_last_SequencesSucceeded = arg;
    }

    if (this->m_tlmOut_OutputPort[0].isConnected()) {
      if (
        this->m_timeCaller_OutputPort[0].isConnected() &&
        (_tlmTime ==  Fw::ZERO_TIME)
      ) {
        this->m_timeCaller_OutputPort[0].invoke(_tlmTime);
      }

      Fw::TlmBuffer _tlmBuff;
      Fw::SerializeStatus _stat = _tlmBuff.serializeFrom(arg);
      FW_ASSERT(
        _stat == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_stat)
      );

      FwChanIdType _id;

      _id = this->getIdBase() + CHANNELID_SEQUENCESSUCCEEDED;

      this->m_tlmOut_OutputPort[0].invoke(
        _id,
        _tlmTime,
        _tlmBuff
      );
    }
  }

  void FpySequencerComponentBase ::
    tlmWrite_SequencesFailed(
        U64 arg,
        Fw::Time _tlmTime
    )
  {
    // Check to see if it is the first time
    if (not this->m_first_update_SequencesFailed) {
      // Check to see if value has changed. If not, don't write it.
      if (arg == this->m_last_SequencesFailed) {
        return;
      }
      else {
        this->m_last_SequencesFailed = arg;
      }
    }
    else {
      this->m_first_update_SequencesFailed = false;
      this->m_last_SequencesFailed = arg;
    }

    if (this->m_tlmOut_OutputPort[0].isConnected()) {
      if (
        this->m_timeCaller_OutputPort[0].isConnected() &&
        (_tlmTime ==  Fw::ZERO_TIME)
      ) {
        this->m_timeCaller_OutputPort[0].invoke(_tlmTime);
      }

      Fw::TlmBuffer _tlmBuff;
      Fw::SerializeStatus _stat = _tlmBuff.serializeFrom(arg);
      FW_ASSERT(
        _stat == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_stat)
      );

      FwChanIdType _id;

      _id = this->getIdBase() + CHANNELID_SEQUENCESFAILED;

      this->m_tlmOut_OutputPort[0].invoke(
        _id,
        _tlmTime,
        _tlmBuff
      );
    }
  }

  void FpySequencerComponentBase ::
    tlmWrite_SequencesCancelled(
        U64 arg,
        Fw::Time _tlmTime
    )
  {
    // Check to see if it is the first time
    if (not this->m_first_update_SequencesCancelled) {
      // Check to see if value has changed. If not, don't write it.
      if (arg == this->m_last_SequencesCancelled) {
        return;
      }
      else {
        this->m_last_SequencesCancelled = arg;
      }
    }
    else {
      this->m_first_update_SequencesCancelled = false;
      this->m_last_SequencesCancelled = arg;
    }

    if (this->m_tlmOut_OutputPort[0].isConnected()) {
      if (
        this->m_timeCaller_OutputPort[0].isConnected() &&
        (_tlmTime ==  Fw::ZERO_TIME)
      ) {
        this->m_timeCaller_OutputPort[0].invoke(_tlmTime);
      }

      Fw::TlmBuffer _tlmBuff;
      Fw::SerializeStatus _stat = _tlmBuff.serializeFrom(arg);
      FW_ASSERT(
        _stat == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_stat)
      );

      FwChanIdType _id;

      _id = this->getIdBase() + CHANNELID_SEQUENCESCANCELLED;

      this->m_tlmOut_OutputPort[0].invoke(
        _id,
        _tlmTime,
        _tlmBuff
      );
    }
  }

  void FpySequencerComponentBase ::
    tlmWrite_StatementsDispatched(
        U64 arg,
        Fw::Time _tlmTime
    )
  {
    // Check to see if it is the first time
    if (not this->m_first_update_StatementsDispatched) {
      // Check to see if value has changed. If not, don't write it.
      if (arg == this->m_last_StatementsDispatched) {
        return;
      }
      else {
        this->m_last_StatementsDispatched = arg;
      }
    }
    else {
      this->m_first_update_StatementsDispatched = false;
      this->m_last_StatementsDispatched = arg;
    }

    if (this->m_tlmOut_OutputPort[0].isConnected()) {
      if (
        this->m_timeCaller_OutputPort[0].isConnected() &&
        (_tlmTime ==  Fw::ZERO_TIME)
      ) {
        this->m_timeCaller_OutputPort[0].invoke(_tlmTime);
      }

      Fw::TlmBuffer _tlmBuff;
      Fw::SerializeStatus _stat = _tlmBuff.serializeFrom(arg);
      FW_ASSERT(
        _stat == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_stat)
      );

      FwChanIdType _id;

      _id = this->getIdBase() + CHANNELID_STATEMENTSDISPATCHED;

      this->m_tlmOut_OutputPort[0].invoke(
        _id,
        _tlmTime,
        _tlmBuff
      );
    }
  }

  void FpySequencerComponentBase ::
    tlmWrite_StatementsFailed(
        U64 arg,
        Fw::Time _tlmTime
    )
  {
    // Check to see if it is the first time
    if (not this->m_first_update_StatementsFailed) {
      // Check to see if value has changed. If not, don't write it.
      if (arg == this->m_last_StatementsFailed) {
        return;
      }
      else {
        this->m_last_StatementsFailed = arg;
      }
    }
    else {
      this->m_first_update_StatementsFailed = false;
      this->m_last_StatementsFailed = arg;
    }

    if (this->m_tlmOut_OutputPort[0].isConnected()) {
      if (
        this->m_timeCaller_OutputPort[0].isConnected() &&
        (_tlmTime ==  Fw::ZERO_TIME)
      ) {
        this->m_timeCaller_OutputPort[0].invoke(_tlmTime);
      }

      Fw::TlmBuffer _tlmBuff;
      Fw::SerializeStatus _stat = _tlmBuff.serializeFrom(arg);
      FW_ASSERT(
        _stat == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_stat)
      );

      FwChanIdType _id;

      _id = this->getIdBase() + CHANNELID_STATEMENTSFAILED;

      this->m_tlmOut_OutputPort[0].invoke(
        _id,
        _tlmTime,
        _tlmBuff
      );
    }
  }

  void FpySequencerComponentBase ::
    tlmWrite_LastDirectiveError(
        const Svc::Fpy::DirectiveErrorCode& arg,
        Fw::Time _tlmTime
    )
  {
    // Check to see if it is the first time
    if (not this->m_first_update_LastDirectiveError) {
      // Check to see if value has changed. If not, don't write it.
      if (arg == this->m_last_LastDirectiveError) {
        return;
      }
      else {
        this->m_last_LastDirectiveError = arg;
      }
    }
    else {
      this->m_first_update_LastDirectiveError = false;
      this->m_last_LastDirectiveError = arg;
    }

    if (this->m_tlmOut_OutputPort[0].isConnected()) {
      if (
        this->m_timeCaller_OutputPort[0].isConnected() &&
        (_tlmTime ==  Fw::ZERO_TIME)
      ) {
        this->m_timeCaller_OutputPort[0].invoke(_tlmTime);
      }

      Fw::TlmBuffer _tlmBuff;
      Fw::SerializeStatus _stat = _tlmBuff.serializeFrom(arg);
      FW_ASSERT(
        _stat == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_stat)
      );

      FwChanIdType _id;

      _id = this->getIdBase() + CHANNELID_LASTDIRECTIVEERROR;

      this->m_tlmOut_OutputPort[0].invoke(
        _id,
        _tlmTime,
        _tlmBuff
      );
    }
  }

  void FpySequencerComponentBase ::
    tlmWrite_DirectiveErrorIndex(
        U64 arg,
        Fw::Time _tlmTime
    )
  {
    // Check to see if it is the first time
    if (not this->m_first_update_DirectiveErrorIndex) {
      // Check to see if value has changed. If not, don't write it.
      if (arg == this->m_last_DirectiveErrorIndex) {
        return;
      }
      else {
        this->m_last_DirectiveErrorIndex = arg;
      }
    }
    else {
      this->m_first_update_DirectiveErrorIndex = false;
      this->m_last_DirectiveErrorIndex = arg;
    }

    if (this->m_tlmOut_OutputPort[0].isConnected()) {
      if (
        this->m_timeCaller_OutputPort[0].isConnected() &&
        (_tlmTime ==  Fw::ZERO_TIME)
      ) {
        this->m_timeCaller_OutputPort[0].invoke(_tlmTime);
      }

      Fw::TlmBuffer _tlmBuff;
      Fw::SerializeStatus _stat = _tlmBuff.serializeFrom(arg);
      FW_ASSERT(
        _stat == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_stat)
      );

      FwChanIdType _id;

      _id = this->getIdBase() + CHANNELID_DIRECTIVEERRORINDEX;

      this->m_tlmOut_OutputPort[0].invoke(
        _id,
        _tlmTime,
        _tlmBuff
      );
    }
  }

  void FpySequencerComponentBase ::
    tlmWrite_DirectiveErrorId(
        const Svc::Fpy::DirectiveId& arg,
        Fw::Time _tlmTime
    )
  {
    // Check to see if it is the first time
    if (not this->m_first_update_DirectiveErrorId) {
      // Check to see if value has changed. If not, don't write it.
      if (arg == this->m_last_DirectiveErrorId) {
        return;
      }
      else {
        this->m_last_DirectiveErrorId = arg;
      }
    }
    else {
      this->m_first_update_DirectiveErrorId = false;
      this->m_last_DirectiveErrorId = arg;
    }

    if (this->m_tlmOut_OutputPort[0].isConnected()) {
      if (
        this->m_timeCaller_OutputPort[0].isConnected() &&
        (_tlmTime ==  Fw::ZERO_TIME)
      ) {
        this->m_timeCaller_OutputPort[0].invoke(_tlmTime);
      }

      Fw::TlmBuffer _tlmBuff;
      Fw::SerializeStatus _stat = _tlmBuff.serializeFrom(arg);
      FW_ASSERT(
        _stat == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_stat)
      );

      FwChanIdType _id;

      _id = this->getIdBase() + CHANNELID_DIRECTIVEERRORID;

      this->m_tlmOut_OutputPort[0].invoke(
        _id,
        _tlmTime,
        _tlmBuff
      );
    }
  }

  void FpySequencerComponentBase ::
    tlmWrite_SeqPath(
        const Fw::StringBase& arg,
        Fw::Time _tlmTime
    )
  {
    // Check to see if it is the first time
    if (not this->m_first_update_SeqPath) {
      // Check to see if value has changed. If not, don't write it.
      if (arg == this->m_last_SeqPath) {
        return;
      }
      else {
        this->m_last_SeqPath = arg;
      }
    }
    else {
      this->m_first_update_SeqPath = false;
      this->m_last_SeqPath = arg;
    }

    if (this->m_tlmOut_OutputPort[0].isConnected()) {
      if (
        this->m_timeCaller_OutputPort[0].isConnected() &&
        (_tlmTime ==  Fw::ZERO_TIME)
      ) {
        this->m_timeCaller_OutputPort[0].invoke(_tlmTime);
      }

      Fw::TlmBuffer _tlmBuff;
      Fw::SerializeStatus _stat = arg.serializeTo(_tlmBuff, FW_MIN(FW_TLM_STRING_MAX_SIZE, 200));
      FW_ASSERT(
        _stat == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_stat)
      );

      FwChanIdType _id;

      _id = this->getIdBase() + CHANNELID_SEQPATH;

      this->m_tlmOut_OutputPort[0].invoke(
        _id,
        _tlmTime,
        _tlmBuff
      );
    }
  }

  void FpySequencerComponentBase ::
    tlmWrite_Debug_ReachedEndOfFile(
        bool arg,
        Fw::Time _tlmTime
    )
  {
    // Check to see if it is the first time
    if (not this->m_first_update_Debug_ReachedEndOfFile) {
      // Check to see if value has changed. If not, don't write it.
      if (arg == this->m_last_Debug_ReachedEndOfFile) {
        return;
      }
      else {
        this->m_last_Debug_ReachedEndOfFile = arg;
      }
    }
    else {
      this->m_first_update_Debug_ReachedEndOfFile = false;
      this->m_last_Debug_ReachedEndOfFile = arg;
    }

    if (this->m_tlmOut_OutputPort[0].isConnected()) {
      if (
        this->m_timeCaller_OutputPort[0].isConnected() &&
        (_tlmTime ==  Fw::ZERO_TIME)
      ) {
        this->m_timeCaller_OutputPort[0].invoke(_tlmTime);
      }

      Fw::TlmBuffer _tlmBuff;
      Fw::SerializeStatus _stat = _tlmBuff.serializeFrom(arg);
      FW_ASSERT(
        _stat == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_stat)
      );

      FwChanIdType _id;

      _id = this->getIdBase() + CHANNELID_DEBUG_REACHEDENDOFFILE;

      this->m_tlmOut_OutputPort[0].invoke(
        _id,
        _tlmTime,
        _tlmBuff
      );
    }
  }

  void FpySequencerComponentBase ::
    tlmWrite_Debug_NextStatementReadSuccess(
        bool arg,
        Fw::Time _tlmTime
    )
  {
    // Check to see if it is the first time
    if (not this->m_first_update_Debug_NextStatementReadSuccess) {
      // Check to see if value has changed. If not, don't write it.
      if (arg == this->m_last_Debug_NextStatementReadSuccess) {
        return;
      }
      else {
        this->m_last_Debug_NextStatementReadSuccess = arg;
      }
    }
    else {
      this->m_first_update_Debug_NextStatementReadSuccess = false;
      this->m_last_Debug_NextStatementReadSuccess = arg;
    }

    if (this->m_tlmOut_OutputPort[0].isConnected()) {
      if (
        this->m_timeCaller_OutputPort[0].isConnected() &&
        (_tlmTime ==  Fw::ZERO_TIME)
      ) {
        this->m_timeCaller_OutputPort[0].invoke(_tlmTime);
      }

      Fw::TlmBuffer _tlmBuff;
      Fw::SerializeStatus _stat = _tlmBuff.serializeFrom(arg);
      FW_ASSERT(
        _stat == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_stat)
      );

      FwChanIdType _id;

      _id = this->getIdBase() + CHANNELID_DEBUG_NEXTSTATEMENTREADSUCCESS;

      this->m_tlmOut_OutputPort[0].invoke(
        _id,
        _tlmTime,
        _tlmBuff
      );
    }
  }

  void FpySequencerComponentBase ::
    tlmWrite_Debug_NextStatementOpcode(
        U8 arg,
        Fw::Time _tlmTime
    )
  {
    // Check to see if it is the first time
    if (not this->m_first_update_Debug_NextStatementOpcode) {
      // Check to see if value has changed. If not, don't write it.
      if (arg == this->m_last_Debug_NextStatementOpcode) {
        return;
      }
      else {
        this->m_last_Debug_NextStatementOpcode = arg;
      }
    }
    else {
      this->m_first_update_Debug_NextStatementOpcode = false;
      this->m_last_Debug_NextStatementOpcode = arg;
    }

    if (this->m_tlmOut_OutputPort[0].isConnected()) {
      if (
        this->m_timeCaller_OutputPort[0].isConnected() &&
        (_tlmTime ==  Fw::ZERO_TIME)
      ) {
        this->m_timeCaller_OutputPort[0].invoke(_tlmTime);
      }

      Fw::TlmBuffer _tlmBuff;
      Fw::SerializeStatus _stat = _tlmBuff.serializeFrom(arg);
      FW_ASSERT(
        _stat == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_stat)
      );

      FwChanIdType _id;

      _id = this->getIdBase() + CHANNELID_DEBUG_NEXTSTATEMENTOPCODE;

      this->m_tlmOut_OutputPort[0].invoke(
        _id,
        _tlmTime,
        _tlmBuff
      );
    }
  }

  void FpySequencerComponentBase ::
    tlmWrite_Debug_NextCmdOpcode(
        FwOpcodeType arg,
        Fw::Time _tlmTime
    )
  {
    // Check to see if it is the first time
    if (not this->m_first_update_Debug_NextCmdOpcode) {
      // Check to see if value has changed. If not, don't write it.
      if (arg == this->m_last_Debug_NextCmdOpcode) {
        return;
      }
      else {
        this->m_last_Debug_NextCmdOpcode = arg;
      }
    }
    else {
      this->m_first_update_Debug_NextCmdOpcode = false;
      this->m_last_Debug_NextCmdOpcode = arg;
    }

    if (this->m_tlmOut_OutputPort[0].isConnected()) {
      if (
        this->m_timeCaller_OutputPort[0].isConnected() &&
        (_tlmTime ==  Fw::ZERO_TIME)
      ) {
        this->m_timeCaller_OutputPort[0].invoke(_tlmTime);
      }

      Fw::TlmBuffer _tlmBuff;
      Fw::SerializeStatus _stat = _tlmBuff.serializeFrom(arg);
      FW_ASSERT(
        _stat == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_stat)
      );

      FwChanIdType _id;

      _id = this->getIdBase() + CHANNELID_DEBUG_NEXTCMDOPCODE;

      this->m_tlmOut_OutputPort[0].invoke(
        _id,
        _tlmTime,
        _tlmBuff
      );
    }
  }

  void FpySequencerComponentBase ::
    tlmWrite_Debug_StackSize(
        Svc::Fpy::StackSizeType arg,
        Fw::Time _tlmTime
    )
  {
    // Check to see if it is the first time
    if (not this->m_first_update_Debug_StackSize) {
      // Check to see if value has changed. If not, don't write it.
      if (arg == this->m_last_Debug_StackSize) {
        return;
      }
      else {
        this->m_last_Debug_StackSize = arg;
      }
    }
    else {
      this->m_first_update_Debug_StackSize = false;
      this->m_last_Debug_StackSize = arg;
    }

    if (this->m_tlmOut_OutputPort[0].isConnected()) {
      if (
        this->m_timeCaller_OutputPort[0].isConnected() &&
        (_tlmTime ==  Fw::ZERO_TIME)
      ) {
        this->m_timeCaller_OutputPort[0].invoke(_tlmTime);
      }

      Fw::TlmBuffer _tlmBuff;
      Fw::SerializeStatus _stat = _tlmBuff.serializeFrom(arg);
      FW_ASSERT(
        _stat == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_stat)
      );

      FwChanIdType _id;

      _id = this->getIdBase() + CHANNELID_DEBUG_STACKSIZE;

      this->m_tlmOut_OutputPort[0].invoke(
        _id,
        _tlmTime,
        _tlmBuff
      );
    }
  }

  void FpySequencerComponentBase ::
    tlmWrite_BreakpointInUse(
        bool arg,
        Fw::Time _tlmTime
    )
  {
    // Check to see if it is the first time
    if (not this->m_first_update_BreakpointInUse) {
      // Check to see if value has changed. If not, don't write it.
      if (arg == this->m_last_BreakpointInUse) {
        return;
      }
      else {
        this->m_last_BreakpointInUse = arg;
      }
    }
    else {
      this->m_first_update_BreakpointInUse = false;
      this->m_last_BreakpointInUse = arg;
    }

    if (this->m_tlmOut_OutputPort[0].isConnected()) {
      if (
        this->m_timeCaller_OutputPort[0].isConnected() &&
        (_tlmTime ==  Fw::ZERO_TIME)
      ) {
        this->m_timeCaller_OutputPort[0].invoke(_tlmTime);
      }

      Fw::TlmBuffer _tlmBuff;
      Fw::SerializeStatus _stat = _tlmBuff.serializeFrom(arg);
      FW_ASSERT(
        _stat == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_stat)
      );

      FwChanIdType _id;

      _id = this->getIdBase() + CHANNELID_BREAKPOINTINUSE;

      this->m_tlmOut_OutputPort[0].invoke(
        _id,
        _tlmTime,
        _tlmBuff
      );
    }
  }

  void FpySequencerComponentBase ::
    tlmWrite_BreakpointIndex(
        U32 arg,
        Fw::Time _tlmTime
    )
  {
    // Check to see if it is the first time
    if (not this->m_first_update_BreakpointIndex) {
      // Check to see if value has changed. If not, don't write it.
      if (arg == this->m_last_BreakpointIndex) {
        return;
      }
      else {
        this->m_last_BreakpointIndex = arg;
      }
    }
    else {
      this->m_first_update_BreakpointIndex = false;
      this->m_last_BreakpointIndex = arg;
    }

    if (this->m_tlmOut_OutputPort[0].isConnected()) {
      if (
        this->m_timeCaller_OutputPort[0].isConnected() &&
        (_tlmTime ==  Fw::ZERO_TIME)
      ) {
        this->m_timeCaller_OutputPort[0].invoke(_tlmTime);
      }

      Fw::TlmBuffer _tlmBuff;
      Fw::SerializeStatus _stat = _tlmBuff.serializeFrom(arg);
      FW_ASSERT(
        _stat == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_stat)
      );

      FwChanIdType _id;

      _id = this->getIdBase() + CHANNELID_BREAKPOINTINDEX;

      this->m_tlmOut_OutputPort[0].invoke(
        _id,
        _tlmTime,
        _tlmBuff
      );
    }
  }

  void FpySequencerComponentBase ::
    tlmWrite_BreakOnlyOnceOnBreakpoint(
        bool arg,
        Fw::Time _tlmTime
    )
  {
    // Check to see if it is the first time
    if (not this->m_first_update_BreakOnlyOnceOnBreakpoint) {
      // Check to see if value has changed. If not, don't write it.
      if (arg == this->m_last_BreakOnlyOnceOnBreakpoint) {
        return;
      }
      else {
        this->m_last_BreakOnlyOnceOnBreakpoint = arg;
      }
    }
    else {
      this->m_first_update_BreakOnlyOnceOnBreakpoint = false;
      this->m_last_BreakOnlyOnceOnBreakpoint = arg;
    }

    if (this->m_tlmOut_OutputPort[0].isConnected()) {
      if (
        this->m_timeCaller_OutputPort[0].isConnected() &&
        (_tlmTime ==  Fw::ZERO_TIME)
      ) {
        this->m_timeCaller_OutputPort[0].invoke(_tlmTime);
      }

      Fw::TlmBuffer _tlmBuff;
      Fw::SerializeStatus _stat = _tlmBuff.serializeFrom(arg);
      FW_ASSERT(
        _stat == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_stat)
      );

      FwChanIdType _id;

      _id = this->getIdBase() + CHANNELID_BREAKONLYONCEONBREAKPOINT;

      this->m_tlmOut_OutputPort[0].invoke(
        _id,
        _tlmTime,
        _tlmBuff
      );
    }
  }

  void FpySequencerComponentBase ::
    tlmWrite_BreakBeforeNextLine(
        bool arg,
        Fw::Time _tlmTime
    )
  {
    // Check to see if it is the first time
    if (not this->m_first_update_BreakBeforeNextLine) {
      // Check to see if value has changed. If not, don't write it.
      if (arg == this->m_last_BreakBeforeNextLine) {
        return;
      }
      else {
        this->m_last_BreakBeforeNextLine = arg;
      }
    }
    else {
      this->m_first_update_BreakBeforeNextLine = false;
      this->m_last_BreakBeforeNextLine = arg;
    }

    if (this->m_tlmOut_OutputPort[0].isConnected()) {
      if (
        this->m_timeCaller_OutputPort[0].isConnected() &&
        (_tlmTime ==  Fw::ZERO_TIME)
      ) {
        this->m_timeCaller_OutputPort[0].invoke(_tlmTime);
      }

      Fw::TlmBuffer _tlmBuff;
      Fw::SerializeStatus _stat = _tlmBuff.serializeFrom(arg);
      FW_ASSERT(
        _stat == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_stat)
      );

      FwChanIdType _id;

      _id = this->getIdBase() + CHANNELID_BREAKBEFORENEXTLINE;

      this->m_tlmOut_OutputPort[0].invoke(
        _id,
        _tlmTime,
        _tlmBuff
      );
    }
  }

  void FpySequencerComponentBase ::
    tlmWrite_PRM_STATEMENT_TIMEOUT_SECS(
        F32 arg,
        Fw::Time _tlmTime
    )
  {
    // Check to see if it is the first time
    if (not this->m_first_update_PRM_STATEMENT_TIMEOUT_SECS) {
      // Check to see if value has changed. If not, don't write it.
      if (arg == this->m_last_PRM_STATEMENT_TIMEOUT_SECS) {
        return;
      }
      else {
        this->m_last_PRM_STATEMENT_TIMEOUT_SECS = arg;
      }
    }
    else {
      this->m_first_update_PRM_STATEMENT_TIMEOUT_SECS = false;
      this->m_last_PRM_STATEMENT_TIMEOUT_SECS = arg;
    }

    if (this->m_tlmOut_OutputPort[0].isConnected()) {
      if (
        this->m_timeCaller_OutputPort[0].isConnected() &&
        (_tlmTime ==  Fw::ZERO_TIME)
      ) {
        this->m_timeCaller_OutputPort[0].invoke(_tlmTime);
      }

      Fw::TlmBuffer _tlmBuff;
      Fw::SerializeStatus _stat = _tlmBuff.serializeFrom(arg);
      FW_ASSERT(
        _stat == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_stat)
      );

      FwChanIdType _id;

      _id = this->getIdBase() + CHANNELID_PRM_STATEMENT_TIMEOUT_SECS;

      this->m_tlmOut_OutputPort[0].invoke(
        _id,
        _tlmTime,
        _tlmBuff
      );
    }
  }

  void FpySequencerComponentBase ::
    tlmWrite_PRM_FLAG_DEFAULT_EXIT_ON_CMD_FAIL(
        bool arg,
        Fw::Time _tlmTime
    )
  {
    // Check to see if it is the first time
    if (not this->m_first_update_PRM_FLAG_DEFAULT_EXIT_ON_CMD_FAIL) {
      // Check to see if value has changed. If not, don't write it.
      if (arg == this->m_last_PRM_FLAG_DEFAULT_EXIT_ON_CMD_FAIL) {
        return;
      }
      else {
        this->m_last_PRM_FLAG_DEFAULT_EXIT_ON_CMD_FAIL = arg;
      }
    }
    else {
      this->m_first_update_PRM_FLAG_DEFAULT_EXIT_ON_CMD_FAIL = false;
      this->m_last_PRM_FLAG_DEFAULT_EXIT_ON_CMD_FAIL = arg;
    }

    if (this->m_tlmOut_OutputPort[0].isConnected()) {
      if (
        this->m_timeCaller_OutputPort[0].isConnected() &&
        (_tlmTime ==  Fw::ZERO_TIME)
      ) {
        this->m_timeCaller_OutputPort[0].invoke(_tlmTime);
      }

      Fw::TlmBuffer _tlmBuff;
      Fw::SerializeStatus _stat = _tlmBuff.serializeFrom(arg);
      FW_ASSERT(
        _stat == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_stat)
      );

      FwChanIdType _id;

      _id = this->getIdBase() + CHANNELID_PRM_FLAG_DEFAULT_EXIT_ON_CMD_FAIL;

      this->m_tlmOut_OutputPort[0].invoke(
        _id,
        _tlmTime,
        _tlmBuff
      );
    }
  }

  // ----------------------------------------------------------------------
  // Parameter update hook
  // ----------------------------------------------------------------------

  void FpySequencerComponentBase ::
    parameterUpdated(FwPrmIdType id)
  {
    // Do nothing by default
  }

  void FpySequencerComponentBase ::
    parametersLoaded()
  {
    // Do nothing by default
  }

  // ----------------------------------------------------------------------
  // Parameter get functions
  // ----------------------------------------------------------------------

  F32 FpySequencerComponentBase ::
    paramGet_STATEMENT_TIMEOUT_SECS(Fw::ParamValid& valid)
  {
    F32 _local{};
    this->m_paramLock.lock();
    valid = this->m_param_STATEMENT_TIMEOUT_SECS_valid;
    _local = this->m_STATEMENT_TIMEOUT_SECS;
    this->m_paramLock.unLock();
    return _local;
  }

  bool FpySequencerComponentBase ::
    paramGet_FLAG_DEFAULT_EXIT_ON_CMD_FAIL(Fw::ParamValid& valid)
  {
    bool _local{};
    this->m_paramLock.lock();
    valid = this->m_param_FLAG_DEFAULT_EXIT_ON_CMD_FAIL_valid;
    _local = this->m_FLAG_DEFAULT_EXIT_ON_CMD_FAIL;
    this->m_paramLock.unLock();
    return _local;
  }

  // ----------------------------------------------------------------------
  // Time
  // ----------------------------------------------------------------------

  Fw::Time FpySequencerComponentBase ::
    getTime() const
  {
    if (this->m_timeCaller_OutputPort[0].isConnected()) {
      Fw::Time _time;
      this->m_timeCaller_OutputPort[0].invoke(_time);
      return _time;
    }
    else {
      return Fw::Time(TimeBase::TB_NONE, 0, 0);
    }
  }

  // ----------------------------------------------------------------------
  // Message dispatch functions
  // ----------------------------------------------------------------------

  Fw::QueuedComponentBase::MsgDispatchStatus FpySequencerComponentBase ::
    doDispatch()
  {
    ComponentIpcSerializableBuffer _msg;
    FwQueuePriorityType _priority = 0;

    Os::Queue::Status _msgStatus = this->m_queue.receive(
      _msg,
      Os::Queue::BLOCKING,
      _priority
    );
    FW_ASSERT(
      _msgStatus == Os::Queue::OP_OK,
      static_cast<FwAssertArgType>(_msgStatus)
    );

    // Reset to beginning of buffer
    _msg.resetDeser();

    FwEnumStoreType _desMsg = 0;
    Fw::SerializeStatus _deserStatus = _msg.deserializeTo(_desMsg);
    FW_ASSERT(
      _deserStatus == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_deserStatus)
    );

    MsgTypeEnum _msgType = static_cast<MsgTypeEnum>(_desMsg);

    if (_msgType == FPYSEQUENCER_COMPONENT_EXIT) {
      return MSG_DISPATCH_EXIT;
    }

    FwIndexType portNum = 0;
    _deserStatus = _msg.deserializeTo(portNum);
    FW_ASSERT(
      _deserStatus == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_deserStatus)
    );

    switch (_msgType) {
      // Handle async input port checkTimers
      case CHECKTIMERS_SCHED: {
        // Deserialize argument context
        U32 context;
        _deserStatus = _msg.deserializeTo(context);
        FW_ASSERT(
          _deserStatus == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_deserStatus)
        );
        // Call handler function
        this->checkTimers_handler(
          portNum,
          context
        );

        break;
      }

      // Handle async input port cmdResponseIn
      case CMDRESPONSEIN_CMDRESPONSE: {
        // Deserialize argument opCode
        FwOpcodeType opCode;
        _deserStatus = _msg.deserializeTo(opCode);
        FW_ASSERT(
          _deserStatus == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_deserStatus)
        );

        // Deserialize argument cmdSeq
        U32 cmdSeq;
        _deserStatus = _msg.deserializeTo(cmdSeq);
        FW_ASSERT(
          _deserStatus == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_deserStatus)
        );

        // Deserialize argument response
        Fw::CmdResponse response;
        _deserStatus = _msg.deserializeTo(response);
        FW_ASSERT(
          _deserStatus == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_deserStatus)
        );
        // Call handler function
        this->cmdResponseIn_handler(
          portNum,
          opCode,
          cmdSeq,
          response
        );

        break;
      }

      // Handle async input port pingIn
      case PINGIN_PING: {
        // Deserialize argument key
        U32 key;
        _deserStatus = _msg.deserializeTo(key);
        FW_ASSERT(
          _deserStatus == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_deserStatus)
        );
        // Call handler function
        this->pingIn_handler(
          portNum,
          key
        );

        break;
      }

      // Handle async input port seqRunIn
      case SEQRUNIN_CMDSEQIN: {
        // Deserialize argument filename
        char __fprime_ac_filename_buffer[Fw::StringBase::BUFFER_SIZE(240)];
        Fw::ExternalString filename(__fprime_ac_filename_buffer, sizeof __fprime_ac_filename_buffer);
        _deserStatus = _msg.deserializeTo(filename);
        FW_ASSERT(
          _deserStatus == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_deserStatus)
        );
        // Call handler function
        this->seqRunIn_handler(
          portNum,
          filename
        );

        break;
      }

      // Handle async input port tlmWrite
      case TLMWRITE_SCHED: {
        // Deserialize argument context
        U32 context;
        _deserStatus = _msg.deserializeTo(context);
        FW_ASSERT(
          _deserStatus == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_deserStatus)
        );
        // Call handler function
        this->tlmWrite_handler(
          portNum,
          context
        );

        break;
      }

      // Handle command RUN
      case CMD_RUN: {
        // Deserialize opcode
        FwOpcodeType _opCode = 0;
        _deserStatus = _msg.deserializeTo(_opCode);
        FW_ASSERT (
          _deserStatus == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_deserStatus)
        );

        // Deserialize command sequence
        U32 _cmdSeq = 0;
        _deserStatus = _msg.deserializeTo(_cmdSeq);
        FW_ASSERT (
          _deserStatus == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_deserStatus)
        );

        // Deserialize command argument buffer
        Fw::CmdArgBuffer args;
        _deserStatus = _msg.deserializeTo(args);
        FW_ASSERT (
          _deserStatus == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_deserStatus)
        );

        // Reset buffer
        args.resetDeser();

        // Deserialize argument fileName
        Fw::CmdStringArg fileName;
        _deserStatus = args.deserializeTo(fileName);
        if (_deserStatus != Fw::FW_SERIALIZE_OK) {
          if (this->m_cmdResponseOut_OutputPort[0].isConnected()) {
            this->cmdResponse_out(
                _opCode,
                _cmdSeq,
                Fw::CmdResponse::FORMAT_ERROR
            );
          }
          // Don't crash the task if bad arguments were passed from the ground
          break;
        }

        // Deserialize argument block
        Svc::FpySequencer_BlockState block;
        _deserStatus = args.deserializeTo(block);
        if (_deserStatus != Fw::FW_SERIALIZE_OK) {
          if (this->m_cmdResponseOut_OutputPort[0].isConnected()) {
            this->cmdResponse_out(
                _opCode,
                _cmdSeq,
                Fw::CmdResponse::FORMAT_ERROR
            );
          }
          // Don't crash the task if bad arguments were passed from the ground
          break;
        }

        // Make sure there was no data left over.
        // That means the argument buffer size was incorrect.
#if FW_CMD_CHECK_RESIDUAL
        if (args.getDeserializeSizeLeft() != 0) {
          if (this->m_cmdResponseOut_OutputPort[0].isConnected()) {
            this->cmdResponse_out(_opCode, _cmdSeq, Fw::CmdResponse::FORMAT_ERROR);
          }
          // Don't crash the task if bad arguments were passed from the ground
          break;
        }
#endif

        // Call handler function
        this->RUN_cmdHandler(
          _opCode, _cmdSeq,
          fileName,
          block
        );

        break;
      }

      // Handle command VALIDATE
      case CMD_VALIDATE: {
        // Deserialize opcode
        FwOpcodeType _opCode = 0;
        _deserStatus = _msg.deserializeTo(_opCode);
        FW_ASSERT (
          _deserStatus == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_deserStatus)
        );

        // Deserialize command sequence
        U32 _cmdSeq = 0;
        _deserStatus = _msg.deserializeTo(_cmdSeq);
        FW_ASSERT (
          _deserStatus == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_deserStatus)
        );

        // Deserialize command argument buffer
        Fw::CmdArgBuffer args;
        _deserStatus = _msg.deserializeTo(args);
        FW_ASSERT (
          _deserStatus == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_deserStatus)
        );

        // Reset buffer
        args.resetDeser();

        // Deserialize argument fileName
        Fw::CmdStringArg fileName;
        _deserStatus = args.deserializeTo(fileName);
        if (_deserStatus != Fw::FW_SERIALIZE_OK) {
          if (this->m_cmdResponseOut_OutputPort[0].isConnected()) {
            this->cmdResponse_out(
                _opCode,
                _cmdSeq,
                Fw::CmdResponse::FORMAT_ERROR
            );
          }
          // Don't crash the task if bad arguments were passed from the ground
          break;
        }

        // Make sure there was no data left over.
        // That means the argument buffer size was incorrect.
#if FW_CMD_CHECK_RESIDUAL
        if (args.getDeserializeSizeLeft() != 0) {
          if (this->m_cmdResponseOut_OutputPort[0].isConnected()) {
            this->cmdResponse_out(_opCode, _cmdSeq, Fw::CmdResponse::FORMAT_ERROR);
          }
          // Don't crash the task if bad arguments were passed from the ground
          break;
        }
#endif

        // Call handler function
        this->VALIDATE_cmdHandler(
          _opCode, _cmdSeq,
          fileName
        );

        break;
      }

      // Handle command RUN_VALIDATED
      case CMD_RUN_VALIDATED: {
        // Deserialize opcode
        FwOpcodeType _opCode = 0;
        _deserStatus = _msg.deserializeTo(_opCode);
        FW_ASSERT (
          _deserStatus == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_deserStatus)
        );

        // Deserialize command sequence
        U32 _cmdSeq = 0;
        _deserStatus = _msg.deserializeTo(_cmdSeq);
        FW_ASSERT (
          _deserStatus == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_deserStatus)
        );

        // Deserialize command argument buffer
        Fw::CmdArgBuffer args;
        _deserStatus = _msg.deserializeTo(args);
        FW_ASSERT (
          _deserStatus == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_deserStatus)
        );

        // Reset buffer
        args.resetDeser();

        // Deserialize argument block
        Svc::FpySequencer_BlockState block;
        _deserStatus = args.deserializeTo(block);
        if (_deserStatus != Fw::FW_SERIALIZE_OK) {
          if (this->m_cmdResponseOut_OutputPort[0].isConnected()) {
            this->cmdResponse_out(
                _opCode,
                _cmdSeq,
                Fw::CmdResponse::FORMAT_ERROR
            );
          }
          // Don't crash the task if bad arguments were passed from the ground
          break;
        }

        // Make sure there was no data left over.
        // That means the argument buffer size was incorrect.
#if FW_CMD_CHECK_RESIDUAL
        if (args.getDeserializeSizeLeft() != 0) {
          if (this->m_cmdResponseOut_OutputPort[0].isConnected()) {
            this->cmdResponse_out(_opCode, _cmdSeq, Fw::CmdResponse::FORMAT_ERROR);
          }
          // Don't crash the task if bad arguments were passed from the ground
          break;
        }
#endif

        // Call handler function
        this->RUN_VALIDATED_cmdHandler(
          _opCode, _cmdSeq,
          block
        );

        break;
      }

      // Handle command CANCEL
      case CMD_CANCEL: {
        // Deserialize opcode
        FwOpcodeType _opCode = 0;
        _deserStatus = _msg.deserializeTo(_opCode);
        FW_ASSERT (
          _deserStatus == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_deserStatus)
        );

        // Deserialize command sequence
        U32 _cmdSeq = 0;
        _deserStatus = _msg.deserializeTo(_cmdSeq);
        FW_ASSERT (
          _deserStatus == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_deserStatus)
        );

        // Deserialize command argument buffer
        Fw::CmdArgBuffer args;
        _deserStatus = _msg.deserializeTo(args);
        FW_ASSERT (
          _deserStatus == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_deserStatus)
        );

        // Reset buffer
        args.resetDeser();

        // Make sure there was no data left over.
        // That means the argument buffer size was incorrect.
#if FW_CMD_CHECK_RESIDUAL
        if (args.getDeserializeSizeLeft() != 0) {
          if (this->m_cmdResponseOut_OutputPort[0].isConnected()) {
            this->cmdResponse_out(_opCode, _cmdSeq, Fw::CmdResponse::FORMAT_ERROR);
          }
          // Don't crash the task if bad arguments were passed from the ground
          break;
        }
#endif

        // Call handler function
        this->CANCEL_cmdHandler(_opCode, _cmdSeq);

        break;
      }

      // Handle command SET_BREAKPOINT
      case CMD_SET_BREAKPOINT: {
        // Deserialize opcode
        FwOpcodeType _opCode = 0;
        _deserStatus = _msg.deserializeTo(_opCode);
        FW_ASSERT (
          _deserStatus == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_deserStatus)
        );

        // Deserialize command sequence
        U32 _cmdSeq = 0;
        _deserStatus = _msg.deserializeTo(_cmdSeq);
        FW_ASSERT (
          _deserStatus == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_deserStatus)
        );

        // Deserialize command argument buffer
        Fw::CmdArgBuffer args;
        _deserStatus = _msg.deserializeTo(args);
        FW_ASSERT (
          _deserStatus == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_deserStatus)
        );

        // Reset buffer
        args.resetDeser();

        // Deserialize argument stmtIdx
        U32 stmtIdx;
        _deserStatus = args.deserializeTo(stmtIdx);
        if (_deserStatus != Fw::FW_SERIALIZE_OK) {
          if (this->m_cmdResponseOut_OutputPort[0].isConnected()) {
            this->cmdResponse_out(
                _opCode,
                _cmdSeq,
                Fw::CmdResponse::FORMAT_ERROR
            );
          }
          // Don't crash the task if bad arguments were passed from the ground
          break;
        }

        // Deserialize argument breakOnce
        bool breakOnce;
        _deserStatus = args.deserializeTo(breakOnce);
        if (_deserStatus != Fw::FW_SERIALIZE_OK) {
          if (this->m_cmdResponseOut_OutputPort[0].isConnected()) {
            this->cmdResponse_out(
                _opCode,
                _cmdSeq,
                Fw::CmdResponse::FORMAT_ERROR
            );
          }
          // Don't crash the task if bad arguments were passed from the ground
          break;
        }

        // Make sure there was no data left over.
        // That means the argument buffer size was incorrect.
#if FW_CMD_CHECK_RESIDUAL
        if (args.getDeserializeSizeLeft() != 0) {
          if (this->m_cmdResponseOut_OutputPort[0].isConnected()) {
            this->cmdResponse_out(_opCode, _cmdSeq, Fw::CmdResponse::FORMAT_ERROR);
          }
          // Don't crash the task if bad arguments were passed from the ground
          break;
        }
#endif

        // Call handler function
        this->SET_BREAKPOINT_cmdHandler(
          _opCode, _cmdSeq,
          stmtIdx,
          breakOnce
        );

        break;
      }

      // Handle command BREAK
      case CMD_BREAK: {
        // Deserialize opcode
        FwOpcodeType _opCode = 0;
        _deserStatus = _msg.deserializeTo(_opCode);
        FW_ASSERT (
          _deserStatus == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_deserStatus)
        );

        // Deserialize command sequence
        U32 _cmdSeq = 0;
        _deserStatus = _msg.deserializeTo(_cmdSeq);
        FW_ASSERT (
          _deserStatus == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_deserStatus)
        );

        // Deserialize command argument buffer
        Fw::CmdArgBuffer args;
        _deserStatus = _msg.deserializeTo(args);
        FW_ASSERT (
          _deserStatus == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_deserStatus)
        );

        // Reset buffer
        args.resetDeser();

        // Make sure there was no data left over.
        // That means the argument buffer size was incorrect.
#if FW_CMD_CHECK_RESIDUAL
        if (args.getDeserializeSizeLeft() != 0) {
          if (this->m_cmdResponseOut_OutputPort[0].isConnected()) {
            this->cmdResponse_out(_opCode, _cmdSeq, Fw::CmdResponse::FORMAT_ERROR);
          }
          // Don't crash the task if bad arguments were passed from the ground
          break;
        }
#endif

        // Call handler function
        this->BREAK_cmdHandler(_opCode, _cmdSeq);

        break;
      }

      // Handle command CONTINUE
      case CMD_CONTINUE: {
        // Deserialize opcode
        FwOpcodeType _opCode = 0;
        _deserStatus = _msg.deserializeTo(_opCode);
        FW_ASSERT (
          _deserStatus == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_deserStatus)
        );

        // Deserialize command sequence
        U32 _cmdSeq = 0;
        _deserStatus = _msg.deserializeTo(_cmdSeq);
        FW_ASSERT (
          _deserStatus == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_deserStatus)
        );

        // Deserialize command argument buffer
        Fw::CmdArgBuffer args;
        _deserStatus = _msg.deserializeTo(args);
        FW_ASSERT (
          _deserStatus == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_deserStatus)
        );

        // Reset buffer
        args.resetDeser();

        // Make sure there was no data left over.
        // That means the argument buffer size was incorrect.
#if FW_CMD_CHECK_RESIDUAL
        if (args.getDeserializeSizeLeft() != 0) {
          if (this->m_cmdResponseOut_OutputPort[0].isConnected()) {
            this->cmdResponse_out(_opCode, _cmdSeq, Fw::CmdResponse::FORMAT_ERROR);
          }
          // Don't crash the task if bad arguments were passed from the ground
          break;
        }
#endif

        // Call handler function
        this->CONTINUE_cmdHandler(_opCode, _cmdSeq);

        break;
      }

      // Handle command CLEAR_BREAKPOINT
      case CMD_CLEAR_BREAKPOINT: {
        // Deserialize opcode
        FwOpcodeType _opCode = 0;
        _deserStatus = _msg.deserializeTo(_opCode);
        FW_ASSERT (
          _deserStatus == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_deserStatus)
        );

        // Deserialize command sequence
        U32 _cmdSeq = 0;
        _deserStatus = _msg.deserializeTo(_cmdSeq);
        FW_ASSERT (
          _deserStatus == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_deserStatus)
        );

        // Deserialize command argument buffer
        Fw::CmdArgBuffer args;
        _deserStatus = _msg.deserializeTo(args);
        FW_ASSERT (
          _deserStatus == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_deserStatus)
        );

        // Reset buffer
        args.resetDeser();

        // Make sure there was no data left over.
        // That means the argument buffer size was incorrect.
#if FW_CMD_CHECK_RESIDUAL
        if (args.getDeserializeSizeLeft() != 0) {
          if (this->m_cmdResponseOut_OutputPort[0].isConnected()) {
            this->cmdResponse_out(_opCode, _cmdSeq, Fw::CmdResponse::FORMAT_ERROR);
          }
          // Don't crash the task if bad arguments were passed from the ground
          break;
        }
#endif

        // Call handler function
        this->CLEAR_BREAKPOINT_cmdHandler(_opCode, _cmdSeq);

        break;
      }

      // Handle command STEP
      case CMD_STEP: {
        // Deserialize opcode
        FwOpcodeType _opCode = 0;
        _deserStatus = _msg.deserializeTo(_opCode);
        FW_ASSERT (
          _deserStatus == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_deserStatus)
        );

        // Deserialize command sequence
        U32 _cmdSeq = 0;
        _deserStatus = _msg.deserializeTo(_cmdSeq);
        FW_ASSERT (
          _deserStatus == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_deserStatus)
        );

        // Deserialize command argument buffer
        Fw::CmdArgBuffer args;
        _deserStatus = _msg.deserializeTo(args);
        FW_ASSERT (
          _deserStatus == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_deserStatus)
        );

        // Reset buffer
        args.resetDeser();

        // Make sure there was no data left over.
        // That means the argument buffer size was incorrect.
#if FW_CMD_CHECK_RESIDUAL
        if (args.getDeserializeSizeLeft() != 0) {
          if (this->m_cmdResponseOut_OutputPort[0].isConnected()) {
            this->cmdResponse_out(_opCode, _cmdSeq, Fw::CmdResponse::FORMAT_ERROR);
          }
          // Don't crash the task if bad arguments were passed from the ground
          break;
        }
#endif

        // Call handler function
        this->STEP_cmdHandler(_opCode, _cmdSeq);

        break;
      }

      // Handle command SET_FLAG
      case CMD_SET_FLAG: {
        // Deserialize opcode
        FwOpcodeType _opCode = 0;
        _deserStatus = _msg.deserializeTo(_opCode);
        FW_ASSERT (
          _deserStatus == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_deserStatus)
        );

        // Deserialize command sequence
        U32 _cmdSeq = 0;
        _deserStatus = _msg.deserializeTo(_cmdSeq);
        FW_ASSERT (
          _deserStatus == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_deserStatus)
        );

        // Deserialize command argument buffer
        Fw::CmdArgBuffer args;
        _deserStatus = _msg.deserializeTo(args);
        FW_ASSERT (
          _deserStatus == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_deserStatus)
        );

        // Reset buffer
        args.resetDeser();

        // Deserialize argument flag
        Svc::Fpy::FlagId flag;
        _deserStatus = args.deserializeTo(flag);
        if (_deserStatus != Fw::FW_SERIALIZE_OK) {
          if (this->m_cmdResponseOut_OutputPort[0].isConnected()) {
            this->cmdResponse_out(
                _opCode,
                _cmdSeq,
                Fw::CmdResponse::FORMAT_ERROR
            );
          }
          // Don't crash the task if bad arguments were passed from the ground
          break;
        }

        // Deserialize argument value
        bool value;
        _deserStatus = args.deserializeTo(value);
        if (_deserStatus != Fw::FW_SERIALIZE_OK) {
          if (this->m_cmdResponseOut_OutputPort[0].isConnected()) {
            this->cmdResponse_out(
                _opCode,
                _cmdSeq,
                Fw::CmdResponse::FORMAT_ERROR
            );
          }
          // Don't crash the task if bad arguments were passed from the ground
          break;
        }

        // Make sure there was no data left over.
        // That means the argument buffer size was incorrect.
#if FW_CMD_CHECK_RESIDUAL
        if (args.getDeserializeSizeLeft() != 0) {
          if (this->m_cmdResponseOut_OutputPort[0].isConnected()) {
            this->cmdResponse_out(_opCode, _cmdSeq, Fw::CmdResponse::FORMAT_ERROR);
          }
          // Don't crash the task if bad arguments were passed from the ground
          break;
        }
#endif

        // Call handler function
        this->SET_FLAG_cmdHandler(
          _opCode, _cmdSeq,
          flag,
          value
        );

        break;
      }

      // Handle command DUMP_STACK_TO_FILE
      case CMD_DUMP_STACK_TO_FILE: {
        // Deserialize opcode
        FwOpcodeType _opCode = 0;
        _deserStatus = _msg.deserializeTo(_opCode);
        FW_ASSERT (
          _deserStatus == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_deserStatus)
        );

        // Deserialize command sequence
        U32 _cmdSeq = 0;
        _deserStatus = _msg.deserializeTo(_cmdSeq);
        FW_ASSERT (
          _deserStatus == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_deserStatus)
        );

        // Deserialize command argument buffer
        Fw::CmdArgBuffer args;
        _deserStatus = _msg.deserializeTo(args);
        FW_ASSERT (
          _deserStatus == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_deserStatus)
        );

        // Reset buffer
        args.resetDeser();

        // Deserialize argument fileName
        Fw::CmdStringArg fileName;
        _deserStatus = args.deserializeTo(fileName);
        if (_deserStatus != Fw::FW_SERIALIZE_OK) {
          if (this->m_cmdResponseOut_OutputPort[0].isConnected()) {
            this->cmdResponse_out(
                _opCode,
                _cmdSeq,
                Fw::CmdResponse::FORMAT_ERROR
            );
          }
          // Don't crash the task if bad arguments were passed from the ground
          break;
        }

        // Make sure there was no data left over.
        // That means the argument buffer size was incorrect.
#if FW_CMD_CHECK_RESIDUAL
        if (args.getDeserializeSizeLeft() != 0) {
          if (this->m_cmdResponseOut_OutputPort[0].isConnected()) {
            this->cmdResponse_out(_opCode, _cmdSeq, Fw::CmdResponse::FORMAT_ERROR);
          }
          // Don't crash the task if bad arguments were passed from the ground
          break;
        }
#endif

        // Call handler function
        this->DUMP_STACK_TO_FILE_cmdHandler(
          _opCode, _cmdSeq,
          fileName
        );

        break;
      }

      // Handle internal interface directive_allocate
      case INT_IF_DIRECTIVE_ALLOCATE: {
        Svc::FpySequencer_AllocateDirective directive;
        _deserStatus = _msg.deserializeTo(directive);

        // Internal interface should always deserialize
        FW_ASSERT(
          Fw::FW_SERIALIZE_OK == _deserStatus,
          static_cast<FwAssertArgType>(_deserStatus)
        );

        // Make sure there was no data left over.
        // That means the buffer size was incorrect.
        FW_ASSERT(
          _msg.getDeserializeSizeLeft() == 0,
          static_cast<FwAssertArgType>(_msg.getDeserializeSizeLeft())
        );

        // Call handler function
        this->directive_allocate_internalInterfaceHandler(
          directive
        );

        break;
      }

      // Handle internal interface directive_constCmd
      case INT_IF_DIRECTIVE_CONSTCMD: {
        Svc::FpySequencer_ConstCmdDirective directive;
        _deserStatus = _msg.deserializeTo(directive);

        // Internal interface should always deserialize
        FW_ASSERT(
          Fw::FW_SERIALIZE_OK == _deserStatus,
          static_cast<FwAssertArgType>(_deserStatus)
        );

        // Make sure there was no data left over.
        // That means the buffer size was incorrect.
        FW_ASSERT(
          _msg.getDeserializeSizeLeft() == 0,
          static_cast<FwAssertArgType>(_msg.getDeserializeSizeLeft())
        );

        // Call handler function
        this->directive_constCmd_internalInterfaceHandler(
          directive
        );

        break;
      }

      // Handle internal interface directive_discard
      case INT_IF_DIRECTIVE_DISCARD: {
        Svc::FpySequencer_DiscardDirective directive;
        _deserStatus = _msg.deserializeTo(directive);

        // Internal interface should always deserialize
        FW_ASSERT(
          Fw::FW_SERIALIZE_OK == _deserStatus,
          static_cast<FwAssertArgType>(_deserStatus)
        );

        // Make sure there was no data left over.
        // That means the buffer size was incorrect.
        FW_ASSERT(
          _msg.getDeserializeSizeLeft() == 0,
          static_cast<FwAssertArgType>(_msg.getDeserializeSizeLeft())
        );

        // Call handler function
        this->directive_discard_internalInterfaceHandler(
          directive
        );

        break;
      }

      // Handle internal interface directive_exit
      case INT_IF_DIRECTIVE_EXIT: {
        Svc::FpySequencer_ExitDirective directive;
        _deserStatus = _msg.deserializeTo(directive);

        // Internal interface should always deserialize
        FW_ASSERT(
          Fw::FW_SERIALIZE_OK == _deserStatus,
          static_cast<FwAssertArgType>(_deserStatus)
        );

        // Make sure there was no data left over.
        // That means the buffer size was incorrect.
        FW_ASSERT(
          _msg.getDeserializeSizeLeft() == 0,
          static_cast<FwAssertArgType>(_msg.getDeserializeSizeLeft())
        );

        // Call handler function
        this->directive_exit_internalInterfaceHandler(
          directive
        );

        break;
      }

      // Handle internal interface directive_getField
      case INT_IF_DIRECTIVE_GETFIELD: {
        Svc::FpySequencer_GetFieldDirective directive;
        _deserStatus = _msg.deserializeTo(directive);

        // Internal interface should always deserialize
        FW_ASSERT(
          Fw::FW_SERIALIZE_OK == _deserStatus,
          static_cast<FwAssertArgType>(_deserStatus)
        );

        // Make sure there was no data left over.
        // That means the buffer size was incorrect.
        FW_ASSERT(
          _msg.getDeserializeSizeLeft() == 0,
          static_cast<FwAssertArgType>(_msg.getDeserializeSizeLeft())
        );

        // Call handler function
        this->directive_getField_internalInterfaceHandler(
          directive
        );

        break;
      }

      // Handle internal interface directive_getFlag
      case INT_IF_DIRECTIVE_GETFLAG: {
        Svc::FpySequencer_GetFlagDirective directive;
        _deserStatus = _msg.deserializeTo(directive);

        // Internal interface should always deserialize
        FW_ASSERT(
          Fw::FW_SERIALIZE_OK == _deserStatus,
          static_cast<FwAssertArgType>(_deserStatus)
        );

        // Make sure there was no data left over.
        // That means the buffer size was incorrect.
        FW_ASSERT(
          _msg.getDeserializeSizeLeft() == 0,
          static_cast<FwAssertArgType>(_msg.getDeserializeSizeLeft())
        );

        // Call handler function
        this->directive_getFlag_internalInterfaceHandler(
          directive
        );

        break;
      }

      // Handle internal interface directive_goto
      case INT_IF_DIRECTIVE_GOTO: {
        Svc::FpySequencer_GotoDirective directive;
        _deserStatus = _msg.deserializeTo(directive);

        // Internal interface should always deserialize
        FW_ASSERT(
          Fw::FW_SERIALIZE_OK == _deserStatus,
          static_cast<FwAssertArgType>(_deserStatus)
        );

        // Make sure there was no data left over.
        // That means the buffer size was incorrect.
        FW_ASSERT(
          _msg.getDeserializeSizeLeft() == 0,
          static_cast<FwAssertArgType>(_msg.getDeserializeSizeLeft())
        );

        // Call handler function
        this->directive_goto_internalInterfaceHandler(
          directive
        );

        break;
      }

      // Handle internal interface directive_if
      case INT_IF_DIRECTIVE_IF: {
        Svc::FpySequencer_IfDirective directive;
        _deserStatus = _msg.deserializeTo(directive);

        // Internal interface should always deserialize
        FW_ASSERT(
          Fw::FW_SERIALIZE_OK == _deserStatus,
          static_cast<FwAssertArgType>(_deserStatus)
        );

        // Make sure there was no data left over.
        // That means the buffer size was incorrect.
        FW_ASSERT(
          _msg.getDeserializeSizeLeft() == 0,
          static_cast<FwAssertArgType>(_msg.getDeserializeSizeLeft())
        );

        // Call handler function
        this->directive_if_internalInterfaceHandler(
          directive
        );

        break;
      }

      // Handle internal interface directive_load
      case INT_IF_DIRECTIVE_LOAD: {
        Svc::FpySequencer_LoadDirective directive;
        _deserStatus = _msg.deserializeTo(directive);

        // Internal interface should always deserialize
        FW_ASSERT(
          Fw::FW_SERIALIZE_OK == _deserStatus,
          static_cast<FwAssertArgType>(_deserStatus)
        );

        // Make sure there was no data left over.
        // That means the buffer size was incorrect.
        FW_ASSERT(
          _msg.getDeserializeSizeLeft() == 0,
          static_cast<FwAssertArgType>(_msg.getDeserializeSizeLeft())
        );

        // Call handler function
        this->directive_load_internalInterfaceHandler(
          directive
        );

        break;
      }

      // Handle internal interface directive_memCmp
      case INT_IF_DIRECTIVE_MEMCMP: {
        Svc::FpySequencer_MemCmpDirective directive;
        _deserStatus = _msg.deserializeTo(directive);

        // Internal interface should always deserialize
        FW_ASSERT(
          Fw::FW_SERIALIZE_OK == _deserStatus,
          static_cast<FwAssertArgType>(_deserStatus)
        );

        // Make sure there was no data left over.
        // That means the buffer size was incorrect.
        FW_ASSERT(
          _msg.getDeserializeSizeLeft() == 0,
          static_cast<FwAssertArgType>(_msg.getDeserializeSizeLeft())
        );

        // Call handler function
        this->directive_memCmp_internalInterfaceHandler(
          directive
        );

        break;
      }

      // Handle internal interface directive_noOp
      case INT_IF_DIRECTIVE_NOOP: {
        Svc::FpySequencer_NoOpDirective directive;
        _deserStatus = _msg.deserializeTo(directive);

        // Internal interface should always deserialize
        FW_ASSERT(
          Fw::FW_SERIALIZE_OK == _deserStatus,
          static_cast<FwAssertArgType>(_deserStatus)
        );

        // Make sure there was no data left over.
        // That means the buffer size was incorrect.
        FW_ASSERT(
          _msg.getDeserializeSizeLeft() == 0,
          static_cast<FwAssertArgType>(_msg.getDeserializeSizeLeft())
        );

        // Call handler function
        this->directive_noOp_internalInterfaceHandler(
          directive
        );

        break;
      }

      // Handle internal interface directive_peek
      case INT_IF_DIRECTIVE_PEEK: {
        Svc::FpySequencer_PeekDirective directive;
        _deserStatus = _msg.deserializeTo(directive);

        // Internal interface should always deserialize
        FW_ASSERT(
          Fw::FW_SERIALIZE_OK == _deserStatus,
          static_cast<FwAssertArgType>(_deserStatus)
        );

        // Make sure there was no data left over.
        // That means the buffer size was incorrect.
        FW_ASSERT(
          _msg.getDeserializeSizeLeft() == 0,
          static_cast<FwAssertArgType>(_msg.getDeserializeSizeLeft())
        );

        // Call handler function
        this->directive_peek_internalInterfaceHandler(
          directive
        );

        break;
      }

      // Handle internal interface directive_pushPrm
      case INT_IF_DIRECTIVE_PUSHPRM: {
        Svc::FpySequencer_PushPrmDirective directive;
        _deserStatus = _msg.deserializeTo(directive);

        // Internal interface should always deserialize
        FW_ASSERT(
          Fw::FW_SERIALIZE_OK == _deserStatus,
          static_cast<FwAssertArgType>(_deserStatus)
        );

        // Make sure there was no data left over.
        // That means the buffer size was incorrect.
        FW_ASSERT(
          _msg.getDeserializeSizeLeft() == 0,
          static_cast<FwAssertArgType>(_msg.getDeserializeSizeLeft())
        );

        // Call handler function
        this->directive_pushPrm_internalInterfaceHandler(
          directive
        );

        break;
      }

      // Handle internal interface directive_pushTime
      case INT_IF_DIRECTIVE_PUSHTIME: {
        Svc::FpySequencer_PushTimeDirective directive;
        _deserStatus = _msg.deserializeTo(directive);

        // Internal interface should always deserialize
        FW_ASSERT(
          Fw::FW_SERIALIZE_OK == _deserStatus,
          static_cast<FwAssertArgType>(_deserStatus)
        );

        // Make sure there was no data left over.
        // That means the buffer size was incorrect.
        FW_ASSERT(
          _msg.getDeserializeSizeLeft() == 0,
          static_cast<FwAssertArgType>(_msg.getDeserializeSizeLeft())
        );

        // Call handler function
        this->directive_pushTime_internalInterfaceHandler(
          directive
        );

        break;
      }

      // Handle internal interface directive_pushTlmVal
      case INT_IF_DIRECTIVE_PUSHTLMVAL: {
        Svc::FpySequencer_PushTlmValDirective directive;
        _deserStatus = _msg.deserializeTo(directive);

        // Internal interface should always deserialize
        FW_ASSERT(
          Fw::FW_SERIALIZE_OK == _deserStatus,
          static_cast<FwAssertArgType>(_deserStatus)
        );

        // Make sure there was no data left over.
        // That means the buffer size was incorrect.
        FW_ASSERT(
          _msg.getDeserializeSizeLeft() == 0,
          static_cast<FwAssertArgType>(_msg.getDeserializeSizeLeft())
        );

        // Call handler function
        this->directive_pushTlmVal_internalInterfaceHandler(
          directive
        );

        break;
      }

      // Handle internal interface directive_pushTlmValAndTime
      case INT_IF_DIRECTIVE_PUSHTLMVALANDTIME: {
        Svc::FpySequencer_PushTlmValAndTimeDirective directive;
        _deserStatus = _msg.deserializeTo(directive);

        // Internal interface should always deserialize
        FW_ASSERT(
          Fw::FW_SERIALIZE_OK == _deserStatus,
          static_cast<FwAssertArgType>(_deserStatus)
        );

        // Make sure there was no data left over.
        // That means the buffer size was incorrect.
        FW_ASSERT(
          _msg.getDeserializeSizeLeft() == 0,
          static_cast<FwAssertArgType>(_msg.getDeserializeSizeLeft())
        );

        // Call handler function
        this->directive_pushTlmValAndTime_internalInterfaceHandler(
          directive
        );

        break;
      }

      // Handle internal interface directive_pushVal
      case INT_IF_DIRECTIVE_PUSHVAL: {
        Svc::FpySequencer_PushValDirective directive;
        _deserStatus = _msg.deserializeTo(directive);

        // Internal interface should always deserialize
        FW_ASSERT(
          Fw::FW_SERIALIZE_OK == _deserStatus,
          static_cast<FwAssertArgType>(_deserStatus)
        );

        // Make sure there was no data left over.
        // That means the buffer size was incorrect.
        FW_ASSERT(
          _msg.getDeserializeSizeLeft() == 0,
          static_cast<FwAssertArgType>(_msg.getDeserializeSizeLeft())
        );

        // Call handler function
        this->directive_pushVal_internalInterfaceHandler(
          directive
        );

        break;
      }

      // Handle internal interface directive_setFlag
      case INT_IF_DIRECTIVE_SETFLAG: {
        Svc::FpySequencer_SetFlagDirective directive;
        _deserStatus = _msg.deserializeTo(directive);

        // Internal interface should always deserialize
        FW_ASSERT(
          Fw::FW_SERIALIZE_OK == _deserStatus,
          static_cast<FwAssertArgType>(_deserStatus)
        );

        // Make sure there was no data left over.
        // That means the buffer size was incorrect.
        FW_ASSERT(
          _msg.getDeserializeSizeLeft() == 0,
          static_cast<FwAssertArgType>(_msg.getDeserializeSizeLeft())
        );

        // Call handler function
        this->directive_setFlag_internalInterfaceHandler(
          directive
        );

        break;
      }

      // Handle internal interface directive_stackCmd
      case INT_IF_DIRECTIVE_STACKCMD: {
        Svc::FpySequencer_StackCmdDirective directive;
        _deserStatus = _msg.deserializeTo(directive);

        // Internal interface should always deserialize
        FW_ASSERT(
          Fw::FW_SERIALIZE_OK == _deserStatus,
          static_cast<FwAssertArgType>(_deserStatus)
        );

        // Make sure there was no data left over.
        // That means the buffer size was incorrect.
        FW_ASSERT(
          _msg.getDeserializeSizeLeft() == 0,
          static_cast<FwAssertArgType>(_msg.getDeserializeSizeLeft())
        );

        // Call handler function
        this->directive_stackCmd_internalInterfaceHandler(
          directive
        );

        break;
      }

      // Handle internal interface directive_stackOp
      case INT_IF_DIRECTIVE_STACKOP: {
        Svc::FpySequencer_StackOpDirective directive;
        _deserStatus = _msg.deserializeTo(directive);

        // Internal interface should always deserialize
        FW_ASSERT(
          Fw::FW_SERIALIZE_OK == _deserStatus,
          static_cast<FwAssertArgType>(_deserStatus)
        );

        // Make sure there was no data left over.
        // That means the buffer size was incorrect.
        FW_ASSERT(
          _msg.getDeserializeSizeLeft() == 0,
          static_cast<FwAssertArgType>(_msg.getDeserializeSizeLeft())
        );

        // Call handler function
        this->directive_stackOp_internalInterfaceHandler(
          directive
        );

        break;
      }

      // Handle internal interface directive_store
      case INT_IF_DIRECTIVE_STORE: {
        Svc::FpySequencer_StoreDirective directive;
        _deserStatus = _msg.deserializeTo(directive);

        // Internal interface should always deserialize
        FW_ASSERT(
          Fw::FW_SERIALIZE_OK == _deserStatus,
          static_cast<FwAssertArgType>(_deserStatus)
        );

        // Make sure there was no data left over.
        // That means the buffer size was incorrect.
        FW_ASSERT(
          _msg.getDeserializeSizeLeft() == 0,
          static_cast<FwAssertArgType>(_msg.getDeserializeSizeLeft())
        );

        // Call handler function
        this->directive_store_internalInterfaceHandler(
          directive
        );

        break;
      }

      // Handle internal interface directive_storeConstOffset
      case INT_IF_DIRECTIVE_STORECONSTOFFSET: {
        Svc::FpySequencer_StoreConstOffsetDirective directive;
        _deserStatus = _msg.deserializeTo(directive);

        // Internal interface should always deserialize
        FW_ASSERT(
          Fw::FW_SERIALIZE_OK == _deserStatus,
          static_cast<FwAssertArgType>(_deserStatus)
        );

        // Make sure there was no data left over.
        // That means the buffer size was incorrect.
        FW_ASSERT(
          _msg.getDeserializeSizeLeft() == 0,
          static_cast<FwAssertArgType>(_msg.getDeserializeSizeLeft())
        );

        // Call handler function
        this->directive_storeConstOffset_internalInterfaceHandler(
          directive
        );

        break;
      }

      // Handle internal interface directive_waitAbs
      case INT_IF_DIRECTIVE_WAITABS: {
        Svc::FpySequencer_WaitAbsDirective directive;
        _deserStatus = _msg.deserializeTo(directive);

        // Internal interface should always deserialize
        FW_ASSERT(
          Fw::FW_SERIALIZE_OK == _deserStatus,
          static_cast<FwAssertArgType>(_deserStatus)
        );

        // Make sure there was no data left over.
        // That means the buffer size was incorrect.
        FW_ASSERT(
          _msg.getDeserializeSizeLeft() == 0,
          static_cast<FwAssertArgType>(_msg.getDeserializeSizeLeft())
        );

        // Call handler function
        this->directive_waitAbs_internalInterfaceHandler(
          directive
        );

        break;
      }

      // Handle internal interface directive_waitRel
      case INT_IF_DIRECTIVE_WAITREL: {
        Svc::FpySequencer_WaitRelDirective directive;
        _deserStatus = _msg.deserializeTo(directive);

        // Internal interface should always deserialize
        FW_ASSERT(
          Fw::FW_SERIALIZE_OK == _deserStatus,
          static_cast<FwAssertArgType>(_deserStatus)
        );

        // Make sure there was no data left over.
        // That means the buffer size was incorrect.
        FW_ASSERT(
          _msg.getDeserializeSizeLeft() == 0,
          static_cast<FwAssertArgType>(_msg.getDeserializeSizeLeft())
        );

        // Call handler function
        this->directive_waitRel_internalInterfaceHandler(
          directive
        );

        break;
      }


      // Handle signals to internal state machines
      case INTERNAL_STATE_MACHINE_SIGNAL:
        this->smDispatch(_msg);
        break;

      default:
        return MSG_DISPATCH_ERROR;
    }

    return MSG_DISPATCH_OK;
  }

  // ----------------------------------------------------------------------
  // Calls for messages received on special input ports
  // ----------------------------------------------------------------------

  void FpySequencerComponentBase ::
    m_p_cmdIn_in(
        Fw::PassiveComponentBase* callComp,
        FwIndexType portNum,
        FwOpcodeType opCode,
        U32 cmdSeq,
        Fw::CmdArgBuffer& args
    )
  {
    FW_ASSERT(callComp);
    FpySequencerComponentBase* compPtr = static_cast<FpySequencerComponentBase*>(callComp);

    const U32 idBase = callComp->getIdBase();
    FW_ASSERT(opCode >= idBase, static_cast<FwAssertArgType>(opCode), static_cast<FwAssertArgType>(idBase));

    // Select base class function based on opcode
    switch (opCode - idBase) {
      case OPCODE_RUN: {
        compPtr->RUN_cmdHandlerBase(
          opCode,
          cmdSeq,
          args
        );
        break;
      }

      case OPCODE_VALIDATE: {
        compPtr->VALIDATE_cmdHandlerBase(
          opCode,
          cmdSeq,
          args
        );
        break;
      }

      case OPCODE_RUN_VALIDATED: {
        compPtr->RUN_VALIDATED_cmdHandlerBase(
          opCode,
          cmdSeq,
          args
        );
        break;
      }

      case OPCODE_CANCEL: {
        compPtr->CANCEL_cmdHandlerBase(
          opCode,
          cmdSeq,
          args
        );
        break;
      }

      case OPCODE_SET_BREAKPOINT: {
        compPtr->SET_BREAKPOINT_cmdHandlerBase(
          opCode,
          cmdSeq,
          args
        );
        break;
      }

      case OPCODE_BREAK: {
        compPtr->BREAK_cmdHandlerBase(
          opCode,
          cmdSeq,
          args
        );
        break;
      }

      case OPCODE_CONTINUE: {
        compPtr->CONTINUE_cmdHandlerBase(
          opCode,
          cmdSeq,
          args
        );
        break;
      }

      case OPCODE_CLEAR_BREAKPOINT: {
        compPtr->CLEAR_BREAKPOINT_cmdHandlerBase(
          opCode,
          cmdSeq,
          args
        );
        break;
      }

      case OPCODE_STEP: {
        compPtr->STEP_cmdHandlerBase(
          opCode,
          cmdSeq,
          args
        );
        break;
      }

      case OPCODE_SET_FLAG: {
        compPtr->SET_FLAG_cmdHandlerBase(
          opCode,
          cmdSeq,
          args
        );
        break;
      }

      case OPCODE_DUMP_STACK_TO_FILE: {
        compPtr->DUMP_STACK_TO_FILE_cmdHandlerBase(
          opCode,
          cmdSeq,
          args
        );
        break;
      }

      case OPCODE_STATEMENT_TIMEOUT_SECS_SET: {
        Fw::CmdResponse _cstat = compPtr->paramSet_STATEMENT_TIMEOUT_SECS(args);
        compPtr->cmdResponse_out(
          opCode,
          cmdSeq,
          _cstat
        );
        break;
      }

      case OPCODE_STATEMENT_TIMEOUT_SECS_SAVE: {
        Fw::CmdResponse _cstat = compPtr->paramSave_STATEMENT_TIMEOUT_SECS();
        compPtr->cmdResponse_out(
          opCode,
          cmdSeq,
          _cstat
        );
        break;
      }

      case OPCODE_FLAG_DEFAULT_EXIT_ON_CMD_FAIL_SET: {
        Fw::CmdResponse _cstat = compPtr->paramSet_FLAG_DEFAULT_EXIT_ON_CMD_FAIL(args);
        compPtr->cmdResponse_out(
          opCode,
          cmdSeq,
          _cstat
        );
        break;
      }

      case OPCODE_FLAG_DEFAULT_EXIT_ON_CMD_FAIL_SAVE: {
        Fw::CmdResponse _cstat = compPtr->paramSave_FLAG_DEFAULT_EXIT_ON_CMD_FAIL();
        compPtr->cmdResponse_out(
          opCode,
          cmdSeq,
          _cstat
        );
        break;
      }
    }
  }

  // ----------------------------------------------------------------------
  // Calls for messages received on typed input ports
  // ----------------------------------------------------------------------

  void FpySequencerComponentBase ::
    m_p_checkTimers_in(
        Fw::PassiveComponentBase* callComp,
        FwIndexType portNum,
        U32 context
    )
  {
    FW_ASSERT(callComp);
    FpySequencerComponentBase* compPtr = static_cast<FpySequencerComponentBase*>(callComp);
    compPtr->checkTimers_handlerBase(
      portNum,
      context
    );
  }

  void FpySequencerComponentBase ::
    m_p_cmdResponseIn_in(
        Fw::PassiveComponentBase* callComp,
        FwIndexType portNum,
        FwOpcodeType opCode,
        U32 cmdSeq,
        const Fw::CmdResponse& response
    )
  {
    FW_ASSERT(callComp);
    FpySequencerComponentBase* compPtr = static_cast<FpySequencerComponentBase*>(callComp);
    compPtr->cmdResponseIn_handlerBase(
      portNum,
      opCode,
      cmdSeq,
      response
    );
  }

  void FpySequencerComponentBase ::
    m_p_pingIn_in(
        Fw::PassiveComponentBase* callComp,
        FwIndexType portNum,
        U32 key
    )
  {
    FW_ASSERT(callComp);
    FpySequencerComponentBase* compPtr = static_cast<FpySequencerComponentBase*>(callComp);
    compPtr->pingIn_handlerBase(
      portNum,
      key
    );
  }

  void FpySequencerComponentBase ::
    m_p_seqRunIn_in(
        Fw::PassiveComponentBase* callComp,
        FwIndexType portNum,
        const Fw::StringBase& filename
    )
  {
    FW_ASSERT(callComp);
    FpySequencerComponentBase* compPtr = static_cast<FpySequencerComponentBase*>(callComp);
    compPtr->seqRunIn_handlerBase(
      portNum,
      filename
    );
  }

  void FpySequencerComponentBase ::
    m_p_tlmWrite_in(
        Fw::PassiveComponentBase* callComp,
        FwIndexType portNum,
        U32 context
    )
  {
    FW_ASSERT(callComp);
    FpySequencerComponentBase* compPtr = static_cast<FpySequencerComponentBase*>(callComp);
    compPtr->tlmWrite_handlerBase(
      portNum,
      context
    );
  }

  // ----------------------------------------------------------------------
  // Send signal helper functions
  // ----------------------------------------------------------------------

  void FpySequencerComponentBase ::
    sendSignalStart(
        SmId smId,
        FwEnumStoreType signal,
        Fw::SerialBufferBase& buffer
    )
  {
    Fw::SerializeStatus status = Fw::FW_SERIALIZE_OK;

    // Serialize the message type
    status = buffer.serializeFrom(static_cast<FwEnumStoreType>(INTERNAL_STATE_MACHINE_SIGNAL));
    FW_ASSERT (status == Fw::FW_SERIALIZE_OK, static_cast<FwAssertArgType>(status));

    // Serialize the port number
    status = buffer.serializeFrom(static_cast<FwIndexType>(0));
    FW_ASSERT (status == Fw::FW_SERIALIZE_OK, static_cast<FwAssertArgType>(status));

    // Serialize the state machine ID
    status = buffer.serializeFrom(static_cast<FwEnumStoreType>(smId));
    FW_ASSERT (status == Fw::FW_SERIALIZE_OK, static_cast<FwAssertArgType>(status));

    // Serialize the signal
    status = buffer.serializeFrom(static_cast<FwEnumStoreType>(signal));
    FW_ASSERT(status == Fw::FW_SERIALIZE_OK, static_cast<FwAssertArgType>(status));
  }

  void FpySequencerComponentBase ::
    sequencer_sendSignalFinish(Fw::LinearBufferBase& buffer)
  {
    // Send message
    Os::Queue::BlockingType _block = Os::Queue::NONBLOCKING;
    Os::Queue::Status qStatus = this->m_queue.send(buffer, 9, _block);

    FW_ASSERT(
      qStatus == Os::Queue::OP_OK,
      static_cast<FwAssertArgType>(qStatus)
    );
  }

  // ----------------------------------------------------------------------
  // Helper functions for state machine dispatch
  // ----------------------------------------------------------------------

  void FpySequencerComponentBase ::
    smDispatch(Fw::SerialBufferBase& buffer)
  {
    // Deserialize the state machine ID and signal
    FwEnumStoreType storedSmId;
    FwEnumStoreType storedSignal;
    FpySequencerComponentBase::deserializeSmIdAndSignal(buffer, storedSmId, storedSignal);

    // Select the target state machine instance
    const SmId smId = static_cast<SmId>(storedSmId);
    switch (smId) {
      case SmId::sequencer: {
        const Svc_FpySequencer_SequencerStateMachine::Signal signal = static_cast<Svc_FpySequencer_SequencerStateMachine::Signal>(storedSignal);
        this->Svc_FpySequencer_SequencerStateMachine_smDispatch(buffer, this->m_stateMachine_sequencer, signal);
        break;
      }
      default:
        FW_ASSERT(0, static_cast<FwAssertArgType>(smId));
        break;
    }
  }

  void FpySequencerComponentBase ::
    deserializeSmIdAndSignal(
        Fw::SerialBufferBase& buffer,
        FwEnumStoreType& smId,
        FwEnumStoreType& signal
    )
  {
    // Move deserialization beyond the message type and port number
    Fw::SerializeStatus status =
      buffer.moveDeserToOffset(ComponentIpcSerializableBuffer::DATA_OFFSET);
    FW_ASSERT(status == Fw::FW_SERIALIZE_OK, static_cast<FwAssertArgType>(status));

    // Deserialize the state machine ID
    status = buffer.deserializeTo(smId);
    FW_ASSERT(status == Fw::FW_SERIALIZE_OK, static_cast<FwAssertArgType>(status));

    // Deserialize the signal
    status = buffer.deserializeTo(signal);
    FW_ASSERT(status == Fw::FW_SERIALIZE_OK, static_cast<FwAssertArgType>(status));
  }

  void FpySequencerComponentBase ::
    Svc_FpySequencer_SequencerStateMachine_smDispatch(
        Fw::SerialBufferBase& buffer,
        Svc_FpySequencer_SequencerStateMachine& sm,
        Svc_FpySequencer_SequencerStateMachine::Signal signal
    )
  {
    switch (signal) {
      case Svc_FpySequencer_SequencerStateMachine::Signal::cmd_VALIDATE: {
        // Deserialize the data
        Svc::FpySequencer_SequenceExecutionArgs value;
        const Fw::SerializeStatus status = buffer.deserializeTo(value);
        FW_ASSERT(status == Fw::FW_SERIALIZE_OK, static_cast<FwAssertArgType>(status));
        // Assert no data left in buffer
        FW_ASSERT(buffer.getDeserializeSizeLeft() == 0, static_cast<FwAssertArgType>(buffer.getDeserializeSizeLeft()));
        // Call the sendSignal function for sm and cmd_VALIDATE
        sm.sendSignal_cmd_VALIDATE(value);
        break;
      }
      case Svc_FpySequencer_SequencerStateMachine::Signal::cmd_RUN: {
        // Deserialize the data
        Svc::FpySequencer_SequenceExecutionArgs value;
        const Fw::SerializeStatus status = buffer.deserializeTo(value);
        FW_ASSERT(status == Fw::FW_SERIALIZE_OK, static_cast<FwAssertArgType>(status));
        // Assert no data left in buffer
        FW_ASSERT(buffer.getDeserializeSizeLeft() == 0, static_cast<FwAssertArgType>(buffer.getDeserializeSizeLeft()));
        // Call the sendSignal function for sm and cmd_RUN
        sm.sendSignal_cmd_RUN(value);
        break;
      }
      case Svc_FpySequencer_SequencerStateMachine::Signal::cmd_RUN_VALIDATED: {
        // Deserialize the data
        Svc::FpySequencer_SequenceExecutionArgs value;
        const Fw::SerializeStatus status = buffer.deserializeTo(value);
        FW_ASSERT(status == Fw::FW_SERIALIZE_OK, static_cast<FwAssertArgType>(status));
        // Assert no data left in buffer
        FW_ASSERT(buffer.getDeserializeSizeLeft() == 0, static_cast<FwAssertArgType>(buffer.getDeserializeSizeLeft()));
        // Call the sendSignal function for sm and cmd_RUN_VALIDATED
        sm.sendSignal_cmd_RUN_VALIDATED(value);
        break;
      }
      case Svc_FpySequencer_SequencerStateMachine::Signal::cmd_CANCEL: {
        // Assert no data left in buffer
        FW_ASSERT(buffer.getDeserializeSizeLeft() == 0, static_cast<FwAssertArgType>(buffer.getDeserializeSizeLeft()));
        // Call the sendSignal function for sm and cmd_CANCEL
        sm.sendSignal_cmd_CANCEL();
        break;
      }
      case Svc_FpySequencer_SequencerStateMachine::Signal::cmd_SET_BREAKPOINT: {
        // Deserialize the data
        Svc::FpySequencer_BreakpointArgs value;
        const Fw::SerializeStatus status = buffer.deserializeTo(value);
        FW_ASSERT(status == Fw::FW_SERIALIZE_OK, static_cast<FwAssertArgType>(status));
        // Assert no data left in buffer
        FW_ASSERT(buffer.getDeserializeSizeLeft() == 0, static_cast<FwAssertArgType>(buffer.getDeserializeSizeLeft()));
        // Call the sendSignal function for sm and cmd_SET_BREAKPOINT
        sm.sendSignal_cmd_SET_BREAKPOINT(value);
        break;
      }
      case Svc_FpySequencer_SequencerStateMachine::Signal::cmd_CLEAR_BREAKPOINT: {
        // Assert no data left in buffer
        FW_ASSERT(buffer.getDeserializeSizeLeft() == 0, static_cast<FwAssertArgType>(buffer.getDeserializeSizeLeft()));
        // Call the sendSignal function for sm and cmd_CLEAR_BREAKPOINT
        sm.sendSignal_cmd_CLEAR_BREAKPOINT();
        break;
      }
      case Svc_FpySequencer_SequencerStateMachine::Signal::result_failure: {
        // Assert no data left in buffer
        FW_ASSERT(buffer.getDeserializeSizeLeft() == 0, static_cast<FwAssertArgType>(buffer.getDeserializeSizeLeft()));
        // Call the sendSignal function for sm and result_failure
        sm.sendSignal_result_failure();
        break;
      }
      case Svc_FpySequencer_SequencerStateMachine::Signal::result_success: {
        // Assert no data left in buffer
        FW_ASSERT(buffer.getDeserializeSizeLeft() == 0, static_cast<FwAssertArgType>(buffer.getDeserializeSizeLeft()));
        // Call the sendSignal function for sm and result_success
        sm.sendSignal_result_success();
        break;
      }
      case Svc_FpySequencer_SequencerStateMachine::Signal::entered: {
        // Assert no data left in buffer
        FW_ASSERT(buffer.getDeserializeSizeLeft() == 0, static_cast<FwAssertArgType>(buffer.getDeserializeSizeLeft()));
        // Call the sendSignal function for sm and entered
        sm.sendSignal_entered();
        break;
      }
      case Svc_FpySequencer_SequencerStateMachine::Signal::result_dispatchStatement_success: {
        // Assert no data left in buffer
        FW_ASSERT(buffer.getDeserializeSizeLeft() == 0, static_cast<FwAssertArgType>(buffer.getDeserializeSizeLeft()));
        // Call the sendSignal function for sm and result_dispatchStatement_success
        sm.sendSignal_result_dispatchStatement_success();
        break;
      }
      case Svc_FpySequencer_SequencerStateMachine::Signal::result_dispatchStatement_failure: {
        // Assert no data left in buffer
        FW_ASSERT(buffer.getDeserializeSizeLeft() == 0, static_cast<FwAssertArgType>(buffer.getDeserializeSizeLeft()));
        // Call the sendSignal function for sm and result_dispatchStatement_failure
        sm.sendSignal_result_dispatchStatement_failure();
        break;
      }
      case Svc_FpySequencer_SequencerStateMachine::Signal::result_dispatchStatement_noMoreStatements: {
        // Assert no data left in buffer
        FW_ASSERT(buffer.getDeserializeSizeLeft() == 0, static_cast<FwAssertArgType>(buffer.getDeserializeSizeLeft()));
        // Call the sendSignal function for sm and result_dispatchStatement_noMoreStatements
        sm.sendSignal_result_dispatchStatement_noMoreStatements();
        break;
      }
      case Svc_FpySequencer_SequencerStateMachine::Signal::checkTimersIn: {
        // Assert no data left in buffer
        FW_ASSERT(buffer.getDeserializeSizeLeft() == 0, static_cast<FwAssertArgType>(buffer.getDeserializeSizeLeft()));
        // Call the sendSignal function for sm and checkTimersIn
        sm.sendSignal_checkTimersIn();
        break;
      }
      case Svc_FpySequencer_SequencerStateMachine::Signal::result_checkShouldWake_wakeup: {
        // Assert no data left in buffer
        FW_ASSERT(buffer.getDeserializeSizeLeft() == 0, static_cast<FwAssertArgType>(buffer.getDeserializeSizeLeft()));
        // Call the sendSignal function for sm and result_checkShouldWake_wakeup
        sm.sendSignal_result_checkShouldWake_wakeup();
        break;
      }
      case Svc_FpySequencer_SequencerStateMachine::Signal::result_checkShouldWake_keepSleeping: {
        // Assert no data left in buffer
        FW_ASSERT(buffer.getDeserializeSizeLeft() == 0, static_cast<FwAssertArgType>(buffer.getDeserializeSizeLeft()));
        // Call the sendSignal function for sm and result_checkShouldWake_keepSleeping
        sm.sendSignal_result_checkShouldWake_keepSleeping();
        break;
      }
      case Svc_FpySequencer_SequencerStateMachine::Signal::result_timeOpFailed: {
        // Assert no data left in buffer
        FW_ASSERT(buffer.getDeserializeSizeLeft() == 0, static_cast<FwAssertArgType>(buffer.getDeserializeSizeLeft()));
        // Call the sendSignal function for sm and result_timeOpFailed
        sm.sendSignal_result_timeOpFailed();
        break;
      }
      case Svc_FpySequencer_SequencerStateMachine::Signal::stmtResponse_beginSleep: {
        // Assert no data left in buffer
        FW_ASSERT(buffer.getDeserializeSizeLeft() == 0, static_cast<FwAssertArgType>(buffer.getDeserializeSizeLeft()));
        // Call the sendSignal function for sm and stmtResponse_beginSleep
        sm.sendSignal_stmtResponse_beginSleep();
        break;
      }
      case Svc_FpySequencer_SequencerStateMachine::Signal::stmtResponse_success: {
        // Assert no data left in buffer
        FW_ASSERT(buffer.getDeserializeSizeLeft() == 0, static_cast<FwAssertArgType>(buffer.getDeserializeSizeLeft()));
        // Call the sendSignal function for sm and stmtResponse_success
        sm.sendSignal_stmtResponse_success();
        break;
      }
      case Svc_FpySequencer_SequencerStateMachine::Signal::stmtResponse_failure: {
        // Assert no data left in buffer
        FW_ASSERT(buffer.getDeserializeSizeLeft() == 0, static_cast<FwAssertArgType>(buffer.getDeserializeSizeLeft()));
        // Call the sendSignal function for sm and stmtResponse_failure
        sm.sendSignal_stmtResponse_failure();
        break;
      }
      case Svc_FpySequencer_SequencerStateMachine::Signal::stmtResponse_unexpected: {
        // Assert no data left in buffer
        FW_ASSERT(buffer.getDeserializeSizeLeft() == 0, static_cast<FwAssertArgType>(buffer.getDeserializeSizeLeft()));
        // Call the sendSignal function for sm and stmtResponse_unexpected
        sm.sendSignal_stmtResponse_unexpected();
        break;
      }
      case Svc_FpySequencer_SequencerStateMachine::Signal::stmtResponse_keepWaiting: {
        // Assert no data left in buffer
        FW_ASSERT(buffer.getDeserializeSizeLeft() == 0, static_cast<FwAssertArgType>(buffer.getDeserializeSizeLeft()));
        // Call the sendSignal function for sm and stmtResponse_keepWaiting
        sm.sendSignal_stmtResponse_keepWaiting();
        break;
      }
      case Svc_FpySequencer_SequencerStateMachine::Signal::result_checkStatementTimeout_statementTimeout: {
        // Assert no data left in buffer
        FW_ASSERT(buffer.getDeserializeSizeLeft() == 0, static_cast<FwAssertArgType>(buffer.getDeserializeSizeLeft()));
        // Call the sendSignal function for sm and result_checkStatementTimeout_statementTimeout
        sm.sendSignal_result_checkStatementTimeout_statementTimeout();
        break;
      }
      case Svc_FpySequencer_SequencerStateMachine::Signal::result_checkStatementTimeout_noTimeout: {
        // Assert no data left in buffer
        FW_ASSERT(buffer.getDeserializeSizeLeft() == 0, static_cast<FwAssertArgType>(buffer.getDeserializeSizeLeft()));
        // Call the sendSignal function for sm and result_checkStatementTimeout_noTimeout
        sm.sendSignal_result_checkStatementTimeout_noTimeout();
        break;
      }
      case Svc_FpySequencer_SequencerStateMachine::Signal::cmd_CONTINUE: {
        // Assert no data left in buffer
        FW_ASSERT(buffer.getDeserializeSizeLeft() == 0, static_cast<FwAssertArgType>(buffer.getDeserializeSizeLeft()));
        // Call the sendSignal function for sm and cmd_CONTINUE
        sm.sendSignal_cmd_CONTINUE();
        break;
      }
      case Svc_FpySequencer_SequencerStateMachine::Signal::cmd_BREAK: {
        // Assert no data left in buffer
        FW_ASSERT(buffer.getDeserializeSizeLeft() == 0, static_cast<FwAssertArgType>(buffer.getDeserializeSizeLeft()));
        // Call the sendSignal function for sm and cmd_BREAK
        sm.sendSignal_cmd_BREAK();
        break;
      }
      case Svc_FpySequencer_SequencerStateMachine::Signal::cmd_STEP: {
        // Assert no data left in buffer
        FW_ASSERT(buffer.getDeserializeSizeLeft() == 0, static_cast<FwAssertArgType>(buffer.getDeserializeSizeLeft()));
        // Call the sendSignal function for sm and cmd_STEP
        sm.sendSignal_cmd_STEP();
        break;
      }
      default:
        FW_ASSERT(0, static_cast<FwAssertArgType>(signal));
        break;
    }
  }

  // ----------------------------------------------------------------------
  // Parameter set functions
  // ----------------------------------------------------------------------

  Fw::CmdResponse FpySequencerComponentBase ::
    paramSet_STATEMENT_TIMEOUT_SECS(Fw::SerialBufferBase& val)
  {
    F32 _localVal{};
    const Fw::SerializeStatus _stat = val.deserializeTo(_localVal);
    if (_stat != Fw::FW_SERIALIZE_OK) {
      return Fw::CmdResponse::VALIDATION_ERROR;
    }

    // Assign value only if successfully deserialized
    this->m_paramLock.lock();
    this->m_STATEMENT_TIMEOUT_SECS = _localVal;
    this->m_param_STATEMENT_TIMEOUT_SECS_valid = Fw::ParamValid::VALID;
    this->m_paramLock.unLock();

    // Call notifier
    this->parameterUpdated(PARAMID_STATEMENT_TIMEOUT_SECS);
    return Fw::CmdResponse::OK;
  }

  Fw::CmdResponse FpySequencerComponentBase ::
    paramSet_FLAG_DEFAULT_EXIT_ON_CMD_FAIL(Fw::SerialBufferBase& val)
  {
    bool _localVal{};
    const Fw::SerializeStatus _stat = val.deserializeTo(_localVal);
    if (_stat != Fw::FW_SERIALIZE_OK) {
      return Fw::CmdResponse::VALIDATION_ERROR;
    }

    // Assign value only if successfully deserialized
    this->m_paramLock.lock();
    this->m_FLAG_DEFAULT_EXIT_ON_CMD_FAIL = _localVal;
    this->m_param_FLAG_DEFAULT_EXIT_ON_CMD_FAIL_valid = Fw::ParamValid::VALID;
    this->m_paramLock.unLock();

    // Call notifier
    this->parameterUpdated(PARAMID_FLAG_DEFAULT_EXIT_ON_CMD_FAIL);
    return Fw::CmdResponse::OK;
  }

  // ----------------------------------------------------------------------
  // Parameter save functions
  // ----------------------------------------------------------------------

  Fw::CmdResponse FpySequencerComponentBase ::
    paramSave_STATEMENT_TIMEOUT_SECS()
  {
    Fw::ParamBuffer _saveBuff;
    FwPrmIdType _id;
    Fw::SerializeStatus _stat;
    if (this->m_prmSet_OutputPort[0].isConnected()) {
      this->m_paramLock.lock();

      _stat = _saveBuff.serializeFrom(m_STATEMENT_TIMEOUT_SECS);

      this->m_paramLock.unLock();
      if (_stat != Fw::FW_SERIALIZE_OK) {
        return Fw::CmdResponse::VALIDATION_ERROR;
      }

      _id = static_cast<FwPrmIdType>(this->getIdBase() + PARAMID_STATEMENT_TIMEOUT_SECS);

      // Save the parameter
      this->m_prmSet_OutputPort[0].invoke(
        _id,
        _saveBuff
      );

      return Fw::CmdResponse::OK;
    }

    return Fw::CmdResponse::EXECUTION_ERROR;
  }

  Fw::CmdResponse FpySequencerComponentBase ::
    paramSave_FLAG_DEFAULT_EXIT_ON_CMD_FAIL()
  {
    Fw::ParamBuffer _saveBuff;
    FwPrmIdType _id;
    Fw::SerializeStatus _stat;
    if (this->m_prmSet_OutputPort[0].isConnected()) {
      this->m_paramLock.lock();

      _stat = _saveBuff.serializeFrom(m_FLAG_DEFAULT_EXIT_ON_CMD_FAIL);

      this->m_paramLock.unLock();
      if (_stat != Fw::FW_SERIALIZE_OK) {
        return Fw::CmdResponse::VALIDATION_ERROR;
      }

      _id = static_cast<FwPrmIdType>(this->getIdBase() + PARAMID_FLAG_DEFAULT_EXIT_ON_CMD_FAIL);

      // Save the parameter
      this->m_prmSet_OutputPort[0].invoke(
        _id,
        _saveBuff
      );

      return Fw::CmdResponse::OK;
    }

    return Fw::CmdResponse::EXECUTION_ERROR;
  }

}
