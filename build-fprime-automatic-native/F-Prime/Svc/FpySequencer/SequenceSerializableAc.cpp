// ======================================================================
// \title  SequenceSerializableAc.cpp
// \author Generated by fpp-to-cpp
// \brief  cpp file for Sequence struct
// ======================================================================

#include "Fw/Types/Assert.hpp"
#include "Svc/FpySequencer/SequenceSerializableAc.hpp"

namespace Svc {

  namespace Fpy {

    // ----------------------------------------------------------------------
    // Constructors
    // ----------------------------------------------------------------------

    Sequence ::
      Sequence() :
        Serializable(),
        m_header(),
        m_args(),
        m_statements(),
        m_footer()
    {

    }

    Sequence ::
      Sequence(
          const Svc::Fpy::Header& header,
          const Type_of_args& args,
          const Type_of_statements& statements,
          const Svc::Fpy::Footer& footer
      ) :
        Serializable(),
        m_header(header),
        m_footer(footer)
    {
      for (FwSizeType i = 0; i < 16; i++) {
        this->m_args[i] = args[i];
      }
      for (FwSizeType i = 0; i < 1024; i++) {
        this->m_statements[i] = statements[i];
      }
    }

    Sequence ::
      Sequence(const Sequence& obj) :
        Serializable(),
        m_header(obj.m_header),
        m_footer(obj.m_footer)
    {
      for (FwSizeType i = 0; i < 16; i++) {
        this->m_args[i] = obj.m_args[i];
      }
      for (FwSizeType i = 0; i < 1024; i++) {
        this->m_statements[i] = obj.m_statements[i];
      }
    }

    Sequence ::
      Sequence(
          const Svc::Fpy::Header& header,
          U8 args,
          const Svc::Fpy::Statement& statements,
          const Svc::Fpy::Footer& footer
      ) :
        Serializable(),
        m_header(header),
        m_footer(footer)
    {
      for (FwSizeType i = 0; i < 16; i++) {
        this->m_args[i] = args;
      }
      for (FwSizeType i = 0; i < 1024; i++) {
        this->m_statements[i] = statements;
      }
    }

    // ----------------------------------------------------------------------
    // Operators
    // ----------------------------------------------------------------------

    Sequence& Sequence ::
      operator=(const Sequence& obj)
    {
      if (this == &obj) {
        return *this;
      }

      set(obj.m_header, obj.m_args, obj.m_statements, obj.m_footer);
      return *this;
    }

    bool Sequence ::
      operator==(const Sequence& obj) const
    {
      if (this == &obj) { return true; }

      // Compare non-array members
      if (!(
        (this->m_header == obj.m_header) &&
        (this->m_footer == obj.m_footer)
      )) {
        return false;
      }

      // Compare array members
      for (FwSizeType i = 0; i < 16; i++) {
        if (!(this->m_args[i] == obj.m_args[i])) {
          return false;
        }
      }
      for (FwSizeType i = 0; i < 1024; i++) {
        if (!(this->m_statements[i] == obj.m_statements[i])) {
          return false;
        }
      }

      return true;
    }

    bool Sequence ::
      operator!=(const Sequence& obj) const
    {
      return !(*this == obj);
    }

#ifdef BUILD_UT

    std::ostream& operator<<(std::ostream& os, const Sequence& obj) {
      Fw::String s;
      obj.toString(s);
      os << s.toChar();
      return os;
    }

#endif

    // ----------------------------------------------------------------------
    // Member functions
    // ----------------------------------------------------------------------

    Fw::SerializeStatus Sequence ::
      serializeTo(
          Fw::SerialBufferBase& buffer,
          Fw::Endianness mode
      ) const
    {
      Fw::SerializeStatus status;

      status = buffer.serializeFrom(this->m_header, mode);
      if (status != Fw::FW_SERIALIZE_OK) {
        return status;
      }
      for (FwSizeType i = 0; i < 16; i++) {
        status = buffer.serializeFrom(this->m_args[i], mode);
        if (status != Fw::FW_SERIALIZE_OK) {
          return status;
        }
      }
      for (FwSizeType i = 0; i < 1024; i++) {
        status = buffer.serializeFrom(this->m_statements[i], mode);
        if (status != Fw::FW_SERIALIZE_OK) {
          return status;
        }
      }
      status = buffer.serializeFrom(this->m_footer, mode);
      if (status != Fw::FW_SERIALIZE_OK) {
        return status;
      }

      return status;
    }

    Fw::SerializeStatus Sequence ::
      deserializeFrom(
          Fw::SerialBufferBase& buffer,
          Fw::Endianness mode
      )
    {
      Fw::SerializeStatus status;

      status = buffer.deserializeTo(this->m_header, mode);
      if (status != Fw::FW_SERIALIZE_OK) {
        return status;
      }
      for (FwSizeType i = 0; i < 16; i++) {
        status = buffer.deserializeTo(this->m_args[i], mode);
        if (status != Fw::FW_SERIALIZE_OK) {
          return status;
        }
      }
      for (FwSizeType i = 0; i < 1024; i++) {
        status = buffer.deserializeTo(this->m_statements[i], mode);
        if (status != Fw::FW_SERIALIZE_OK) {
          return status;
        }
      }
      status = buffer.deserializeTo(this->m_footer, mode);
      if (status != Fw::FW_SERIALIZE_OK) {
        return status;
      }

      return status;
    }

    FwSizeType Sequence ::
      serializedSize() const
    {
      FwSizeType size = 0;
      size += this->m_header.serializedSize();
      size += sizeof(U8) * 16;
      for (U32 index = 0; index < 1024; index++) {
        size += this->m_statements[index].serializedSize();
      }
      size += this->m_footer.serializedSize();
      return size;
    }

#if FW_SERIALIZABLE_TO_STRING

    void Sequence ::
      toString(Fw::StringBase& sb) const
    {
      Fw::String tmp;
      sb = "( ";

      // Format header
      sb += "header = ";
      this->m_header.toString(tmp);
      sb += tmp;
      sb += ", ";

      // Format args
      sb += "args = ";
      sb += "[ ";
      for (FwSizeType i = 0; i < 16; i++) {
        tmp.format("%" PRIu8 "", this->m_args[i]);
        if (i > 0) {
          sb += ", ";
        }
        sb += tmp;
      }
      sb += " ]";
      sb += ", ";

      // Format statements
      sb += "statements = ";
      sb += "[ ";
      for (FwSizeType i = 0; i < 1024; i++) {
        this->m_statements[i].toString(tmp);
        if (i > 0) {
          sb += ", ";
        }
        sb += tmp;
      }
      sb += " ]";
      sb += ", ";

      // Format footer
      sb += "footer = ";
      this->m_footer.toString(tmp);
      sb += tmp;
      sb += " )";
    }

#endif

    // ----------------------------------------------------------------------
    // Setter functions
    // ----------------------------------------------------------------------

    void Sequence ::
      set(
          const Svc::Fpy::Header& header,
          const Type_of_args& args,
          const Type_of_statements& statements,
          const Svc::Fpy::Footer& footer
      )
    {
      this->m_header = header;
      this->m_footer = footer;

      for (FwSizeType i = 0; i < 16; i++) {
        this->m_args[i] = args[i];
      }
      for (FwSizeType i = 0; i < 1024; i++) {
        this->m_statements[i] = statements[i];
      }
    }

    void Sequence ::
      set_header(const Svc::Fpy::Header& header)
    {
      this->m_header = header;
    }

    void Sequence ::
      set_args(const Type_of_args& args)
    {
      for (FwSizeType i = 0; i < 16; i++) {
        this->m_args[i] = args[i];
      }
    }

    void Sequence ::
      set_statements(const Type_of_statements& statements)
    {
      for (FwSizeType i = 0; i < 1024; i++) {
        this->m_statements[i] = statements[i];
      }
    }

    void Sequence ::
      set_footer(const Svc::Fpy::Footer& footer)
    {
      this->m_footer = footer;
    }

  }

}
