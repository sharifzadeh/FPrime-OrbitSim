// ======================================================================
// \title  SpacePacketHeaderSerializableAc.cpp
// \author Generated by fpp-to-cpp
// \brief  cpp file for SpacePacketHeader struct
// ======================================================================

#include "Fw/Types/Assert.hpp"
#include "Svc/Ccsds/Types/SpacePacketHeaderSerializableAc.hpp"

namespace Svc {

  namespace Ccsds {

    // ----------------------------------------------------------------------
    // Constructors
    // ----------------------------------------------------------------------

    SpacePacketHeader ::
      SpacePacketHeader() :
        Serializable(),
        m_packetIdentification(),
        m_packetSequenceControl(),
        m_packetDataLength()
    {

    }

    SpacePacketHeader ::
      SpacePacketHeader(
          U16 packetIdentification,
          U16 packetSequenceControl,
          U16 packetDataLength
      ) :
        Serializable(),
        m_packetIdentification(packetIdentification),
        m_packetSequenceControl(packetSequenceControl),
        m_packetDataLength(packetDataLength)
    {

    }

    SpacePacketHeader ::
      SpacePacketHeader(const SpacePacketHeader& obj) :
        Serializable(),
        m_packetIdentification(obj.m_packetIdentification),
        m_packetSequenceControl(obj.m_packetSequenceControl),
        m_packetDataLength(obj.m_packetDataLength)
    {

    }

    // ----------------------------------------------------------------------
    // Operators
    // ----------------------------------------------------------------------

    SpacePacketHeader& SpacePacketHeader ::
      operator=(const SpacePacketHeader& obj)
    {
      if (this == &obj) {
        return *this;
      }

      set(obj.m_packetIdentification, obj.m_packetSequenceControl, obj.m_packetDataLength);
      return *this;
    }

    bool SpacePacketHeader ::
      operator==(const SpacePacketHeader& obj) const
    {
      if (this == &obj) { return true; }
      return (
        (this->m_packetIdentification == obj.m_packetIdentification) &&
        (this->m_packetSequenceControl == obj.m_packetSequenceControl) &&
        (this->m_packetDataLength == obj.m_packetDataLength)
      );
    }

    bool SpacePacketHeader ::
      operator!=(const SpacePacketHeader& obj) const
    {
      return !(*this == obj);
    }

#ifdef BUILD_UT

    std::ostream& operator<<(std::ostream& os, const SpacePacketHeader& obj) {
      Fw::String s;
      obj.toString(s);
      os << s.toChar();
      return os;
    }

#endif

    // ----------------------------------------------------------------------
    // Member functions
    // ----------------------------------------------------------------------

    Fw::SerializeStatus SpacePacketHeader ::
      serializeTo(
          Fw::SerialBufferBase& buffer,
          Fw::Endianness mode
      ) const
    {
      Fw::SerializeStatus status;

      status = buffer.serializeFrom(this->m_packetIdentification, mode);
      if (status != Fw::FW_SERIALIZE_OK) {
        return status;
      }
      status = buffer.serializeFrom(this->m_packetSequenceControl, mode);
      if (status != Fw::FW_SERIALIZE_OK) {
        return status;
      }
      status = buffer.serializeFrom(this->m_packetDataLength, mode);
      if (status != Fw::FW_SERIALIZE_OK) {
        return status;
      }

      return status;
    }

    Fw::SerializeStatus SpacePacketHeader ::
      deserializeFrom(
          Fw::SerialBufferBase& buffer,
          Fw::Endianness mode
      )
    {
      Fw::SerializeStatus status;

      status = buffer.deserializeTo(this->m_packetIdentification, mode);
      if (status != Fw::FW_SERIALIZE_OK) {
        return status;
      }
      status = buffer.deserializeTo(this->m_packetSequenceControl, mode);
      if (status != Fw::FW_SERIALIZE_OK) {
        return status;
      }
      status = buffer.deserializeTo(this->m_packetDataLength, mode);
      if (status != Fw::FW_SERIALIZE_OK) {
        return status;
      }

      return status;
    }

    FwSizeType SpacePacketHeader ::
      serializedSize() const
    {
      FwSizeType size = 0;
      size += sizeof(U16);
      size += sizeof(U16);
      size += sizeof(U16);
      return size;
    }

#if FW_SERIALIZABLE_TO_STRING

    void SpacePacketHeader ::
      toString(Fw::StringBase& sb) const
    {
      Fw::String tmp;
      sb = "( ";

      // Format packetIdentification
      sb += "packetIdentification = ";
      tmp.format("%" PRIu16 "", this->m_packetIdentification);
      sb += tmp;
      sb += ", ";

      // Format packetSequenceControl
      sb += "packetSequenceControl = ";
      tmp.format("%" PRIu16 "", this->m_packetSequenceControl);
      sb += tmp;
      sb += ", ";

      // Format packetDataLength
      sb += "packetDataLength = ";
      tmp.format("%" PRIu16 "", this->m_packetDataLength);
      sb += tmp;
      sb += " )";
    }

#endif

    // ----------------------------------------------------------------------
    // Setter functions
    // ----------------------------------------------------------------------

    void SpacePacketHeader ::
      set(
          U16 packetIdentification,
          U16 packetSequenceControl,
          U16 packetDataLength
      )
    {
      this->m_packetIdentification = packetIdentification;
      this->m_packetSequenceControl = packetSequenceControl;
      this->m_packetDataLength = packetDataLength;
    }

    void SpacePacketHeader ::
      set_packetIdentification(U16 packetIdentification)
    {
      this->m_packetIdentification = packetIdentification;
    }

    void SpacePacketHeader ::
      set_packetSequenceControl(U16 packetSequenceControl)
    {
      this->m_packetSequenceControl = packetSequenceControl;
    }

    void SpacePacketHeader ::
      set_packetDataLength(U16 packetDataLength)
    {
      this->m_packetDataLength = packetDataLength;
    }

  }

}
